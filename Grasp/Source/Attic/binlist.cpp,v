head	1.1;
access;
symbols
	Monaco_Aidan:1.1.6.15.0.2
	Root-of-Monaco_Aidan:1.1.6.15
	Monaco:1.1.0.6
	PreMonaco:1.1
	PMONACO:1.1.0.4
	P_MonacoSource:1.1.0.2;
locks; strict;
comment	@// @;


1.1
date	2005.04.07.00.04.52;	author saubry;	state dead;
branches
	1.1.2.1
	1.1.4.1
	1.1.6.1;
next	;

1.1.2.1
date	2005.04.07.00.04.52;	author saubry;	state Exp;
branches;
next	1.1.2.2;

1.1.2.2
date	2005.04.08.00.04.39;	author saubry;	state Exp;
branches;
next	1.1.2.3;

1.1.2.3
date	2005.04.12.16.31.04;	author saubry;	state Exp;
branches;
next	1.1.2.4;

1.1.2.4
date	2005.04.12.17.25.34;	author saubry;	state Exp;
branches;
next	;

1.1.4.1
date	2005.04.12.22.58.05;	author saubry;	state Exp;
branches;
next	;

1.1.6.1
date	2005.05.03.22.14.52;	author athomps;	state Exp;
branches;
next	1.1.6.2;

1.1.6.2
date	2005.05.04.21.40.07;	author saubry;	state Exp;
branches;
next	1.1.6.3;

1.1.6.3
date	2005.05.10.23.31.54;	author saubry;	state Exp;
branches;
next	1.1.6.4;

1.1.6.4
date	2005.05.11.19.15.57;	author athomps;	state Exp;
branches;
next	1.1.6.5;

1.1.6.5
date	2005.05.12.00.14.42;	author saubry;	state Exp;
branches;
next	1.1.6.6;

1.1.6.6
date	2005.05.16.18.19.11;	author athomps;	state Exp;
branches;
next	1.1.6.7;

1.1.6.7
date	2005.05.18.20.53.08;	author saubry;	state Exp;
branches;
next	1.1.6.8;

1.1.6.8
date	2005.05.18.20.54.06;	author saubry;	state Exp;
branches;
next	1.1.6.9;

1.1.6.9
date	2005.05.23.18.33.40;	author saubry;	state Exp;
branches;
next	1.1.6.10;

1.1.6.10
date	2005.05.23.18.41.50;	author saubry;	state Exp;
branches;
next	1.1.6.11;

1.1.6.11
date	2005.05.23.19.58.48;	author saubry;	state Exp;
branches;
next	1.1.6.12;

1.1.6.12
date	2005.06.06.17.30.01;	author saubry;	state Exp;
branches;
next	1.1.6.13;

1.1.6.13
date	2005.06.09.18.51.21;	author saubry;	state Exp;
branches;
next	1.1.6.14;

1.1.6.14
date	2005.06.09.19.40.57;	author saubry;	state Exp;
branches;
next	1.1.6.15;

1.1.6.15
date	2005.06.10.23.35.38;	author saubry;	state Exp;
branches
	1.1.6.15.2.1;
next	;

1.1.6.15.2.1
date	2005.06.15.20.29.11;	author athomps;	state Exp;
branches;
next	1.1.6.15.2.2;

1.1.6.15.2.2
date	2005.06.15.23.26.07;	author athomps;	state Exp;
branches;
next	1.1.6.15.2.3;

1.1.6.15.2.3
date	2005.07.05.22.39.47;	author saubry;	state Exp;
branches;
next	1.1.6.15.2.4;

1.1.6.15.2.4
date	2005.07.08.23.16.36;	author saubry;	state Exp;
branches;
next	1.1.6.15.2.5;

1.1.6.15.2.5
date	2005.07.19.22.56.35;	author saubry;	state Exp;
branches;
next	1.1.6.15.2.6;

1.1.6.15.2.6
date	2005.07.20.23.18.47;	author saubry;	state Exp;
branches;
next	1.1.6.15.2.7;

1.1.6.15.2.7
date	2005.07.28.23.17.30;	author saubry;	state Exp;
branches;
next	1.1.6.15.2.8;

1.1.6.15.2.8
date	2005.08.04.18.28.14;	author saubry;	state Exp;
branches;
next	1.1.6.15.2.9;

1.1.6.15.2.9
date	2005.08.09.22.50.06;	author saubry;	state Exp;
branches;
next	1.1.6.15.2.10;

1.1.6.15.2.10
date	2005.08.12.23.55.22;	author saubry;	state Exp;
branches;
next	1.1.6.15.2.11;

1.1.6.15.2.11
date	2005.09.12.21.02.47;	author saubry;	state Exp;
branches;
next	1.1.6.15.2.12;

1.1.6.15.2.12
date	2005.10.11.21.43.24;	author saubry;	state Exp;
branches;
next	1.1.6.15.2.13;

1.1.6.15.2.13
date	2005.10.21.15.44.43;	author saubry;	state Exp;
branches;
next	1.1.6.15.2.14;

1.1.6.15.2.14
date	2005.11.01.21.17.20;	author saubry;	state Exp;
branches;
next	1.1.6.15.2.15;

1.1.6.15.2.15
date	2005.11.17.20.43.30;	author athomps;	state Exp;
branches;
next	1.1.6.15.2.16;

1.1.6.15.2.16
date	2005.11.28.23.08.47;	author saubry;	state Exp;
branches;
next	1.1.6.15.2.17;

1.1.6.15.2.17
date	2005.12.09.18.35.27;	author athomps;	state Exp;
branches;
next	1.1.6.15.2.18;

1.1.6.15.2.18
date	2005.12.19.17.57.04;	author athomps;	state Exp;
branches;
next	1.1.6.15.2.19;

1.1.6.15.2.19
date	2006.01.18.18.24.50;	author athomps;	state Exp;
branches;
next	1.1.6.15.2.20;

1.1.6.15.2.20
date	2006.02.02.23.40.43;	author athomps;	state Exp;
branches;
next	1.1.6.15.2.21;

1.1.6.15.2.21
date	2006.02.03.19.07.27;	author athomps;	state Exp;
branches;
next	1.1.6.15.2.22;

1.1.6.15.2.22
date	2006.02.06.19.15.25;	author athomps;	state Exp;
branches;
next	1.1.6.15.2.23;

1.1.6.15.2.23
date	2006.02.06.21.27.39;	author saubry;	state Exp;
branches;
next	1.1.6.15.2.24;

1.1.6.15.2.24
date	2006.02.06.21.41.58;	author saubry;	state Exp;
branches;
next	1.1.6.15.2.25;

1.1.6.15.2.25
date	2006.02.08.23.43.02;	author athomps;	state Exp;
branches;
next	1.1.6.15.2.26;

1.1.6.15.2.26
date	2006.02.15.21.34.48;	author athomps;	state Exp;
branches;
next	1.1.6.15.2.27;

1.1.6.15.2.27
date	2006.02.16.00.32.33;	author athomps;	state Exp;
branches;
next	;


desc
@@


1.1
log
@file binlist.cpp was initially added on branch P_MonacoSource.
@
text
@@


1.1.6.1
log
@Added new files to Monaco branch.
@
text
@a0 765
//-----------------------------------------------------------------------
//
//   G R A S P
//   ____________
//   \           \
//    \ General   \
//     \ Reactive  \
//      \ Atomistic \
//       \ Simulation\
//        \ Program   \
//         \___________\
//
//    Timestamp: April 1, 2005
//    Version: 4.0
//
//    Primary Author: Aidan P. Thompson
//
//    e-mail: athomps@@sandia.gov
//   
//    Copyright (2005) Sandia National Laboratories
//
//    Sandia National Laboratories is a multiprogram laboratory 
//    operated by Sandia Corporation, a Lockheed Martin company,
//    for the United States Department of Energy under contract
//    No. DE-AC04-94AL-85000.
//
//    Under the terms of Contract DE-AC04-94AL85000 with Sandia 
//    Corporation, the U.S. Government retains certain rights in 
//    this software.
//
//    This software is distributed under the terms of the GNU Public 
//    License (GPL). For a copy of the GPL see the file 
//    Grasp/Documentation/LICENSE or visit the GNU website at 
//    http://www.gnu.org/copyleft/gpl.html. Briefly, the GPL 
//    entitles you to use the software, modify it and redistribute it. 
//    The main thing you can not do is apply any other licensing 
//    terms to the software. Also, if any part of this sofware is added 
//    to other software, then that software must also be released under 
//    the GPL.
//
//    This software comes with no warranty of any kind. 
//
//----------------------------------------------------------------------- 
/////:EOH~
#include <cmath>
#include <vector>
#include <string>
#include <iostream>
#include <iomanip>
#include <fstream>
using namespace std;
#include "mpi.h"
#include "grasp.h"
#include "particle.h"
#include "vec3.h"
#include "binlist.h"
#include "bin.h"
#include "forcefield.h"
#include "box.h"
#include "box_inline.h"
#include "fixed_object.h"
#include "particlelist.h"
#include "forcefieldlist.h"
#include "machine.h"
#include "comm.h"
#include "log.h"
extern Log glog;

BinList::BinList(){}


void BinList::Setup(const ParticleList* p, const Box* b, Comm* comm, ForceFieldList* ffl)
{
  int node;
  node = comm->get_node();
  int procgrid[3];
  comm->get_procgrid(procgrid);

  int nprocs = procgrid[0]*procgrid[1]*procgrid[2];
  
  if (node == 0) 
    {
      glog.logfile << "\n\n\n";
      glog.logfile << "Entering BinList::Setup()" << endl;
    }
  if (comm->get_Lnodefile()) 
    {
      comm->get_nodefile() << "Entered BinList::Setup" << endl;
    }

  double w[3];
  b->get_lw(w);

  // In fractional coodinates, if domain dimension is [0,1]^3 and 
  // cut off is rcut =  force_cut_off + skin_distance then
  // ghost domain dimension is [-cut,cut]^3. 

  double rcut = ffl->get_rcutneighmaxall();
  rcutneigh[0] = rcut/w[0];
  rcutneigh[1] = rcut/w[1];
  rcutneigh[2] = rcut/w[2];
  
  if (node == 0)
    {
      glog.logfile  << "w[0] = " << w[0] << endl;
      glog.logfile  << "w[1] = " << w[1] << endl;
      glog.logfile  << "w[2] = " << w[2] << endl;

      glog.logfile  << "rcut = " << rcut << endl;
      glog.logfile  << "rcutneigh[0] = " << rcutneigh[0] << endl;
      glog.logfile  << "rcutneigh[1] = " << rcutneigh[1] << endl;
      glog.logfile  << "rcutneigh[2] = " << rcutneigh[2] << endl;
    }

  // bin size is 0.5*rcut
  nbinx = static_cast<int> (2.0/rcutneigh[0]);
  nbiny = static_cast<int> (2.0/rcutneigh[1]);
  nbinz = static_cast<int> (2.0/rcutneigh[2]);
  if (nbinx == 0) nbinx = 1;
  if (nbiny == 0) nbiny = 1;
  if (nbinz == 0) nbinz = 1;

  nbins = nbinx*nbiny*nbinz;

  if (node == 0)
    {
      glog.logfile  << "nbinx = " << nbinx << endl;
      glog.logfile  << "nbiny = " << nbiny << endl;
      glog.logfile  << "nbinz = " << nbinz << endl;
      glog.logfile << endl;
      glog.logfile  << "nbins = " << nbins << endl;
      glog.logfile << endl;
    }

  // Global bounds in fractional coordinates
  globalbounds[0] =   - rcutneigh[0] - small;
  globalbounds[1] = 1 + rcutneigh[0] + small;
  globalbounds[2] =   - rcutneigh[1] - small;
  globalbounds[3] = 1 + rcutneigh[1] + small;
  globalbounds[4] =   - rcutneigh[2] - small;
  globalbounds[5] = 1 + rcutneigh[2] + small;

  if (node == 0)
    {
      glog.logfile << "globalbounds\n";
      glog.logfile << globalbounds[0] << "\t" << globalbounds[1] << "\t";
      glog.logfile << globalbounds[2] << "\t" << globalbounds[3] << "\t";
      glog.logfile << globalbounds[4] << "\t" << globalbounds[5] << endl;
    }

  mbinx = static_cast<int>(2.0*w[0]*(globalbounds[1]-globalbounds[0])/rcut);
  mbiny = static_cast<int>(2.0*w[1]*(globalbounds[3]-globalbounds[2])/rcut);
  mbinz = static_cast<int>(2.0*w[2]*(globalbounds[5]-globalbounds[4])/rcut);
  mbins = mbinx*mbiny*mbinz;

  if (node == 0)
    {
      glog.logfile << "mbinx = " << mbinx << endl;
      glog.logfile << "mbiny = " << mbiny << endl;
      glog.logfile << "mbinz = " << mbinz << endl;
      glog.logfile << endl;
      glog.logfile << "mbins = " << mbins << endl;
      glog.logfile << endl;
    }
  
  // binsize in fractional coordinates
  binsizex = (globalbounds[1]-globalbounds[0])/static_cast<double>(mbinx);
  binsizey = (globalbounds[1]-globalbounds[0])/static_cast<double>(mbiny);
  binsizez = (globalbounds[1]-globalbounds[0])/static_cast<double>(mbinz);

  if (node == 0)
    {
      glog.logfile << "binsizex = " << binsizex << endl;
      glog.logfile << "binsizey = " << binsizey << endl;
      glog.logfile << "binsizez = " << binsizez << endl;
    }

  // Find lowest and highest bounds for bins in no-ghost region
  int addon[3];
  addon[0] = static_cast<int>(rcut/(binsizex*w[0])+1);
  addon[1] = static_cast<int>(rcut/(binsizey*w[1])+1);
  addon[2] = static_cast<int>(rcut/(binsizez*w[2])+1);

  mbinxlo = addon[0];
  mbinxhi = mbinx - addon[0];
  mbinylo = addon[1];
  mbinyhi = mbiny - addon[1];
  mbinzlo = addon[2];
  mbinzhi = mbinz - addon[2];

  if (node == 0)
    {
      glog.logfile  << "mbinxlo = " << mbinxlo << endl;
      glog.logfile  << "mbinxhi = " << mbinxhi << endl;
      glog.logfile  << "mbinylo = " << mbinylo << endl;
      glog.logfile  << "mbinyhi = " << mbinyhi << endl;
      glog.logfile  << "mbinzlo = " << mbinzlo << endl;
      glog.logfile  << "mbinzhi = " << mbinzhi << endl;
    }

  // Local region in fractional coordinates
  int loc[3];
  comm->get_myloc(loc);
  localbounds[0] = static_cast<double>(loc[0])/static_cast<double>(procgrid[0])
    - rcutneigh[0] - small;
  localbounds[1] = static_cast<double>(loc[0]+1)/static_cast<double>(procgrid[0])
    + rcutneigh[0] + small;
  localbounds[2] = static_cast<double>(loc[1])/static_cast<double>(procgrid[1])
    - rcutneigh[1] - small;
  localbounds[3] = static_cast<double>(loc[1]+1)/static_cast<double>(procgrid[1])
    + rcutneigh[1] + small;
  localbounds[4] = static_cast<double>(loc[2])/static_cast<double>(procgrid[2])
    - rcutneigh[2] - small;
  localbounds[5] = static_cast<double>(loc[2]+1)/static_cast<double>(procgrid[2])
    + rcutneigh[2] + small;

  // bins - local numbering
  cout << "Proc - " << node << " - localbounds\n";
  cout << localbounds[0] << "\t" << localbounds[1] << "\t";
  cout << localbounds[2] << "\t" << localbounds[3] << "\t";
  cout << localbounds[4] << "\t" << localbounds[5] << endl << endl;

  pbinx = static_cast<int>((localbounds[1]-localbounds[0])/binsizex);
  pbiny = static_cast<int>((localbounds[3]-localbounds[2])/binsizey);
  pbinz = static_cast<int>((localbounds[5]-localbounds[4])/binsizez);
  pbins = pbinx*pbiny*pbinz;

  cout << "pbinx = " << pbinx << endl;
  cout << "pbiny = " << pbiny << endl;
  cout << "pbinz = " << pbinz << endl;
  cout << endl;
  cout << "pbins = " << pbins << endl;
  cout << endl;

  // Create bins - Fractional coordinates
  Bin current_bin;
  int m = 0;
  double fcb[6];
  for (int k=0;k<mbinz;k++)
    for (int j=0;j<mbiny;j++)
      for (int i=0;i<mbinx;i++)
	{
	  Bin2Bnds(i,j,k,fcb);
	  if (CheckBin(i,j,k) == 1)
	    {
	      int n =  k*mbiny*mbinx + j*mbinx + i;
	      current_bin.set_id(n);
	      current_bin.set_binx(i);
	      current_bin.set_biny(j);
	      current_bin.set_binz(k);
	      int ighost = -1;
	      if( (i>=mbinxlo && i<=mbinxhi) && (j>=mbinylo && j<=mbinyhi)
	      	  && (k>=mbinzlo && k<=mbinzhi) ) 
	      	ighost = 0;
	      else
	      	ighost = 1;
	      current_bin.set_ghost(ighost);		
	      current_bin.set_binregion(fcb);
	      bins.push_back(current_bin);
	      m++;
	    }

	  //cout << fcb[0] << "  " << fcb[1] << "\t" << fcb[2] << "  "
	  //     << fcb[3] << "\t" << fcb[4] << "  " << fcb[5] << endl;
	}

  BinParticles(p->get_nparticles(),p->get_nghost_particles(),p->get_particles(), b, comm);

  // Define neighboring bins  
  Bin checkbin;
  vector<Bin *> neighbor_bins;
  neighbor_bins.resize(26);
  int nbrs[26];
  for (int ix = mbinxlo; ix < mbinxhi; ix++) 
    for (int iy = mbinylo; iy < mbinyhi; iy++) 
      for (int iz = mbinzlo; iz < mbinzhi; iz++) 
	{
	  int n = mbinx*mbiny*iz + mbinx*iy + ix;
	  int m = Map(ix,iy,iz);
	  if (m != -1)
	    bins[m].set_nbrs(SelectNbrBins(ix,iy,iz));
	}
   

  /////////   TESTS   /////////
      /*double region[6]; // Fractional region only
  region[0] = -0.25; region[1] = 0.26;
  region[2] = -0.25; region[3] = 0.26;
  region[4] = -0.25; region[5] = 0.26;
      */
    
  // Test SelectRegionBins
  /*{
    vector<Bin *> temp_bins;
      if (node == 0)
	{
	  cout << "\n\nTest SelectRegionBins --- Trial region:\n";
	  cout << region[0] << "\t" << region[1] << "\t" << region[2] << "\t"
		       << region[3] << "\t" << region[4] << "\t" << region[5] << endl;
	}
    
    temp_bins = SelectRegionBins(region,b);
    if (node == 0)
      {
	cout << "Bins check: "<<endl;
	cout << "Number of bins found: "<< temp_bins.size()<<endl;
      }
    vector<Bin *>::iterator pbin;
    for (pbin = temp_bins.begin();pbin!=temp_bins.end();pbin++)
      {
	cout << "Bin " <<(*pbin)->get_id()<<" : ";

	double fcb[6];	
	(*pbin)->get_binregion(fcb);
	cout << fcb[0]<<"\t"<<  fcb[1]<<"\t"<< fcb[2]<<"\t"
	     << fcb[3]<<"\t"<<  fcb[4]<<"\t"<< fcb[5]<<endl;
      }
  }
  */
  

  // Test ReturnBins 
      /*
  {
    vector<Bin *> temp_bins;
    if (node == 0)
      {
	cout << "\n\nTest SelectGhostRegionBins --- Trial region:\n";
	cout << region[0] << "\t" << region[1] << "\t" << region[2] << "\t"
		     << region[3] << "\t" << region[4] << "\t" << region[5] << endl;
      }
    
    temp_bins = ReturnBins(region,b);
    if (node == 0)
      {
	cout << "Bins check: "<<endl;
	cout << "Number of bins found: "<< temp_bins.size()<<endl;
      }
    vector<Bin *>::iterator pbin;
    for (pbin = temp_bins.begin();pbin!=temp_bins.end();pbin++)
      {
	cout << "Bin " <<(*pbin)->get_id()<<" : ";

	double fcb[6];	
	(*pbin)->get_binregion(fcb);
	if (node == 0)
	  {
	    cout << fcb[0]<<"\t"<< fcb[1]<<"\t"<<fcb[2]<<"\t"
		 << fcb[3]<<"\t"<< fcb[4]<<"\t"<<fcb[5]<<endl;
	  }
      }
      }
      */
}

/* Bin Particles */
void BinList::BinParticles(
	       const int& nparticles, const int& nghost_particles, 
	       const Particle* particles, const Box* b, Comm* comm)
{
  int node;
  node = comm->get_node();
  if (node == 0) 
    {
      cout << "\n\n\n";
      cout << "Entering BinList::BinParticles()" << endl;
    }
  if (comm->get_Lnodefile()) {
    comm->get_nodefile() << "Entered BinList::BinParticles" << endl;
  }

  // bin particles
  double x[3];
  int ix,iy,iz;
  for (int i = 0; i < nparticles; i++) 
    {
      particles[i].get_x(x);
      Coord2Bin(x,b,&ix,&iy,&iz);
      int m = Map(ix,iy,iz);
      if (m != -1) bins[m].particles.push_back(particles[i]);
    }
  
  for (int i = nparticles; i < nparticles + nghost_particles; i++) 
    {
      particles[i].get_x(x);
      Coord2GhostBin(x,b,&ix,&iy,&iz);
      int m = Map(ix,iy,iz);
      if (m != -1) bins[Map(ix,iy,iz)].particles.push_back(particles[i]);
    }
  
}


void BinList::Coord2Bin(const double x[3],const Box* b,int *ix, int *iy, int *iz)
{
  double X[3];
  
  X[0] = b->Fractional(0,x);
  *ix = static_cast<int>(mbinxlo + X[0]*nbinx);
  
  X[1] = b->Fractional(1,x);
  *iy = static_cast<int>(mbinylo + X[1]*nbiny);
  
  X[2] = b->Fractional(2,x);
  *iz = static_cast<int>(mbinzlo + X[2]*nbinz);
  
  if ( (*ix < 0 || *ix >= mbinx)|| (*iy < 0 || *iy >= mbiny) || (*iz < 0 || *iz >= mbinz) ) 
    {
      cout << "ix, iy or iy in Coord2Bin out of range " << endl;
      cout << "ix=" << *ix << "\tiy=" << *iy << "\tiz" << *iz << endl;
      glog.abort("BinList::Coord2Bin:\n"
		 "local particle out of range");
    }    
}

void BinList::Coord2GhostBin(const double x[3],const Box* b,int *ix,int *iy, int *iz)
{
  double X[3];
  X[0] = b->Fractional(0,x);
  X[1] = b->Fractional(1,x);
  X[2] = b->Fractional(2,x);

  if (X[0] > 1.0)
    *ix = static_cast<int> ((X[0] - 1.0)*nbinx) + nbinx + mbinxlo;
  else if (X[0] >= 0.0)
    *ix = static_cast<int> (X[0]*nbinx) + mbinxlo;
  else
    *ix = static_cast<int> (X[0]*nbinx) + mbinxlo - 1;

  if (X[1] > 1.0)
    *iy = static_cast<int> ((X[1] - 1.0)*nbiny) + nbiny + mbinylo;
  else if (X[1] >= 0.0)
    *iy = static_cast<int> (X[1]*nbiny) + mbinylo;
  else
    *iy = static_cast<int> (X[1]*nbiny) +mbinylo - 1;

  if (X[2] > 1.0)
    *iz = static_cast<int> ((X[2] - 1.0)*nbinz) + nbinz + mbinzlo;
  else if (X[2] >= 0.0)
    *iz = static_cast<int> (X[2]*nbinz) + mbinzlo;
  else
    *iz = static_cast<int> (X[2]*nbinz) + mbinzlo -1;

  if ( (*ix < 0 || *ix >= mbinx)|| (*iy < 0 || *iy >= mbiny) || (*iz < 0 || *iz >= mbinz) ) 
    {
      cout << "ix, iy or iy in Coord2GhostBin out of range " << endl;
      cout << "ix=" << *ix << "\tiy=" << *iy << "\tiz" << *iz << endl;
      glog.abort("BinList::Coord2GhostBin:\n"
		 "local particle out of range");
    }    
}

vector<Bin *> BinList::ReturnBins(const double reg[6], const Box* b)
{  
  // enter a fractional region only.
  vector<Bin *> RegionBins;
  Bin *current_bin;
  int ixlo,iylo,izlo;
  int ixhi,iyhi,izhi;

  // check region
  if(reg[0]>=reg[1]) return RegionBins;
  if(reg[2]>=reg[3]) return RegionBins;
  if(reg[4]>=reg[5]) return RegionBins;

  double regc[6];
  GlobalBounds(reg,regc);

  ixlo = static_cast<int> (regc[0]*mbinx);
  ixhi = static_cast<int> (regc[1]*mbinx+1);
  iylo = static_cast<int> (regc[2]*mbiny);
  iyhi = static_cast<int> (regc[3]*mbiny+1);
  izlo = static_cast<int> (regc[4]*mbinz);
  izhi = static_cast<int> (regc[5]*mbinz+1);

  for (int k=izlo;k<izhi;k++)
    for (int j=iylo;j<iyhi;j++)
      for (int i=ixlo;i<ixhi;i++)
	{
	  
	  if ( (i < 0 || i > mbinx)|| (j < 0 || j > mbiny) || (k < 0 || k > mbinz) ) 
	    {
	      cout << "i, j or k in ReturnBins out of range " << endl;
	      cout << "i=" << i << "\tj=" << j << "\tk=" << k << endl;
	      glog.abort("BinList::ReturnBins:\n"
			 "local particle out of range");
	    }   
	  
	  int m = Map(i,j,k);
	  if (m != -1)
	    {
	      current_bin = &bins[m];
	      RegionBins.push_back(current_bin);	  
	    }
	}
  
  return RegionBins;
}



vector<Bin *> BinList::SelectRegionBins(const double reg[6], const Box* b)
{  
  // enter a fractional region only.
  // region has to belong to no-ghost region
  vector<Bin *> RegionBins;
  Bin *current_bin;
  int ixlo,iylo,izlo;
  int ixhi,iyhi,izhi;

  // check region
  if(reg[0]>=reg[1]) return RegionBins;
  if(reg[2]>=reg[3]) return RegionBins;
  if(reg[4]>=reg[5]) return RegionBins;


  double regc[6];
  GlobalBounds(reg,regc);

  ixlo =  max(static_cast<int> (regc[0]*mbinx),mbinxlo);
  ixhi =  min(static_cast<int> (regc[1]*mbinx+1),mbinxhi);
  iylo =  max(static_cast<int> (regc[2]*mbiny),mbinylo);
  iyhi =  min(static_cast<int> (regc[3]*mbiny+1),mbinyhi);
  izlo =  max(static_cast<int> (regc[4]*mbinz),mbinzlo);
  izhi =  min(static_cast<int> (regc[5]*mbinz+1),mbinzhi);

  for (int k=izlo;k<izhi;k++)
    for (int j=iylo;j<iyhi;j++)
      for (int i=ixlo;i<ixhi;i++)
	{
	  
	  if ( (i < mbinxlo || i > mbinxhi)|| (j < mbinylo || j > mbinyhi) || (k < mbinzlo || k > mbinzhi) ) 
	    {
	      cout << "i, j or k in SelectRegionBins out of range " << endl;
	      cout << "i=" << i << "\tj=" << j << "\tk" << k << endl;
	      glog.abort("BinList::SelectRegionBins:\n"
			 "local particle out of range");
	    }   
	  
	  int m = Map(i,j,k);
	  if (m != -1)
	    {
	      current_bin = &bins[m];
	      RegionBins.push_back(current_bin);	  
	    }
	}
  
  return RegionBins;
}


vector<Bin *> BinList::SelectGhostRegionBins(const double reg[6], const Box* b)
{  
  // enter a fractional region only
  vector<Bin *> collectbins,RegionGhostBins;
  vector<Bin *>::iterator pbin;
  Bin *current_bin;

  // check region
  if(reg[0]>=reg[1]) return RegionGhostBins;
  if(reg[2]>=reg[3]) return RegionGhostBins;
  if(reg[4]>=reg[5]) return RegionGhostBins;


  double region[6];
  // Define rings around given region
  region[0] = max(reg[0] - rcutneigh[0],globalbounds[0]);
  region[1] = reg[0];
  region[2] = max(reg[2] - rcutneigh[1],globalbounds[2]);
  region[3] = min(reg[3] + rcutneigh[1],globalbounds[3]);
  region[4] = max(reg[4] - rcutneigh[2],globalbounds[4]);
  region[5] = min(reg[5] + rcutneigh[2],globalbounds[5]);

  RegionGhostBins = ReturnBins(region,b);

  region[0] = reg[1];
  region[1] = min(reg[1] + rcutneigh[0],globalbounds[1]);
  region[2] = max(reg[2] - rcutneigh[1],globalbounds[2]);
  region[3] = min(reg[3] + rcutneigh[1],globalbounds[3]);
  region[4] = max(reg[4] - rcutneigh[2],globalbounds[4]);
  region[5] = min(reg[5] + rcutneigh[2],globalbounds[5]);

  RegionGhostBins = ReturnBins(region,b);
  
  region[0] = reg[0];
  region[1] = reg[1];
  region[2] = max(reg[2] - rcutneigh[1],globalbounds[2]);
  region[3] = reg[2];
  region[4] = max(reg[4] - rcutneigh[2],globalbounds[4]);
  region[5] = min(reg[5] + rcutneigh[2],globalbounds[5]);

  RegionGhostBins = ReturnBins(region,b);

  region[0] = reg[0];
  region[1] = reg[1];
  region[2] = reg[3];
  region[3] = min(reg[3] + rcutneigh[1],globalbounds[3]);
  region[4] = max(reg[4] - rcutneigh[2],globalbounds[4]);
  region[5] = min(reg[5] + rcutneigh[2],globalbounds[5]);

  RegionGhostBins = ReturnBins(region,b);

  region[0] = reg[0];
  region[1] = reg[1];
  region[2] = reg[2];
  region[3] = reg[3];
  region[4] = max(reg[4] - rcutneigh[2],globalbounds[4]);
  region[5] = reg[4];

  RegionGhostBins = ReturnBins(region,b);

  region[0] = reg[0];
  region[1] = reg[1];
  region[2] = reg[2];
  region[3] = reg[3];
  region[4] = reg[5];
  region[5] = min(reg[5] + rcutneigh[2],globalbounds[5]);

  RegionGhostBins = ReturnBins(region,b);

  return RegionGhostBins;
}

vector<Bin *> BinList::SelectNbrBins (const int ix,const int iy, const int iz)
{
  vector<Bin *> NeighborBins;
  Bin *current_bin;

  int ixx = ix;
  int iyy = iy;
  int izz = iz;

  if (ix == 0) ixx = mbinx-2;
  if (ix == mbinx-1) ixx = 1;
  if (iy == 0) iyy = mbiny-2;
  if (iy == mbiny-1) iyy = 1;
  if (iz == 0) izz = mbinz-2;
  if (iz == mbinz-1) izz = 1;

   for (int k=izz-1;k<=izz+1;k++)
    for (int j=iyy-1;j<=iyy+1;j++)
      for (int i=ixx-1;i<=ixx+1;i++)
	{
	  if (k != izz || j != iyy || i != ixx) // not self
	    {
	      int m = Map(i,j,k);
	      if (m != -1)
		{
		  current_bin = &bins[m];
		  NeighborBins.push_back(current_bin);	  
		}
	    }
	}
   
   return NeighborBins;
}


void BinList::LocalBounds(const double r[6],double rc[6])
{
  rc[0] = (r[0]  - localbounds[0])/(localbounds[1]-localbounds[0]);
  rc[1] = (r[1]  - localbounds[0])/(localbounds[1]-localbounds[0]);
  
  rc[2] = (r[2]  - localbounds[2])/(localbounds[3]-localbounds[2]);
  rc[3] = (r[3]  - localbounds[2])/(localbounds[3]-localbounds[2]);
  
  rc[4] = (r[4]  - localbounds[4])/(localbounds[5]-localbounds[4]);
  rc[5] = (r[5]  - localbounds[4])/(localbounds[5]-localbounds[4]);
}

void BinList::GlobalBounds(const double r[6],double rc[6])
{
  // coordinates -> fractional coordinates
  rc[0] = (r[0]  - globalbounds[0])/(globalbounds[1]-globalbounds[0]);
  rc[1] = (r[1]  - globalbounds[0])/(globalbounds[1]-globalbounds[0]);

  rc[2] = (r[2]  - globalbounds[2])/(globalbounds[3]-globalbounds[2]);
  rc[3] = (r[3]  - globalbounds[2])/(globalbounds[3]-globalbounds[2]);

  rc[4] = (r[4]  - globalbounds[4])/(globalbounds[5]-globalbounds[4]);
  rc[5] = (r[5]  - globalbounds[4])/(globalbounds[5]-globalbounds[4]);
}


void BinList::InvGlobalBounds(const double r[6],double rc[6])
{
  rc[0] = globalbounds[0] + r[0]*(globalbounds[1]-globalbounds[0]);
  rc[1] = globalbounds[0] + r[1]*(globalbounds[1]-globalbounds[0]);
  
  rc[2] = globalbounds[2] + r[2]*(globalbounds[3]-globalbounds[2]);
  rc[3] = globalbounds[2] + r[3]*(globalbounds[3]-globalbounds[2]);
  
  rc[4] = globalbounds[4] + r[4]*(globalbounds[5]-globalbounds[4]);
  rc[5] = globalbounds[4] + r[5]*(globalbounds[5]-globalbounds[4]);
}

int BinList::CheckBin(int i,int j,int k)
{
  double bnds[6],bndsc[6];
  bnds[0] =  static_cast<double>(i)/static_cast<double>(mbinx);
  bnds[1] =  static_cast<double>(i)/static_cast<double>(mbinx);
  bnds[2] =  static_cast<double>(j)/static_cast<double>(mbiny);
  bnds[3] =  static_cast<double>(j)/static_cast<double>(mbiny);
  bnds[4] =  static_cast<double>(k)/static_cast<double>(mbinz);
  bnds[5] =  static_cast<double>(k)/static_cast<double>(mbinz);
  InvGlobalBounds(bnds,bndsc);
  bndsc[1] += binsizex;
  bndsc[3] += binsizey;
  bndsc[5] += binsizez;

  int ires[3];
  //x
  if(bndsc[0]>=localbounds[0] && bndsc[1] <=localbounds[1])
    ires[0] = 1;
  else
    ires[0] = 0;

  //y
  if(bndsc[2]>=localbounds[2] && bndsc[3] <=localbounds[3])
    ires[1] = 1;
  else
    ires[1] = 0;

  //z
  if(bndsc[4]>=localbounds[4] && bndsc[5] <=localbounds[5])
    ires[2] = 1;
  else
    ires[2] = 0;

  return (ires[0] + ires[1] + ires[2])/3;
}

int BinList::Map(int ix,int iy, int iz)
{
  // Given a global bin number m, return the local number n on the proc this bin belongs to
  int n;

  double binbnds[6];
  Bin2Bnds(ix,iy,iz,binbnds);

  //is this bin on that proc?
  if ( (binbnds[0] >= localbounds[0] && binbnds[1] <= localbounds[1]) &&
       (binbnds[2] >= localbounds[2] && binbnds[3] <= localbounds[3]) &&
       (binbnds[4] >= localbounds[4] && binbnds[5] <= localbounds[5]) ) 
    n = pbinx*pbiny*iz + pbinx*iy + ix;
  else
    n = -1;

  return n;
}

void BinList::Bin2Bnds(int ix,int iy,int iz,double bounds[6])
{
  double bnds[6];
  bnds[0] = static_cast<double>(ix)/static_cast<double>(mbinx);
  bnds[1] = static_cast<double>(ix)/static_cast<double>(mbinx);
  bnds[2] = static_cast<double>(iy)/static_cast<double>(mbiny);
  bnds[3] = static_cast<double>(iy)/static_cast<double>(mbiny);
  bnds[4] = static_cast<double>(iz)/static_cast<double>(mbinz);
  bnds[5] = static_cast<double>(iz)/static_cast<double>(mbinz);
  InvGlobalBounds(bnds,bounds);
  bounds[1] += binsizex;
  bounds[3] += binsizey;
  bounds[5] += binsizez;
}
@


1.1.6.2
log
@Region for octant's ghost bins implemented
@
text
@d243 1
d257 1
a257 3
	      current_bin.set_ghost(ighost);

	      Bin2Bnds(i,j,k,fcb);		
a258 1

d278 1
a456 1
  RegionBins.resize(0);
d462 3
a464 3
  if(reg[0]>=reg[1]) {return RegionBins;};
  if(reg[2]>=reg[3]) {return RegionBins;};
  if(reg[4]>=reg[5]) {return RegionBins;};
d469 6
a474 6
  ixlo = max(static_cast<int> (regc[0]*mbinx),0);
  ixhi = min(static_cast<int> (regc[1]*mbinx+1),mbinx);
  iylo = max(static_cast<int> (regc[2]*mbiny),0);
  iyhi = min(static_cast<int> (regc[3]*mbiny+1),mbiny);
  izlo = max(static_cast<int> (regc[4]*mbinz),0);
  izhi = min(static_cast<int> (regc[5]*mbinz+1),mbinz);
d480 9
d493 1
a493 1
	      RegionBins.push_back(current_bin);
d501 1
a506 1
  RegionBins.resize(0);
d512 3
a514 3
  if(reg[0]>=reg[1]) {return RegionBins;};
  if(reg[2]>=reg[3]) {return RegionBins;};
  if(reg[4]>=reg[5]) {return RegionBins;};
d555 3
a557 3
  vector<Bin *> collect,RegionGhostBins;
  RegionGhostBins.resize(0);
  vector<Bin *>::iterator p1,p2;
d560 4
a563 3
  if(reg[0]>=reg[1]) {return RegionGhostBins;};
  if(reg[2]>=reg[3]) {return RegionGhostBins;};
  if(reg[4]>=reg[5]) {return RegionGhostBins;};
d566 1
d568 9
d583 26
a608 1
  collect = ReturnBins(region,b);
d610 8
a617 9
  for (p1 = collect.begin();p1!=collect.end();p1++)
    {
      double fcb[6];
       (*p1)->get_binregion(fcb);
       if( (fcb[0]>reg[0] && fcb[1]<reg[1]) ||
	   (fcb[2]>reg[2] && fcb[3]<reg[3]) ||
	   (fcb[4]>reg[4] && fcb[5]<reg[5]) )
 	 (*p1)->set_id(-1);
    }
d619 1
a619 3
  for (p1 = collect.begin();p1!=collect.end();p1++)
    if ((*p1)->get_id() != -1) 
      RegionGhostBins.push_back(*p1);
d713 1
a713 1
  if(bndsc[0]>=localbounds[0]-small && bndsc[1] <=localbounds[1]+small)
d719 1
a719 1
  if(bndsc[2]>=localbounds[2]-small && bndsc[3] <=localbounds[3]+small)
d725 1
a725 1
  if(bndsc[4]>=localbounds[4]-small && bndsc[5] <=localbounds[5]+small)
@


1.1.6.3
log
@Alex's algorithm implemented. Need more checks in parallel
@
text
@d69 2
a70 3
BinList::BinList()
{
}
d78 1
d80 1
d96 1
a96 1
  // ghost domain dimension is [-cut,1+cut]^3. 
d115 4
a118 69
  // Global bounds in fractional coordinates
  globalbounds[0] =   - rcutneigh[0] - small;
  globalbounds[1] = 1 + rcutneigh[0] + small;
  globalbounds[2] =   - rcutneigh[1] - small;
  globalbounds[3] = 1 + rcutneigh[1] + small;
  globalbounds[4] =   - rcutneigh[2] - small;
  globalbounds[5] = 1 + rcutneigh[2] + small;

  if (node == 0)
    {
      glog.logfile << "globalbounds\n";
      glog.logfile << globalbounds[0] << "\t" << globalbounds[1] << "\t";
      glog.logfile << globalbounds[2] << "\t" << globalbounds[3] << "\t";
      glog.logfile << globalbounds[4] << "\t" << globalbounds[5] << endl;
    }


  // Local region in fractional coordinates - contains ghost region
  int loc[3];
  comm->get_myloc(loc);
  localbounds[0] = static_cast<double>(loc[0])/static_cast<double>(procgrid[0])
    - rcutneigh[0] - small;
  localbounds[1] = static_cast<double>(loc[0]+1)/static_cast<double>(procgrid[0])
    + rcutneigh[0] + small;
  localbounds[2] = static_cast<double>(loc[1])/static_cast<double>(procgrid[1])
    - rcutneigh[1] - small;
  localbounds[3] = static_cast<double>(loc[1]+1)/static_cast<double>(procgrid[1])
    + rcutneigh[1] + small;
  localbounds[4] = static_cast<double>(loc[2])/static_cast<double>(procgrid[2])
    - rcutneigh[2] - small;
  localbounds[5] = static_cast<double>(loc[2]+1)/static_cast<double>(procgrid[2])
    + rcutneigh[2] + small;

  cout << "Proc. " << node << ":  \t";
  cout << localbounds[0] << "\t" << localbounds[1] << "\t";
  cout << localbounds[2] << "\t" << localbounds[3] << "\t";
  cout << localbounds[4] << "\t" << localbounds[5] << endl << endl;


  // Check that proc. domain is 4*rcut
  double domain[3];
  domain[0] = (localbounds[1]-localbounds[0])/rcutneigh[0];
  domain[1] = (localbounds[3]-localbounds[2])/rcutneigh[1];
  domain[2] = (localbounds[5]-localbounds[4])/rcutneigh[2];
  if ( domain[0] <= 4*rcutneigh[0] || domain[1] <= 4*rcutneigh[1] || 
       domain[2] <= 4*rcutneigh[2]  ) 
    {
      cout  << "Proc. domains:  " << domain[0] << "\t" << domain[1] 
	   << "\t" << domain[2] << endl;
      glog.abort("BinList::Setup:\n"
		 "Proc. domain have to be at least 4*rcut");
    }

  // calculate binsize in fractional coordinates
  BinSize(comm);
  // assume from now on that  bin size = rcut 

  if (node == 0)
    {
      cout << "binsizex = " << binsizex << endl;
      cout << "binsizey = " << binsizey << endl;
      cout << "binsizez = " << binsizez << endl;
    }

  // bin size is rcut
  nbinx = ioctbin[0]*2*procgrid[0]; 
  nbiny = ioctbin[1]*2*procgrid[1]; 
  nbinz = ioctbin[2]*2*procgrid[2]; 

d135 15
d151 3
a153 3
  mbinx = nbinx + 2;
  mbiny = nbiny + 2;
  mbinz = nbinz + 2;
d165 12
d179 11
a189 6
  mbinxlo = 1;
  mbinxhi = mbinx - 1;
  mbinylo = 1;
  mbinyhi = mbiny - 1;
  mbinzlo = 1;
  mbinzhi = mbinz - 1;
d201 25
a225 4
  // local numbering of bins. Contains bin + ghostbin region
  pbinx = ioctbin[0]*2+2;
  pbiny = ioctbin[1]*2+2;
  pbinz = ioctbin[2]*2+2;
d228 6
a233 9
  if (node == 0)
    {
      glog.logfile << "pbinx = " << pbinx << endl;
      glog.logfile << "pbiny = " << pbiny << endl;
      glog.logfile << "pbinz = " << pbinz << endl;
      glog.logfile << endl;
      glog.logfile << "pbins = " << pbins << endl;
      glog.logfile << endl;
    }
d237 1
d243 1
a243 3
	  // define bins contained in each processor
	  int m = Map(i,j,k);
	  if (m != -1)
d250 8
d259 2
a260 1
	      current_bin.set_binregion(fcb);	      
d262 1
d264 3
a268 24
  /*
  Bin binlist;
  cout << "node=" << node << "\t  ";
  cout << localbounds[0] << "\t" << localbounds[1] << "\t";
  cout << localbounds[2] << "\t" << localbounds[3] << "\t";
  cout << localbounds[4] << "\t" << localbounds[5] << endl;

  for (int pp = 0; pp<bins.size();pp++) 
    {
      double fcb[6];
      binlist = bins[pp];
      binlist.get_binregion(fcb);
      
      int i,j,k;
      i = binlist.get_binx();
      j = binlist.get_biny();
      k = binlist.get_binz();
      
      cout << " (" << pp << " - " << Map(i,j,k) << ")  [" << fcb[0] << "\t" << fcb[1] << "\t" << fcb[2] << "\t"
	   << fcb[3] << "\t" << fcb[4] << "\t" << fcb[5] << "]" << endl;
      
    }
  */
  
d284 71
d366 2
a367 2
      glog.logfile << "\n\n\n";
      glog.logfile << "Entering BinList::BinParticles()" << endl;
d389 1
a389 1
      if (m != -1) bins[m].particles.push_back(particles[i]);
a453 11

void BinList::Coord2GhostBin2(double x,int nbin,int mbinlo,int *ix)
{
  if (x > 1.0)
    *ix = static_cast<int> ((x - 1.0)*nbin) + nbin + mbinlo;
  else if (x >= 0.0)
    *ix = static_cast<int> (x*nbin) + mbinlo;
  else
    *ix = static_cast<int> (x*nbin) + mbinlo - 1;
}

d459 1
a459 1
  Bin* current_bin;
d468 10
a477 14
  Coord2GhostBin2(reg[0],nbinx,mbinxlo,&ixlo);
  Coord2GhostBin2(reg[1],nbinx,mbinxlo,&ixhi);
  Coord2GhostBin2(reg[2],nbiny,mbinylo,&iylo);
  Coord2GhostBin2(reg[3],nbiny,mbinylo,&iyhi);
  Coord2GhostBin2(reg[4],nbinz,mbinzlo,&izlo);
  Coord2GhostBin2(reg[5],nbinz,mbinzlo,&izhi);

  cout << "ixlo=" << ixlo << endl;
  cout << "ixhi=" << ixhi << endl;
  cout << "iylo=" << iylo << endl;
  cout << "iyhi=" << iyhi << endl;
  cout << "izlo=" << izlo << endl;
  cout << "izhi=" << izhi << endl;
  
d481 1
a481 1
	{	  
d486 1
a486 1
	      RegionBins.push_back(current_bin);	  
d500 1
a500 1
  Bin* current_bin;
d523 10
a532 1
	{	  
d537 1
a537 1
	      RegionBins.push_back(current_bin);
d548 1
a548 3
  // reg = region only 

  vector<Bin* > collect, RegionGhostBins;
d550 1
a550 1
  vector<Bin *>::iterator pbin;
a556 1
  // add non-ghost region
d558 6
a563 11
  region[0] = reg[0] - rcutneigh[0] - small;
  region[1] = reg[1] + rcutneigh[0] + small;
  region[2] = reg[2] - rcutneigh[1] - small;
  region[3] = reg[3] + rcutneigh[1] + small;
  region[4] = reg[4] - rcutneigh[2] - small;
  region[5] = reg[5] + rcutneigh[2] + small;

  cout << "region = \t";
  cout << "  " << region[0] << "\t" << region[1] << "\t" << region[2] << "\t"
      	   << region[3] << "\t" << region[4] << "\t" << region[5] << endl;

d567 1
a567 5
  if(region[0]>=region[1]) {return RegionGhostBins;};
  if(region[2]>=region[3]) {return RegionGhostBins;};
  if(region[4]>=region[5]) {return RegionGhostBins;};
  
  for (pbin = collect.begin();pbin!=collect.end();pbin++)
d570 5
a574 5
      (*pbin)->get_binregion(fcb);
      if ( (fcb[0]>=reg[0] && fcb[1]<=reg[1]) ||
	   (fcb[2]>=reg[2] && fcb[3]<=reg[3]) ||
	   (fcb[4]>=reg[4] && fcb[5]<=reg[5]) )
	(*pbin)->set_id(-1);
d576 5
a580 7
  
  for (pbin = collect.begin();pbin!=collect.end();pbin++)
    {  
      if ( (*pbin)->get_id() != -1)
  	RegionGhostBins.push_back(*pbin);
    }      
  
d657 36
d696 1
a696 1
  int n = -1;
d701 1
a701 1
  //is this bin on that proc region (= proc region + ghost region = localbounds)?
d706 2
a725 54

void BinList::BinSize(Comm* comm)
{
  // calculate binsize
  // temporary mbinx,y,z
  mbinx = static_cast<int>((globalbounds[1]-globalbounds[0])/rcutneigh[0]);
  mbiny = static_cast<int>((globalbounds[3]-globalbounds[2])/rcutneigh[1]);
  mbinz = static_cast<int>((globalbounds[5]-globalbounds[4])/rcutneigh[2]);

  binsizex = (globalbounds[1]-globalbounds[0])/mbinx;
  binsizey = (globalbounds[3]-globalbounds[2])/mbiny;
  binsizez = (globalbounds[5]-globalbounds[4])/mbinz;

  // temporarly define octant region
  int loc[3];
  comm->get_myloc(loc);
  cout << "loc : " << loc[0] << "\t" << loc[1] << "\t" << loc[2] << endl;
  int procgrid[3];
  comm->get_procgrid(procgrid);
  cout << "procgrid : " << procgrid[0] << "\t" << procgrid[1] << "\t" << procgrid[2] << endl;

  double locals[6];
  locals[0] = static_cast<double>(loc[0])/static_cast<double>(procgrid[0]);
  locals[1] = static_cast<double>(loc[0]+1)/static_cast<double>(procgrid[0]);
  locals[2] = static_cast<double>(loc[1])/static_cast<double>(procgrid[1]);
  locals[3] = static_cast<double>(loc[1]+1)/static_cast<double>(procgrid[1]);
  locals[4] = static_cast<double>(loc[2])/static_cast<double>(procgrid[2]);
  locals[5] = static_cast<double>(loc[2]+1)/static_cast<double>(procgrid[2]);

  // size of first octant
  // assumed here that all octants have same dimensions in fractional coord.
  double rc[6];
  rc[0] = locals[0];
  rc[1] = (locals[1]+locals[0])*0.5;
  
  rc[2] = locals[2];
  rc[3] = (locals[3]+locals[2])*0.5;
  
  rc[4] = locals[4];
  rc[5] = (locals[5]+locals[4])*0.5;
	  
  // number of bins in a given octant
  ioctbin[0] = static_cast<int>((rc[1]-rc[0])/binsizex+1);
  ioctbin[1] = static_cast<int>((rc[3]-rc[2])/binsizey+1);
  ioctbin[2] = static_cast<int>((rc[5]-rc[4])/binsizez+1);

  cout << "ioctbin[0]=" << ioctbin[0] << "\t" << "ioctbin[1]=" 
       << ioctbin[1] << "\t" << "ioctbin[2]=" << ioctbin[2] << endl;

  
  binsizex = (rc[1]-rc[0])/ static_cast<double>(ioctbin[0]);
  binsizey = (rc[3]-rc[2])/ static_cast<double>(ioctbin[1]);
  binsizez = (rc[5]-rc[4])/ static_cast<double>(ioctbin[2]);
}
@


1.1.6.4
log
@Made bin entries independent.
@
text
@a259 1
	      bins.resize(bins.size()+1);
d261 4
a264 4
	      bins[bins.size()-1].set_id(n);
	      bins[bins.size()-1].set_binx(i);
	      bins[bins.size()-1].set_biny(j);
	      bins[bins.size()-1].set_binz(k);
d266 2
a267 1
	      bins[bins.size()-1].set_binregion(fcb);	      
@


1.1.6.5
log
@Correct a few bugs
@
text
@d82 2
a83 2
      cout << "\n\n\n";
      cout << "Entering BinList::Setup()" << endl;
d104 8
a111 8
      cout  << "w[0] = " << w[0] << endl;
      cout  << "w[1] = " << w[1] << endl;
      cout  << "w[2] = " << w[2] << endl;

      cout  << "rcut = " << rcut << endl;
      cout  << "rcutneigh[0] = " << rcutneigh[0] << endl;
      cout  << "rcutneigh[1] = " << rcutneigh[1] << endl;
      cout  << "rcutneigh[2] = " << rcutneigh[2] << endl;
d124 4
a127 4
      cout << "globalbounds\n";
      cout << globalbounds[0] << "\t" << globalbounds[1] << "\t";
      cout << globalbounds[2] << "\t" << globalbounds[3] << "\t";
      cout << globalbounds[4] << "\t" << globalbounds[5] << endl;
d130 1
d147 5
a151 7
  if (node == 0)
    {
      cout << "Proc. " << node << ":  \t";
      cout << localbounds[0] << "\t" << localbounds[1] << "\t";
      cout << localbounds[2] << "\t" << localbounds[3] << "\t";
      cout << localbounds[4] << "\t" << localbounds[5] << endl << endl;
    }
d158 2
a159 2
  if ( node == 0 && (domain[0] <= 4*rcutneigh[0] || domain[1] <= 4*rcutneigh[1] || 
       domain[2] <= 4*rcutneigh[2])  ) 
d191 6
a196 6
      cout  << "nbinx = " << nbinx << endl;
      cout  << "nbiny = " << nbiny << endl;
      cout  << "nbinz = " << nbinz << endl;
      cout << endl;
      cout  << "nbins = " << nbins << endl;
      cout << endl;
d199 1
d207 6
a212 6
      cout << "mbinx = " << mbinx << endl;
      cout << "mbiny = " << mbiny << endl;
      cout << "mbinz = " << mbinz << endl;
      cout << endl;
      cout << "mbins = " << mbins << endl;
      cout << endl;
d222 11
a232 1
 
d241 6
a246 6
      cout << "pbinx = " << pbinx << endl;
      cout << "pbiny = " << pbiny << endl;
      cout << "pbinz = " << pbinz << endl;
      cout << endl;
      cout << "pbins = " << pbins << endl;
      cout << endl;
a249 1
  //cout << "Proc. " << node << "\t  ";
d270 25
a294 1
 
d298 4
a309 2
  
  
d321 2
a322 2
      cout << "\n\n\n";
      cout << "Entering BinList::BinParticles()" << endl;
d337 1
a337 1
      }
d345 1
a345 1
      }
d641 4
a644 4
  if ( (binbnds[0]+small >= localbounds[0] && binbnds[1]-small <= localbounds[1]) &&
       (binbnds[2]+small >= localbounds[2] && binbnds[3]-small <= localbounds[3]) &&
       (binbnds[4]+small >= localbounds[4] && binbnds[5]-small <= localbounds[5]) ) 
      n = pbinx*pbiny*iz + pbinx*iy + ix;
d659 3
a661 3
  bounds[1] = min(bounds[1]+binsizex,globalbounds[1]);
  bounds[3] = min(bounds[3]+binsizey,globalbounds[3]);
  bounds[5] = min(bounds[5]+binsizez,globalbounds[5]);
@


1.1.6.6
log
@Added error check in Binlist::BinParticles()
@
text
@d301 1
a301 3
      if (m < 0 || m >= bins.size()) {
	glog.abort("BinList::BinParticles:\n"
		   "Bin outside range",comm);
a302 2
      bins[m].particles.push_back(particles[i]);
    }
d309 1
a309 4
      if (m < 0 || m >= bins.size()) {
	glog.abort("BinList::BinParticles:\n"
	       "Bin outside range",comm);
	bins[m].particles.push_back(particles[i]);
a310 2
      bins[m].particles.push_back(particles[i]);
    }
@


1.1.6.7
log
@Memory bug found.
@
text
@d82 2
a83 2
      glog.logfile << "\n\n\n";
      glog.logfile << "Entering BinList::Setup()" << endl;
d104 8
a111 8
      glog.logfile  << "w[0] = " << w[0] << endl;
      glog.logfile  << "w[1] = " << w[1] << endl;
      glog.logfile  << "w[2] = " << w[2] << endl;

      glog.logfile  << "rcut = " << rcut << endl;
      glog.logfile  << "rcutneigh[0] = " << rcutneigh[0] << endl;
      glog.logfile  << "rcutneigh[1] = " << rcutneigh[1] << endl;
      glog.logfile  << "rcutneigh[2] = " << rcutneigh[2] << endl;
d124 4
a127 4
      glog.logfile << "globalbounds\n";
      glog.logfile << globalbounds[0] << "\t" << globalbounds[1] << "\t";
      glog.logfile << globalbounds[2] << "\t" << globalbounds[3] << "\t";
      glog.logfile << globalbounds[4] << "\t" << globalbounds[5] << endl;
d148 4
a151 4
      glog.logfile << "Proc. " << node << ":  \t";
      glog.logfile << localbounds[0] << "\t" << localbounds[1] << "\t";
      glog.logfile << localbounds[2] << "\t" << localbounds[3] << "\t";
      glog.logfile << localbounds[4] << "\t" << localbounds[5] << endl << endl;
d174 3
a176 3
      glog.logfile << "binsizex = " << binsizex << endl;
      glog.logfile << "binsizey = " << binsizey << endl;
      glog.logfile << "binsizez = " << binsizez << endl;
a178 2
  exit(0);

d192 6
a197 6
      glog.logfile << "nbinx = " << nbinx << endl;
      glog.logfile << "nbiny = " << nbiny << endl;
      glog.logfile << "nbinz = " << nbinz << endl;
      glog.logfile << endl;
      glog.logfile << "nbins = " << nbins << endl;
      glog.logfile  << endl;
d207 6
a212 6
      glog.logfile  << "mbinx = " << mbinx << endl;
      glog.logfile  << "mbiny = " << mbiny << endl;
      glog.logfile  << "mbinz = " << mbinz << endl;
      glog.logfile  << endl;
      glog.logfile  << "mbins = " << mbins << endl;
      glog.logfile << endl;
d223 4
a226 4
  // How many bins in octant?  Contains bin + ghostbin regions
  pbinx = ioctbin[0]*2;
  pbiny = ioctbin[1]*2;
  pbinz = ioctbin[2]*2;
d231 6
a236 6
      glog.logfile  << "pbinx = " << pbinx << endl;
      glog.logfile  << "pbiny = " << pbiny << endl;
      glog.logfile  << "pbinz = " << pbinz << endl;
      glog.logfile  << endl;
      glog.logfile  << "pbins = " << pbins << endl;
      glog.logfile  << endl;
a238 1

d286 2
a287 2
      glog.logfile << "\n\n\n";
      glog.logfile << "Entering BinList::BinParticles()" << endl;
d301 5
a305 7
      if (m >= bins.size()) 
	{
	  cout << "m=" << m << endl;
	  glog.abort("BinList::BinParticles(1):\n"
		     "Bin outside range",comm);
	}
      if (m != -1) bins[m].particles.push_back(particles[i]);
d313 6
a318 7
      if (m >= bins.size()) 
	{
	  cout << "m=" << m << endl;	
	  glog.abort("BinList::BinParticles(2):\n"
		     "Bin outside range",comm);
	}
      if (m != -1) bins[m].particles.push_back(particles[i]);
d340 1
a340 3
      cout << "ix=" << *ix << "\tiy=" << *iy << "\tiz=" << *iz << endl;
      cout << "x[0]=" << x[0] << "\tx[1]=" << x[1] << "\tx[2]=" << x[2] << endl;
      cout << "X[0]=" << X[0] << "\tX[1]=" << X[1] << "\tX[2]=" << X[2] << endl;
d377 1
a377 3
      cout << "ix=" << *ix << "\tiy=" << *iy << "\tiz=" << *iz << endl;
      cout << "x[0]=" << x[0] << "\tx[1]=" << x[1] << "\tx[2]=" << x[2] << endl;
      cout << "X[0]=" << X[0] << "\tX[1]=" << X[1] << "\tX[2]=" << X[2] << endl;
d646 3
a648 6
  binsizex = (globalbounds[1]-globalbounds[0])/static_cast<double>(mbinx);
  binsizey = (globalbounds[3]-globalbounds[2])/static_cast<double>(mbiny);
  binsizez = (globalbounds[5]-globalbounds[4])/static_cast<double>(mbinz);

  cout << "binsizex=" << binsizex << "\t" << "binsizey=" 
       << binsizey << "\t" << "binsizez=" << binsizez << endl;
d653 1
d656 1
a656 3
  cout << procgrid[0] << endl;
  cout << procgrid[1] << endl;
  cout << procgrid[2] << endl;
d684 1
a684 2
       << ioctbin[1] << "\t" << "ioctbin[2]=" << ioctbin[2]  << endl;

d686 1
@


1.1.6.8
log
@Memory bug found.
@
text
@d179 2
@


1.1.6.9
log
@Correct a few bugs
@
text
@d134 1
a134 1
  - rcutneigh[0] - small;
d136 1
a136 1
  + rcutneigh[0] + small;
d138 1
a138 1
  - rcutneigh[1] - small;
d140 1
a140 1
  + rcutneigh[1] + small;
d142 1
a142 1
  - rcutneigh[2] - small;
d144 1
a144 1
  + rcutneigh[2] + small;
d146 7
a152 6
  cout << "------------------------\n";
  cout << "Proc. " << node << ":  \t";
  cout << localbounds[0] << "\t" << localbounds[1] << "\t";
  cout << localbounds[2] << "\t" << localbounds[3] << "\t";
  cout << localbounds[4] << "\t" << localbounds[5] << endl << endl;
  cout << "------------------------\n";
d223 4
a226 4
  // How many bins in a given proc?  Contains bin (ioctbin*2). NO ghost region.
  pbinx = ioctbin[0]*2+2;
  pbiny = ioctbin[1]*2+2;
  pbinz = ioctbin[2]*2+2;
d241 1
a242 1
  bins.resize(pbins);
d252 6
a257 12
	      //bins.resize(bins.size()+1);
	      int n =  k*mbiny*mbinx + j*mbinx + i; // global number
	      if (m >  bins.size()-1) 
	      	{
		  cout <<  "m =" << m << " > bins.size =" << bins.size() << "in SetUp\n";
		  glog.abort("BinList::Setup:\n"
			     "m > bins.size");
		}
	      bins[m].set_id(n);
	      bins[m].set_binx(i);
	      bins[m].set_biny(j);
	      bins[m].set_binz(k);
d259 1
a259 1
	      bins[m].set_binregion(fcb);	      
a273 10


  // Test ReturnBins2
  vector<Bin *> RegionBins;
  vector<Bin *>::iterator pbin;
  
  RegionBins = ReturnBins2(1.,0,1,b);
  for (pbin = RegionBins.begin();pbin!=RegionBins.end();pbin++)
    cout << "  " << (*pbin)->get_id() << "\t";    
  cout << endl<<endl;
a274 8
  for (pbin = RegionBins.begin();pbin!=RegionBins.end();pbin++)
    {
      double fcb[6];
      (*pbin)->get_binregion(fcb);
      cout << "(" << (*pbin)->get_id() << ")  " << fcb[0] << "\t" << fcb[1] << "\t" << fcb[2] << "\t"
	   << fcb[3] << "\t" << fcb[4] << "\t" << fcb[5] << endl;
    }
  cout << endl<<endl;     
a275 2

  exit(0); 
d391 12
a402 1
vector<Bin *> BinList::ReturnBins(const double X[6], const Box* b)
d412 3
a414 17
  if(X[1]<=X[0]) {return RegionBins;};
  if(X[3]<=X[2]) {return RegionBins;};
  if(X[5]<=X[4]) {return RegionBins;};

  if (X[0] > 1.0)    
    ixlo = static_cast<int>((X[0] - 1.0)*nbinx) + nbinx + mbinxlo;
  else if (X[0] >= 0.0)
    ixlo = static_cast<int> (X[0]*nbinx) + mbinxlo;
  else    
    ixlo = static_cast<int>(X[0]*nbinx) + mbinxlo - 1;
  
  if (X[1] > 1.0)    
    ixhi = static_cast<int>((X[1] - 1.0)*nbinx) + nbinx + mbinxlo;
  else if (X[1] >= 0.0)
    ixhi = static_cast<int> (X[1]*nbinx) + mbinxlo;
  else    
    ixhi = static_cast<int>(X[1]*nbinx) + mbinxlo - 1;
d416 17
a432 50
  if (X[2] > 1.0)    
    iylo = static_cast<int>((X[2] - 1.0)*nbiny) + nbiny + mbinylo;
  else if (X[2] >= 0.0)
    iylo = static_cast<int> (X[2]*nbiny) + mbinylo;
  else 
    {   
      iylo = static_cast<int>(X[2]*nbiny) +mbinylo - 1;
    }
  
  if (X[3] > 1.0)    
    iyhi = static_cast<int>((X[3] - 1.0)*nbiny) + nbiny + mbinylo;
  else if (X[3] >= 0.0)
    iyhi = static_cast<int> (X[3]*nbiny) + mbinylo;
  else    
    iyhi = static_cast<int>(X[3]*nbiny) +mbinylo - 1;
  
  if (X[4] > 1.0)    
    izlo = static_cast<int>((X[4] - 1.0)*nbinz) + nbinz + mbinzlo;
  else if (X[4] >= 0.0)
    izlo = static_cast<int> (X[4]*nbinz) + mbinzlo;
  else    
    izlo =  static_cast<int>(X[4]*nbinz) + mbinzlo -1;

  if (X[5] > 1.0)    
    izhi = static_cast<int>((X[5] - 1.0)*nbinz) + nbinz + mbinzlo;
  else if (X[5] >= 0.0)
    izhi = static_cast<int> (X[5]*nbinz) + mbinzlo;
  else    
    izhi =  static_cast<int>(X[5]*nbinz) + mbinzlo -1;
  

  if ( (ixlo < 0 || ixlo >= mbinx) || (ixhi < 0 || ixhi >= mbinx) || 
       (iylo < 0 || iylo >= mbiny) || (iyhi < 0 || iyhi >= mbiny) || 
       (izlo < 0 || izlo >= mbinz) || (izhi < 0 || izhi >= mbinz) )
  {
    cout << "ixlo=" << X[0] << "\t" <<ixlo << endl;
    cout << "ixhi=" << X[1] << "\t" <<ixhi << endl;
    cout << "iylo=" << X[2] << "\t" <<iylo << endl;
    cout << "iyhi=" << X[3] << "\t" <<iyhi << endl;
    cout << "izlo=" << X[4] << "\t" <<izlo << endl;
    cout << "izhi=" << X[5] << "\t" <<izhi << endl;


    glog.abort("BinList::ReturnBins:\n"
	       "Bin outside range");    
  } 
  
  for (int k=izlo;k<=izhi;k++)
    for (int j=iylo;j<=iyhi;j++)
      for (int i=ixlo;i<=ixhi;i++)
a445 53
vector<Bin *> BinList::ReturnBins2(const double x0,const int i,
				   const int infsup,const Box* b)
{ 
  // if infsup == 1 : greater than
  // else           : lower than

  vector<Bin *> RegionBins;
  RegionBins.resize(0);
  vector<Bin *> collect;
  collect.resize(0);
  vector<Bin *>::iterator pbin;
  double region[6];
  int m;

  region[0] = globalbounds[0]+2*small;
  region[1] = globalbounds[1]-2*small;
  region[2] = globalbounds[2]+2*small;
  region[3] = globalbounds[3]-2*small;
  region[4] = globalbounds[4]+2*small;
  region[5] = globalbounds[5]-2*small;
  
  if (infsup == 1)
    {
      if (i==0) m = 0;
      if (i==1) m = 2;
      if (i==2) m = 4;
      region[m] = x0;
    }
  else
    {
      if (i==0) m = 1;
      if (i==1) m = 3;
      if (i==2) m = 5;
      region[m] = x0;
    }

  /*if( (region[0] >= localbounds[0] || region[1] <= localbounds[1]) ||
      (region[2] >= localbounds[2] || region[3] <= localbounds[3]) ||
      (region[4] >= localbounds[4] || region[5] <= localbounds[5]) )
    {
      collect = ReturnBins(region,b);
      for (pbin = collect.begin();pbin!=collect.end();pbin++)
	RegionBins.push_back(*pbin);
      collect.resize(0);
    }
  */

     
  RegionBins = ReturnBins(region,b);    
  return  RegionBins;
}


d472 3
a474 3
  for (int k=izlo;k<=izhi;k++)
    for (int j=iylo;j<=iyhi;j++)
      for (int i=ixlo;i<=ixhi;i++)
d504 11
a514 6
  region[0] = reg[0] - rcutneigh[0] + 2*small;
  region[1] = reg[1] + rcutneigh[0] - 2*small;
  region[2] = reg[2] - rcutneigh[1] + 2*small;
  region[3] = reg[3] + rcutneigh[1] - 2*small;
  region[4] = reg[4] - rcutneigh[2] + 2*small;
  region[5] = reg[5] + rcutneigh[2] - 2*small;
d616 1
a616 2
  // Given a global bin number m, return the local number n 
  // on the proc this bin belongs to
a618 4
  int ilx = static_cast<int>(pbinx*static_cast<double>(ix)/static_cast<double>(mbinx));
  int ily = static_cast<int>(pbiny*static_cast<double>(iy)/static_cast<double>(mbiny));
  int ilz = static_cast<int>(pbinz*static_cast<double>(iz)/static_cast<double>(mbinz));

d623 4
a626 4
  if ( (binbnds[0] >= localbounds[0] && binbnds[1] <= localbounds[1]) &&
       (binbnds[2] >= localbounds[2] && binbnds[3] <= localbounds[3]) &&
       (binbnds[4] >= localbounds[4] && binbnds[5] <= localbounds[5]) ) 
     n = pbinx*pbiny*ilz + pbinx*ily + ilx;
d658 3
d666 3
a669 2

  // proc. size without ghost region
d682 1
a682 1
  rc[1] = (locals[1]-locals[0])*0.5;
d685 1
a685 1
  rc[3] = (locals[3]-locals[2])*0.5;
d688 1
a688 1
  rc[5] = (locals[5]-locals[4])*0.5;
d695 3
a697 3
  if (ioctbin[0]==0) ioctbin[0] = 1;
  if (ioctbin[1]==0) ioctbin[1] = 1;
  if (ioctbin[2]==0) ioctbin[2] = 1;
a702 1

@


1.1.6.10
log
@Correct a few bugs
@
text
@d146 7
d287 2
a288 2
    glog.logfile << "  " << (*pbin)->get_id() << "\t";    
  glog.logfile << endl<<endl;
d294 1
a294 1
      glog.logfile << "(" << (*pbin)->get_id() << ")  " << fcb[0] << "\t" << fcb[1] << "\t" << fcb[2] << "\t"
d297 1
a297 1
  glog.logfile << endl<<endl;     
d300 1
a300 1
  //exit(0); 
d486 1
@


1.1.6.11
log
@Output to node file
@
text
@d280 2
a281 4
    if (comm->get_Lnodefile())
      comm->get_nodefile() << "  " << (*pbin)->get_id() << "\t";    
  if (comm->get_Lnodefile())
    comm->get_nodefile() << endl<<endl;
d287 2
a288 4
       if (comm->get_Lnodefile())
	 comm->get_nodefile() << "(" << (*pbin)->get_id() << ")  " 
			      << fcb[0] << "\t" << fcb[1] << "\t" << fcb[2] << "\t"
			      << fcb[3] << "\t" << fcb[4] << "\t" << fcb[5] << endl;
d290 1
a290 1
  if (comm->get_Lnodefile()) comm->get_nodefile() << endl<<endl;     
d292 2
@


1.1.6.12
log
@Routine ReturnBins2 works ok. Correct a bug
@
text
@d164 1
a164 1
  if (comm->get_Lnodefile()) 
d166 3
a168 3
      comm->get_nodefile() << "(out) binsizex = " << binsizex << endl;
      comm->get_nodefile() << "(out) binsizey = " << binsizey << endl;
      comm->get_nodefile() << "(out) binsizez = " << binsizez << endl;
a239 1
	  Bin2Bnds(i,j,k,fcb);
d256 1
a257 4


	      //cout << "(" << m << ")  " << fcb[0] << "\t" << fcb[1] << endl;		

d260 1
a260 2


d275 1
a275 1
  /*vector<Bin *> RegionBins;
d280 4
a283 2
    cout << "  " << (*pbin)->get_id() << "\t";    
  cout << endl<<endl;
d289 4
a292 3
      cout << "(" << (*pbin)->get_id() << ")  " 
	   << fcb[0] << "\t" << fcb[1] << "\t" << fcb[2] << "\t"
	   << fcb[3] << "\t" << fcb[4] << "\t" << fcb[5] << endl;
d294 2
a295 2
  cout << endl<<endl;    
  */ 
d444 3
a446 1
    iylo = static_cast<int>(X[2]*nbiny) +mbinylo - 1;
d474 6
a479 6
    cout << X[0] << "\t" << "ixlo=" <<ixlo << endl;
    cout << X[1] << "\t" << "ixhi=" <<ixhi << endl;
    cout << X[2] << "\t" << "iylo=" <<iylo << endl;
    cout << X[3] << "\t" << "iyhi=" <<iyhi << endl;
    cout << X[4] << "\t" << "izlo=" <<izlo << endl;
    cout << X[5] << "\t" << "izhi=" <<izhi << endl;
d536 12
d717 1
a717 1
int BinList::Map(const int ix,const int iy,const int iz)
d772 2
a773 1
  // proc. size
d786 1
a786 1
  rc[1] = (locals[1]+locals[0])*0.5;
d789 1
a789 1
  rc[3] = (locals[3]+locals[2])*0.5;
d792 1
a792 1
  rc[5] = (locals[5]+locals[4])*0.5;
a805 1

@


1.1.6.13
log
@Correct more bugs...
@
text
@d214 1
a214 1

a380 14
  double reg[6],regc[6];
  reg[0] = X[0];
  reg[1] = X[0];
  reg[2] = X[1];
  reg[3] = X[1];
  reg[4] = X[2];
  reg[5] = X[2];
  GlobalBounds(reg,regc);

  *ix = static_cast<int>(regc[0]*mbinx);
  *iy = static_cast<int>(regc[2]*mbiny);
  *iz = static_cast<int>(regc[4]*mbinz);
  
  /*
a400 1
    */
a426 11
  double regc[6];
  GlobalBounds(X,regc);

  ixlo = static_cast<int>(regc[0]*mbinx);
  ixhi = static_cast<int>(regc[1]*mbinx);
  iylo = static_cast<int>(regc[2]*mbiny);
  iylo = static_cast<int>(regc[3]*mbiny);
  izlo = static_cast<int>(regc[4]*mbinz);
  izhi = static_cast<int>(regc[5]*mbinz);

  /*
d468 1
a468 1
  */  
@


1.1.6.14
log
@Add more flags
@
text
@d324 1
a324 1
      if (m >= bins.size() && m != -1) 
d338 1
a338 1
      if (m >= bins.size() && m != -1) 
@


1.1.6.15
log
@correction
@
text
@d448 1
a448 1
  iyhi = static_cast<int>(regc[3]*mbiny);
@


1.1.6.15.2.1
log
@Added class Comm_Octant
@
text
@a593 9
  cout << "reg[0] = " << reg[0] << " reg[1] " << reg[1] << endl;
  cout << "reg[2] = " << reg[2] << " reg[3] " << reg[3] << endl;
  cout << "reg[4] = " << reg[4] << " reg[5] " << reg[5] << endl;
  cout << "regc[0] = " << regc[0] << " regc[1] " << regc[1] << endl;
  cout << "regc[2] = " << regc[2] << " regc[3] " << regc[3] << endl;
  cout << "regc[4] = " << regc[4] << " regc[5] " << regc[5] << endl;
  cout << "ixlo = " << ixlo << " ixhi " << ixhi << endl;
  cout << "iylo = " << iylo << " iyhi " << iyhi << endl;
  cout << "izlo = " << izlo << " izhi " << izhi << endl;
a821 190
int BinList::pack_comm_size(const int& num, const vector<int>& list) {

  int ibin,nsend;

  nsend = 0;
  for (int isend=0;isend<num;isend++) {
    ibin = list[isend];
    nsend+=1+size_comm*bins[ibin].particles.size();
  }

  return nsend;
}
      
void BinList::pack_comm(const int& num, const vector<int>& list , double* buf, 
		       const int pbc[], const Box* b) {

  int ibin,nsend,ntmp;
  double rshift[3],lva[3],lvb[3],lvc[3];

  // First compute shift due to periodic boundary, if any

  if (pbc[0]) {
    b->get_lv(lva,lvb,lvc);
    rshift[0] = 0.0;
    rshift[1] = 0.0;
    rshift[2] = 0.0;

    if (pbc[1]==-1) {
      vec3_subtract(rshift,lva,rshift);
    } else if (pbc[1]==1) {
      vec3_add(rshift,lva,rshift);
    }

    if (pbc[2]==-1) {
      vec3_subtract(rshift,lvb,rshift);
    } else if (pbc[2]==1) {
      vec3_add(rshift,lvb,rshift);
    }
    
    if (pbc[3]==-1) {
      vec3_subtract(rshift,lvc,rshift);
    } else if (pbc[3]==1) {
      vec3_add(rshift,lvc,rshift);
    }
  }

  nsend = 0;
  for (int isend=0;isend<num;isend++) {
    ibin = list[isend];
    buf[nsend] = static_cast<double>(bins[ibin].particles.size());
    nsend++;
    ntmp = nsend;
    // May need to call a ParticleList pack function here instead,
    // in which case pbc shifts will best be performed inside it
    for (vector<Particle>::iterator part_i = bins[ibin].particles.begin();
	 part_i != bins[ibin].particles.end();part_i++) {
      part_i->get_x(&buf[nsend]);
      nsend+=size_comm;
    }

    if (pbc[0]) {
      // Move back the pointer and apply shift
      nsend=ntmp;
      for (vector<Particle>::iterator part_i=bins[ibin].particles.begin();
	   part_i!=bins[ibin].particles.end();part_i++) {
	part_i->get_x(&buf[nsend]);
	vec3_add(&buf[nsend],rshift,&buf[nsend]);
	nsend+=size_comm;
      }
    }
  }

}
      
void BinList::unpack_comm(const int& num, const vector<int>& list , const double* buf) {

  int ibin,nrecv;

  nrecv = 0;
  for (int irecv=0;irecv<num;irecv++) {
    ibin = list[irecv];
    // This creates space for the new particles.
    // It does not guarantee that old particles are erased, 
    // so beware of residual data from previous passes.
    bins[ibin].particles.resize(static_cast<int>(buf[nrecv]));
    nrecv++;
    // May need to call a ParticleList unpack function here instead
    for (vector<Particle>::iterator part_i = bins[ibin].particles.begin();
	 part_i != bins[ibin].particles.end();part_i++) {
      part_i->set_x(&buf[nrecv]);
      nrecv+=size_comm;
    }
  }
}

int BinList::pack_reverse_size(const int& num, const vector<int>& list) {

  int ibin,nsend;

  nsend = 0;
  for (int isend=0;isend<num;isend++) {
    ibin = list[isend];
    nsend+=1+size_reverse*bins[ibin].particles.size();
  }

  return nsend;
}
      
void BinList::pack_reverse(const int& num, const vector<int>& list , double* buf, 
		       const int pbc[], const Box* b) {

  int ibin,nsend,ntmp;
  double rshift[3],lva[3],lvb[3],lvc[3];

  // First compute shift due to periodic boundary, if any

  if (pbc[0]) {
    b->get_lv(lva,lvb,lvc);
    rshift[0] = 0.0;
    rshift[1] = 0.0;
    rshift[2] = 0.0;

    if (pbc[1]==1) {
      vec3_subtract(rshift,lva,rshift);
    } else if (pbc[1]==-1) {
      vec3_add(rshift,lva,rshift);
    }

    if (pbc[2]==1) {
      vec3_subtract(rshift,lvb,rshift);
    } else if (pbc[2]==-1) {
      vec3_add(rshift,lvb,rshift);
    }
    
    if (pbc[3]==1) {
      vec3_subtract(rshift,lvc,rshift);
    } else if (pbc[3]==-1) {
      vec3_add(rshift,lvc,rshift);
    }
  }

  nsend = 0;
  for (int isend=0;isend<num;isend++) {
    ibin = list[isend];
    buf[nsend] = static_cast<double>(bins[ibin].particles.size());
    nsend++;
    ntmp = nsend;
    // May need to call a ParticleList pack function here instead,
    // in which case pbc shifts will best be performed inside it
    for (vector<Particle>::iterator part_i = bins[ibin].particles.begin();
	 part_i != bins[ibin].particles.end();part_i++) {
      part_i->get_x(&buf[nsend]);
      nsend+=size_reverse;
    }

    if (pbc[0]) {
      // Move back the pointer and apply shift
      nsend=ntmp;
      for (vector<Particle>::iterator part_i=bins[ibin].particles.begin();
	   part_i!=bins[ibin].particles.end();part_i++) {
	part_i->get_x(&buf[nsend]);
	vec3_add(&buf[nsend],rshift,&buf[nsend]);
	nsend+=size_reverse;
      }
    }
  }

}
      
void BinList::unpack_reverse(const int& num, const vector<int>& list , const double* buf) {

  int ibin,nrecv;

  nrecv = 0;
  for (int irecv=0;irecv<num;irecv++) {
    ibin = list[irecv];
    // This creates space for the new particles.
    // It does not guarantee that old particles are erased, 
    // so beware of residual data from previous passes.
    bins[ibin].particles.resize(static_cast<int>(buf[nrecv]));
    nrecv++;
    // May need to call a ParticleList unpack function here instead
    for (vector<Particle>::iterator part_i = bins[ibin].particles.begin();
	 part_i != bins[ibin].particles.end();part_i++) {
      part_i->set_x(&buf[nrecv]);
      nrecv+=size_reverse;
    }
  }
}

@


1.1.6.15.2.2
log
@Finished fist pass of testing on Comm_Octant class
@
text
@d594 9
a602 9
//   cout << "reg[0] = " << reg[0] << " reg[1] " << reg[1] << endl;
//   cout << "reg[2] = " << reg[2] << " reg[3] " << reg[3] << endl;
//   cout << "reg[4] = " << reg[4] << " reg[5] " << reg[5] << endl;
//   cout << "regc[0] = " << regc[0] << " regc[1] " << regc[1] << endl;
//   cout << "regc[2] = " << regc[2] << " regc[3] " << regc[3] << endl;
//   cout << "regc[4] = " << regc[4] << " regc[5] " << regc[5] << endl;
//   cout << "ixlo = " << ixlo << " ixhi " << ixhi << endl;
//   cout << "iylo = " << iylo << " iyhi " << iyhi << endl;
//   cout << "izlo = " << izlo << " izhi " << izhi << endl;
@


1.1.6.15.2.3
log
@Correct a few bugs
@
text
@d1 1
a1 1

d93 1
a93 1
  // In fractional coordinates, if domain dimension is [0,1]^3 and 
a103 4
      glog.logfile  << "procgrid[0] = " << procgrid[0] << endl;
      glog.logfile  << "procgrid[1] = " << procgrid[1] << endl;
      glog.logfile  << "procgrid[2] = " << procgrid[2] << endl;

d130 29
a158 14
  // Check that the right number of proc is allocated
  double check[3];
  check[0] = (1.+ 2*rcutneigh[0])/(4.*rcutneigh[0]);
  check[1] = (1.+ 2*rcutneigh[1])/(4.*rcutneigh[1]);
  check[2] = (1.+ 2*rcutneigh[2])/(4.*rcutneigh[2]);
  if (procgrid[0] > check[0] || procgrid[1] > check[1] || 
      procgrid[2] > check[2]) 
   {
      cout << "Number of processors allocated wrong, nprocs = ";
      cout << nprocs << " has to be lower than " 
	   << static_cast<int>(check[0]*check[1]*check[2]) << "\n";
      glog.abort("BinList::SetUp:\n"
  		 "Wrong number of procs.");
   }
d164 1
a164 1
  if (node == 0) 
d166 3
a168 3
      glog.logfile << "binsizex = " << binsizex << endl;
      glog.logfile << "binsizey = " << binsizey << endl;
      glog.logfile << "binsizez = " << binsizez << endl;
d192 3
a194 3
  mbinx = nbinx + 2*static_cast<int> (binsizex/rcutneigh[0]);
  mbiny = nbiny + 2*static_cast<int> (binsizey/rcutneigh[1]);
  mbinz = nbinz + 2*static_cast<int> (binsizez/rcutneigh[2]);
d208 11
a218 24
  mbinxlo = static_cast<int> (binsizex/rcutneigh[0]);
  mbinxhi = mbinx - mbinxlo;
  mbinylo = static_cast<int> (binsizey/rcutneigh[1]);
  mbinyhi = mbiny - mbinylo;
  mbinzlo = static_cast<int> (binsizez/rcutneigh[2]);
  mbinzhi = mbinz - mbinzlo;

  if (node == 0)
    {
      glog.logfile << "mbinxlo = " << mbinxlo << endl;
      glog.logfile << "mbinxhi = " << mbinxhi << endl;
      glog.logfile << "mbinylo = " << mbinylo << endl;
      glog.logfile << "mbinyhi = " << mbinyhi << endl;
      glog.logfile << "mbinzlo = " << mbinzlo << endl;
      glog.logfile << "mbinzhi = " << mbinzhi << endl;
      glog.logfile  << endl;
    }

  // How many bins on a given proc?  Contains bin (ioctbin*2). NO ghost region.
  pbinx = ioctbin[0]*2;
  pbiny = ioctbin[1]*2;
  pbinz = ioctbin[2]*2;


d231 1
d242 1
a242 1
	  int m = Map(i,j,k,comm);
d258 4
d265 1
d273 1
a273 1
	  int m = Map(ix,iy,iz,comm);
d275 1
a275 1
	    bins[m].set_nbrs(SelectNbrBins(ix,iy,iz,comm));
d279 2
a280 2
  // Trial
  /*vector <Bin*> checkbins;
d282 7
a288 9
  double region[6];
  region[0] = 0.45;
  region[1] = 0.8;
  region[2] = 0.45;
  region[3] = 0.8;
  region[4] = 0.45;
  region[5] = 0.8;
  checkbins = ReturnBins(region,b,comm);
  for (pbin = checkbins.begin();pbin!=checkbins.end();pbin++)
d292 2
a293 1
      cout << "(" << (*pbin)->get_id() << ")  " << fcb[0] << "\t" << fcb[1] << "\t" << fcb[2] << "\t"
d296 2
a297 4

  cout << endl << endl;
  */

d323 2
a324 2
      int m = Map(ix,iy,iz,comm);
      if ( (m >= bins.size() || m < 0)&& m != -1) 
d337 2
a338 2
      int m = Map(ix,iy,iz,comm);
      if ( (m >= bins.size() || m < 0) && m != -1) 
d394 23
d425 1
a425 1
    }   
d428 1
a428 1
vector<Bin *> BinList::ReturnBins(const double X[6], const Box* b,Comm* comm)
a429 2
  // return number of bins in a given region for a given proc.

d442 1
a442 1
  /*double regc[6];
a450 1
  */
d452 3
a454 2
  if (X[0] >= 1.0)
    ixlo = static_cast<int> ((X[0] - 1.0)*nbinx) + nbinx + mbinxlo;
d457 5
a461 5
  else
    ixlo = static_cast<int> (X[0]*nbinx) + mbinxlo - 1;

  if (X[1] >= 1.0)
    ixhi = static_cast<int> ((X[1] - 1.0)*nbinx) + nbinx + mbinxlo;
d464 5
a468 5
  else
    ixhi = static_cast<int> (X[1]*nbinx) + mbinxlo - 1;
  
   if (X[2] >= 1.0)
    iylo = static_cast<int> ((X[2] - 1.0)*nbiny) + nbiny + mbinylo;
d471 5
a475 5
  else
    iylo = static_cast<int> (X[2]*nbiny) + mbinylo - 1;

  if (X[3] >= 1.0)
    iyhi = static_cast<int> ((X[3] - 1.0)*nbiny) + nbiny + mbinylo;
d478 5
a482 5
  else
    iyhi = static_cast<int> (X[3]*nbiny) + mbinylo - 1;

 if (X[4] >= 1.0)
    izlo = static_cast<int> ((X[4] - 1.0)*nbinz) + nbinz + mbinzlo;
d485 2
a486 2
  else
    izlo = static_cast<int> (X[4]*nbinz) + mbinzlo - 1;
d488 2
a489 2
  if (X[5] >= 1.0)
    izhi = static_cast<int> ((X[5] - 1.0)*nbinz) + nbinz + mbinzlo;
d492 3
a494 3
  else
    izhi = static_cast<int> (X[5]*nbinz) + mbinzlo - 1;

d511 3
a513 3
  for (int k=max(izlo-1,0);k<=izhi;k++)
    for (int j=max(iylo-1,0);j<=iyhi;j++)
      for (int i=max(ixlo-1,0);i<=ixhi;i++)
d515 1
a515 1
	  int m = Map(i,j,k,comm);
d522 1
a522 1

d528 1
a528 2
				   const int infsup,const Box* b,
				   Comm *comm)
d563 1
a563 1
  RegionBins = ReturnBins(region,b,comm);    
d568 1
a568 1
vector<Bin *> BinList::SelectRegionBins(const double reg[6], const Box* b, Comm * comm)
d571 1
a571 2
  // no-ghost region only.

d587 16
a602 19
  ixlo =  static_cast<int> (regc[0]*mbinx);
  ixhi =  static_cast<int> (regc[1]*mbinx);
  iylo =  static_cast<int> (regc[2]*mbiny);
  iyhi =  static_cast<int> (regc[3]*mbiny);
  izlo =  static_cast<int> (regc[4]*mbinz);
  izhi =  static_cast<int> (regc[5]*mbinz);

  int node;
  node = comm->get_node();
  if (comm->get_Lnodefile()) 
    {
      comm->get_nodefile() << "ixlo=" << ixlo << "\t";
      comm->get_nodefile() << "ixhi=" << ixhi << "\t";
      comm->get_nodefile() << "iylo=" << iylo << "\t";
      comm->get_nodefile() << "iyhi=" << iyhi << "\t";
      comm->get_nodefile() << "izlo=" << izlo << "\t";
      comm->get_nodefile() << "izhi=" << izhi << "\n";
    }

d607 1
a607 1
	  int m = Map(i,j,k,comm);
d619 1
a619 1
vector<Bin *> BinList::SelectGhostRegionBins(const double reg[6], const Box* b, Comm * comm)
d623 1
a623 1
  
d627 1
a627 1
  
d633 1
a633 1
  // add ghost region
d635 12
a646 17
  region[0] = reg[0] - rcutneigh[0]; 
  region[1] = reg[1] + rcutneigh[0]; 
  region[2] = reg[2] - rcutneigh[1]; 
  region[3] = reg[3] + rcutneigh[1]; 
  region[4] = reg[4] - rcutneigh[2]; 
  region[5] = reg[5] + rcutneigh[2]; 
  
  if (comm->get_Lnodefile()) 
    {
      comm->get_nodefile() << "Region\n";
      comm->get_nodefile() << "  [" << region[0] << "\t" << region[1] << "\t" 
			   << region[2] << "\t" << region[3] << "\t" 
			   << region[4] << "\t" << region[5] << "]" << endl;
    }
  
  // Remove bins in non-ghost-region
  collect = ReturnBins(region,b,comm);
d655 1
a655 1
	(*pbin)->set_id(-2);
d660 2
a661 2
      if ( (*pbin)->get_id() != -2)
	RegionGhostBins.push_back(*pbin);
d667 1
a667 1
vector<Bin *> BinList::SelectNbrBins (const int ix,const int iy, const int iz, Comm * comm)
d689 1
a689 1
	      int m = Map(i,j,k,comm);
d702 12
d727 1
d740 1
a740 1
int BinList::Map(const int ix,const int iy,const int iz,Comm *comm)
a743 6

  int loc[3];
  comm->get_myloc(loc);
  int procgrid[3];
  comm->get_procgrid(procgrid);

d746 12
a757 13
  // number of bins per proc * position of the given proc
  int rmx = loc[0]*mbinx/procgrid[0];
  int rmy = loc[1]*mbiny/procgrid[1];
  int rmz = loc[2]*mbinz/procgrid[2];  

  int ilx = ix-rmx;
  int ily = iy-rmy;
  int ilz = iz-rmz;

  if ((ilx < 0 || ilx >= pbinx) || (ily < 0 || ily >= pbiny) || (ilz < 0 || ilz >= pbinz) )
    n = -1;
  else
    n = pbinx*pbiny*ilz + pbinx*ily + ilx;
d779 11
a789 1
  // Local region in fractional coordinates - with ghost region
d795 33
a827 21
  double localbounds[6];
  localbounds[0] = static_cast<double>(loc[0])/static_cast<double>(procgrid[0]);
  localbounds[1] = static_cast<double>(loc[0]+1)/static_cast<double>(procgrid[0]);
  localbounds[2] = static_cast<double>(loc[1])/static_cast<double>(procgrid[1]);
  localbounds[3] = static_cast<double>(loc[1]+1)/static_cast<double>(procgrid[1]);
  localbounds[4] = static_cast<double>(loc[2])/static_cast<double>(procgrid[2]);
  localbounds[5] = static_cast<double>(loc[2]+1)/static_cast<double>(procgrid[2]);
  
  // calculate binsize
  double len[3];

  // size of an octant - no ghost region
  len[0] = 0.5*(localbounds[1]-localbounds[0]);
  len[1] = 0.5*(localbounds[3]-localbounds[2]);
  len[2] = 0.5*(localbounds[5]-localbounds[4]);
  
  // number of bins or rcuts in an octant
  ioctbin[0] = static_cast<int>(len[0]/rcutneigh[0]);
  ioctbin[1] = static_cast<int>(len[1]/rcutneigh[1]);
  ioctbin[2] = static_cast<int>(len[2]/rcutneigh[2]);
  
a828 13
  // octant size has to be at least 2*rcut
  if (ioctbin[0] <= 2 || ioctbin[1] <= 2 || ioctbin[2] <= 2) 
    {
      cout << "ioctbin[0]=" << ioctbin[0] << "\t";
      cout << "ioctbin[1]=" << ioctbin[1] << "\t";
      cout << "ioctbin[2]=" << ioctbin[2] << "\n";
      glog.abort("BinList::BinSize:\n"
		 "Check cut off");      
    }
  
  binsizex = len[0]/static_cast<double>(ioctbin[0]);
  binsizey = len[1]/static_cast<double>(ioctbin[1]);
  binsizez = len[2]/static_cast<double>(ioctbin[2]);
d1020 1
@


1.1.6.15.2.4
log
@Implement correctly bin and ghost bin lists
@
text
@d2 1
a74 4
  // define some common variables
  comm->get_procgrid(procgrid);
  nprocs = procgrid[0]*procgrid[1]*procgrid[2];
  
d77 3
a79 1

d118 31
a160 1
  // global numbering of bins without periodic region
a180 1
  // global numbering of bins with periodic region 
d215 1
a215 1
  // local  numbering of bins without periodic region
d220 1
a222 7
  // local  numbering of bins with periodic region and ghost bins
  qbinx = pbinx + 2;
  qbiny = pbiny + 2;
  qbinz = pbinz + 2;

  qbins = qbinx*qbiny*qbinz;

d235 2
a236 1
  bins.resize(qbins);
d241 3
a243 3
	  // map global bin number to local position on proc.
	  int ip = 0;
	  int m = CreateMap(i,j,k,&ip,comm);
d246 2
a247 2
	      // m = global numbering, n = local numbering
	      int n =  k*mbiny*mbinx + j*mbinx + i; 
d250 1
a250 2
		  cout <<  "m =" << m << " > bins.size =" << bins.size() 
		       << "in SetUp\n";
d254 5
a258 46

		  bins[m].set_id(n);
		  bins[m].set_binx(i);
		  bins[m].set_biny(j);
		  bins[m].set_binz(k);
		  bins[m].set_perbin(ip);
	
		  double fcb[6];
		  fcb[0] = (i-1)*binsizex;
		  fcb[1] = i*binsizex;
		  fcb[2] = (j-1)*binsizey;
		  fcb[3] = j*binsizey;
		  fcb[4] = (k-1)*binsizez;
		  fcb[5] = k*binsizez;
		  
		  bins[m].set_binregion(fcb);	
	    }
	}

  // print out bins
  /* 
  for (int k=0;k<mbinz;k++)
    for (int j=0;j<mbiny;j++)
      for (int i=0;i<mbinx;i++)
	{
	  
	  int m = Map(i,j,k,comm);
	  if (m != -1)
	    {
	      double fcb[6];
	      int n =  k*mbiny*mbinx + j*mbinx + i; 
	      bins[m].get_binregion(fcb);
	      

	      //cout << "(" << n << "/" << m << ") - \n";  
	      //cout << fcb[0] << "\t" << fcb[1] << "\t" << fcb[2] << "\t"
	      //   << fcb[3] << "\t" << fcb[4] << "\t" << fcb[5] << endl;


	      if (comm->get_Lnodefile()) 
		{
		  comm->get_nodefile() << "(" << n << "/" << m << ") - \n";  
		  comm->get_nodefile() << fcb[0] << "\t" << fcb[1] << "\t" << fcb[2] << "\t"
				       << fcb[3] << "\t" << fcb[4] << "\t" << fcb[5] << endl;
		}

a261 6

  exit(0);
  */



d269 1
a269 1
       	  int m = Map(ix,iy,iz,comm);
d271 1
a271 1
	      bins[m].set_nbrs(SelectNbrBins(ix,iy,iz,comm));
d279 6
a284 6
  region[0] = 0.40;
  region[1] = 0.55;
  region[2] = 0.40;
  region[3] = 0.55;
  region[4] = 0.40;
  region[5] = 0.55;
d290 2
a291 3
      if (comm->get_Lnodefile())  
	comm->get_nodefile() << "(" << (*pbin)->get_id() << ")  " << fcb[0] << "\t" << fcb[1] << "\t" << fcb[2] << "\t"
			     << fcb[3] << "\t" << fcb[4] << "\t" << fcb[5] << endl;
d293 1
a293 1
  
d296 1
d349 1
a349 1
void BinList::Coord2Bin(const double x[3],const Box* b,int *ix,int *iy, int *iz)
d362 1
a362 2
  if ( (*ix < 0 || *ix >= mbinx)|| (*iy < 0 || *iy >= mbiny) || 
       (*iz < 0 || *iz >= mbinz) ) 
d380 14
a393 23
  if (X[0] >= 1.0)
    *ix = static_cast<int> ((X[0] - 1.0)*nbinx) + nbinx + mbinxlo;
  else if (X[0] >= 0.0)
    *ix = static_cast<int> (X[0]*nbinx) + mbinxlo;
  else
    *ix = static_cast<int> (X[0]*nbinx) + mbinxlo - 1;

   if (X[1] >= 1.0)
    *iy = static_cast<int> ((X[1] - 1.0)*nbiny) + nbiny + mbinylo;
  else if (X[1] >= 0.0)
    *iy = static_cast<int> (X[1]*nbiny) + mbinylo;
  else
    *iy = static_cast<int> (X[1]*nbiny) + mbinylo - 1;

 if (X[2] >= 1.0)
    *iz = static_cast<int> ((X[2] - 1.0)*nbinz) + nbinz + mbinzlo;
  else if (X[2] >= 0.0)
    *iz = static_cast<int> (X[2]*nbinz) + mbinzlo;
  else
    *iz = static_cast<int> (X[2]*nbinz) + mbinzlo - 1;

  if ( (*ix < 0 || *ix >= mbinx)|| (*iy < 0 || *iy >= mbiny) || 
       (*iz < 0 || *iz >= mbinz) ) 
d406 1
a406 1
  // return number of bins in a region
d410 1
d420 11
d489 3
a491 3
  for (int k=izlo;k<=izhi;k++)
    for (int j=iylo;j<=iyhi;j++)
      for (int i=ixlo;i<=ixhi;i++)
d501 1
a501 2

   return RegionBins;
d513 4
a519 9
  double globalbounds[6];
  globalbounds[0] =   - binsizex;
  globalbounds[1] = 1 + binsizex;
  globalbounds[2] =   - binsizey;
  globalbounds[3] = 1 + binsizey;
  globalbounds[4] =   - binsizez;
  globalbounds[5] = 1 + binsizez;


d547 1
a547 1
vector<Bin *> BinList::SelectRegionBins(const double X[6], const Box* b, Comm * comm)
a550 1
  // region is LOCAL to a proc
d552 5
a556 2
  int loc[3];
  comm->get_myloc(loc);
d558 4
a561 9
  // get region in global fractional coordinates
  /*double Y[6];
  Y[0] = static_cast<double>(loc[0])/static_cast<double>(procgrid[0]) + X[0];
  Y[1] = static_cast<double>(loc[0])/static_cast<double>(procgrid[0]) + X[1];
  Y[2] = static_cast<double>(loc[1])/static_cast<double>(procgrid[1]) + X[2];
  Y[3] = static_cast<double>(loc[1])/static_cast<double>(procgrid[1]) + X[3];
  Y[4] = static_cast<double>(loc[2])/static_cast<double>(procgrid[2]) + X[4];
  Y[5] = static_cast<double>(loc[2])/static_cast<double>(procgrid[2]) + X[5];
  */  
a562 2
  vector<Bin *> RegionBins;
  Bin* current_bin;
d564 9
a572 2
  int ixlo = static_cast<int>(mbinxlo + X[0]*nbinx);
  int ixhi = static_cast<int>(mbinxlo + X[1]*nbiny);
a573 6
  int iylo = static_cast<int>(mbinylo + X[2]*nbinz);
  int iyhi = static_cast<int>(mbinylo + X[3]*nbinz);
  
  int izlo = static_cast<int>(mbinzlo + X[4]*nbinz);
  int izhi = static_cast<int>(mbinzlo + X[5]*nbinz);
 
d602 1
a602 33
vector<Bin *> BinList::SelectGhostRegionBins(const int X[6], const Box* b, Comm * comm)
{  
  Bin* current_bin;
  vector<Bin* > RegionGhostBins;
  
  // add ghost region
  int Z[6];
  Z[0] = X[0] - 1; 
  Z[1] = X[1] + 1; 
  Z[2] = X[2] - 1; 
  Z[3] = X[3] + 1; 
  Z[4] = X[4] - 1; 
  Z[5] = X[5] + 1; 

  int ip = 0;
  for (int k=Z[4];k<=Z[5];k++)
    for (int j=Z[2];j<=Z[3];j++)
      for (int i=Z[0];i<=Z[1];i++)
	{	
	  int n = qbinx*qbiny*k + qbinx*j + i;
	  int m = CreateMap(i,j,k,&ip,comm);
	  if (i == Z[0] || i == Z[1] || j == Z[2] || j == Z[3] || 
	      k == Z[4] || k == Z[5] )
	    {
	      current_bin = &bins[n];
	      RegionGhostBins.push_back(current_bin);
	    }
	}

  return RegionGhostBins;
}

vector<Bin *> BinList::SelectGhostRegionBins(const double X[6], const Box* b, Comm * comm)
d604 2
a605 1
  // enter a fractional region only 
d608 1
d611 4
a614 2
  int loc[3];
  comm->get_myloc(loc);
d617 16
a632 8
  double Z[6];
  Z[0] = X[0] - rcutneigh[0]; 
  Z[1] = X[1] + rcutneigh[0]; 
  Z[2] = X[2] - rcutneigh[1]; 
  Z[3] = X[3] + rcutneigh[1]; 
  Z[4] = X[4] - rcutneigh[2]; 
  Z[5] = X[5] + rcutneigh[2]; 

d634 1
a634 1
  collect = ReturnBins(Z,b,comm);
d640 9
a648 4
      if ( (fcb[0] < X[0] || fcb[1] > X[1]) &&
	   (fcb[2] < X[2] || fcb[3] > X[3]) &&
	   (fcb[4] < X[4] || fcb[5] > X[5]) )
      
d650 1
a650 1
    }
d690 1
a690 1
int BinList::CreateMap(const int ix,const int iy,const int iz,int *ip,Comm *comm)
d692 3
a694 2
  int ilx,ily,ilz;
  int rmx,rmy,rmz;
d696 2
a697 2
  int loc[3];
  comm->get_myloc(loc);
d699 3
a701 2
  int n = -1;
  *ip = 0;
d703 7
a709 15
  // mark ghost bins 
  if( (ix == 0) || (ix == qbinx-1) || (iy == 0) || (iy == qbiny-1) ||
      (iz == 0) || (iz == qbinz-1) )
      *ip = 1;

  // proc are defined over their periodic region for simplicity.

  *ip = 0;
  rmx = loc[0]*(mbinx/procgrid[0] -mbinxlo);
  rmy = loc[1]*(mbiny/procgrid[1] -mbinylo);
  rmz = loc[2]*(mbinz/procgrid[2] -mbinzlo);  
 
  ilx = ix-rmx;
  ily = iy-rmy;
  ilz = iz-rmz;
d711 2
a712 6
  if ((ilx < 0 || ilx >= qbinx) || (ily < 0 || ily >= qbiny) || (ilz < 0 || ilz >= qbinz) )
    n = -1;
  else
    n = qbinx*qbiny*ilz + qbinx*ily + ilx;
    
  return n;
a714 1

a718 1
  int n = -1;
d722 9
a731 4
  int rmx = loc[0]*(mbinx/procgrid[0] -mbinxlo);
  int rmy = loc[1]*(mbiny/procgrid[1] -mbinylo);
  int rmz = loc[2]*(mbinz/procgrid[2] -mbinzlo);  
  
d736 1
a736 1
  if ((ilx < 0 || ilx >= qbinx) || (ily < 0 || ily >= qbiny) || (ilz < 0 || ilz >= qbinz) )
d739 2
a740 2
    n = qbinx*qbiny*ilz + qbinx*ily + ilx;
    
d744 15
d764 2
@


1.1.6.15.2.5
log
@Correct
@
text
@d92 1
a92 1
  b->get_lw(w);  
d96 1
a96 1
  // ghost domain dimension is [-rcut,1+rcut]^3. 
d102 1
a102 1

d585 10
d607 12
d826 1
d836 1
a836 1

@


1.1.6.15.2.6
log
@Implementation of 2 routines:
1./ Return ghost bins of an octant on the proc. of that octant.
2./ Return bins of a given translated region.
@
text
@a208 7

      glog.logfile  << "qbinx = " << qbinx << endl;
      glog.logfile  << "qbiny = " << qbiny << endl;
      glog.logfile  << "qbinz = " << qbinz << endl;
      glog.logfile  << endl;
      glog.logfile  << "qbins = " << qbins << endl;
      glog.logfile  << endl;
d237 1
a237 1
		  bins[m].set_ghostbin(ip);
d251 2
a252 17

  BinParticles(p->get_nparticles(),p->get_nghost_particles(),p->get_particles(), b, comm);

  // Define neighboring bins  
  for (int ix = mbinxlo; ix < mbinxhi; ix++) 
    for (int iy = mbinylo; iy < mbinyhi; iy++) 
      for (int iz = mbinzlo; iz < mbinzhi; iz++) 
	{
       	  int m = Map(ix,iy,iz,comm);
	  if (m != -1)
	      bins[m].set_nbrs(SelectNbrBins(ix,iy,iz,comm));
	}
}


void BinList::PrintBins(const Box*b, Comm* comm)
{
d265 6
a270 7
	      if (nprocs == 1)
		{
		  cout << "(" << n << "/" << m << ") - \n";  
		  cout << fcb[0] << "\t" << fcb[1] << "\t" << fcb[2] << "\t"
		       << fcb[3] << "\t" << fcb[4] << "\t" << fcb[5] << endl;
		}
		  
d277 1
a277 1
		  
d280 42
d324 1
d454 4
a457 15
  double Y[6];
  for (int i=0;i<6;i++) Y[i] = X[i];

  if (fabs (Y[0]+binsizex) <= small) Y[0] += small;
  if (fabs (Y[2]+binsizey) <= small) Y[2] += small;
  if (fabs (Y[4]+binsizez) <= small) Y[4] += small;

  if (fabs (Y[1] - 1 - binsizex) <= small) Y[1] -= small;
  if (fabs (Y[3] - 1 - binsizey) <= small) Y[3] -= small;
  if (fabs (Y[5] - 1 - binsizez) <= small) Y[5] -= small;

  if (Y[0] >= 1.0)
    ixlo = static_cast<int> ((Y[0] - 1.0)*nbinx) + nbinx + mbinxlo;
  else if (Y[0] >= 0.0)
    ixlo = static_cast<int> (Y[0]*nbinx) + mbinxlo;
d459 1
a459 1
    ixlo = static_cast<int> (Y[0]*nbinx) + mbinxlo - 1;
d461 4
a464 4
  if (Y[1] >= 1.0)
    ixhi = static_cast<int> ((Y[1] - 1.0)*nbinx) + nbinx + mbinxlo;
  else if (Y[1] >= 0.0)
    ixhi = static_cast<int> (Y[1]*nbinx) + mbinxlo;
d466 1
a466 1
    ixhi = static_cast<int> (Y[1]*nbinx) + mbinxlo - 1;
d468 4
a471 4
   if (Y[2] >= 1.0)
    iylo = static_cast<int> ((Y[2] - 1.0)*nbiny) + nbiny + mbinylo;
  else if (Y[2] >= 0.0)
    iylo = static_cast<int> (Y[2]*nbiny) + mbinylo;
d473 1
a473 1
    iylo = static_cast<int> (Y[2]*nbiny) + mbinylo - 1;
d475 4
a478 4
  if (Y[3] >= 1.0)
    iyhi = static_cast<int> ((Y[3] - 1.0)*nbiny) + nbiny + mbinylo;
  else if (Y[3] >= 0.0)
    iyhi = static_cast<int> (Y[3]*nbiny) + mbinylo;
d480 1
a480 1
    iyhi = static_cast<int> (Y[3]*nbiny) + mbinylo - 1;
d482 4
a485 4
 if (Y[4] >= 1.0)
    izlo = static_cast<int> ((Y[4] - 1.0)*nbinz) + nbinz + mbinzlo;
  else if (Y[4] >= 0.0)
    izlo = static_cast<int> (Y[4]*nbinz) + mbinzlo;
d487 1
a487 1
    izlo = static_cast<int> (Y[4]*nbinz) + mbinzlo - 1;
d489 4
a492 4
  if (Y[5] >= 1.0)
    izhi = static_cast<int> ((Y[5] - 1.0)*nbinz) + nbinz + mbinzlo;
  else if (Y[5] >= 0.0)
    izhi = static_cast<int> (Y[5]*nbinz) + mbinzlo;
d494 1
a494 1
    izhi = static_cast<int> (Y[5]*nbinz) + mbinzlo - 1;
d501 6
a506 6
    cout << "Y[0]=" << Y[0] << "\t" << "ixlo=" <<ixlo << endl;
    cout << "Y[1]=" << Y[1] << "\t" << "ixhi=" <<ixhi << endl;
    cout << "Y[2]=" << Y[2] << "\t" << "iylo=" <<iylo << endl;
    cout << "Y[3]=" << Y[3] << "\t" << "iyhi=" <<iyhi << endl;
    cout << "Y[4]=" << Y[4] << "\t" << "izlo=" <<izlo << endl;
    cout << "Y[5]=" << Y[5] << "\t" << "izhi=" <<izhi << endl;
d537 2
d540 16
a555 9
  double Y[6];
  Y[0] =   - binsizex + 2*small;
  Y[1] = 1 + binsizex - 2*small;
  Y[2] =   - binsizey + 2*small;
  Y[3] = 1 + binsizey - 2*small;
  Y[4] =   - binsizez + 2*small;
  Y[5] = 1 + binsizez - 2*small;

  int m = 0;
d561 1
a561 1
      Y[m] = x0;
d568 1
a568 1
      Y[m] = x0;
d571 1
a571 31
  RegionBins = ReturnBins(Y,b,comm);    
  return  RegionBins;
}


vector<Bin *> BinList::TranslatedBins(const double X[6],const double L[3],
				      const Box* b,Comm *comm)
{ 
  // Translated region has to be in fractional coordinates

  vector<Bin *> RegionBins;

  double Z[6];
  Z[0] =   - binsizex + 2*small;
  Z[1] = 1 + binsizex - 2*small;
  Z[2] =   - binsizey + 2*small;
  Z[3] = 1 + binsizey - 2*small;
  Z[4] =   - binsizez + 2*small;
  Z[5] = 1 + binsizez - 2*small;

  
  double Y[6];
  Y[0] = max(X[0]+L[0],Z[0]);
  Y[1] = min(X[1]+L[0],Z[1]);
  Y[2] = max(X[2]+L[1],Z[2]);
  Y[3] = min(X[3]+L[1],Z[3]);
  Y[4] = max(X[4]+L[2],Z[4]);
  Y[5] = min(X[5]+L[2],Z[5]);


  RegionBins = ReturnBins(Y,b,comm);    
d580 1
d627 1
d633 1
d671 2
a672 2
      if ( (fcb[0] < X[0] || fcb[1] > X[1]) ||
	   (fcb[2] < X[2] || fcb[3] > X[3]) ||
d727 1
a727 1
  // mark ghost bins of a given proc.
d733 2
@


1.1.6.15.2.7
log
@Implemented tools for bins lists:
  - intersection
  - union
  - copy constructor

Created a new class:  BinTools.
Tested these tools.

Seems to work ok in serial and parallel.
@
text
@a54 1
#include "bintools.h"
d724 1
a1014 2


@


1.1.6.15.2.8
log
@Implement Alex's algorithm to send specific octant bin lists.
No communication implemented yet.
@
text
@d73 1
a73 2
void BinList::Setup(const ParticleList* p, BinTools *bt, const Box* b, 
		    Comm* comm, ForceFieldList* ffl)
d126 3
a128 3
      glog.logfile << "binsize[0] = " << binsize[0] << endl;
      glog.logfile << "binsize[1] = " << binsize[1] << endl;
      glog.logfile << "binsize[2] = " << binsize[2] << endl;
d154 3
a156 3
  mbinx = nbinx + 2*static_cast<int> (binsize[0]/rcutneigh[0]);
  mbiny = nbiny + 2*static_cast<int> (binsize[1]/rcutneigh[1]);
  mbinz = nbinz + 2*static_cast<int> (binsize[2]/rcutneigh[2]);
d170 1
a170 1
  mbinxlo = static_cast<int> (binsize[0]/rcutneigh[0]);
d172 1
a172 1
  mbinylo = static_cast<int> (binsize[1]/rcutneigh[1]);
d174 1
a174 1
  mbinzlo = static_cast<int> (binsize[2]/rcutneigh[2]);
d248 6
a253 6
		  fcb[0] = (i-1)*binsize[0];
		  fcb[1] = i*binsize[0];
		  fcb[2] = (j-1)*binsize[1];
		  fcb[3] = j*binsize[1];
		  fcb[4] = (k-1)*binsize[2];
		  fcb[5] = k*binsize[2];
d438 7
a444 8
  // Adjust computer error
  if (fabs (Y[0]+binsize[0]) <= small) Y[0] += small;
  if (fabs (Y[2]+binsize[1]) <= small) Y[2] += small;
  if (fabs (Y[4]+binsize[2]) <= small) Y[4] += small;

  if (fabs (Y[1] - 1 - binsize[0]) <= small) Y[1] -= small;
  if (fabs (Y[3] - 1 - binsize[1]) <= small) Y[3] -= small;
  if (fabs (Y[5] - 1 - binsize[2]) <= small) Y[5] -= small;
a510 1
	      // Adjust bounds
d512 1
a512 7
	      double fcb[6];
	      current_bin->get_binregion(fcb);
	      
	      if ( (fcb[0] >= X[0] && fcb[1] <= X[1]) &&
		   (fcb[2] >= X[2] && fcb[3] <= X[3]) &&
		   (fcb[4] >= X[4] && fcb[5] <= X[5]) )
		RegionBins.push_back(current_bin);	  
d516 1
d531 6
a536 6
  Y[0] =   - binsize[0] + 2*small;
  Y[1] = 1 + binsize[0] - 2*small;
  Y[2] =   - binsize[1] + 2*small;
  Y[3] = 1 + binsize[1] - 2*small;
  Y[4] =   - binsize[2] + 2*small;
  Y[5] = 1 + binsize[2] - 2*small;
d559 1
a559 1
vector<Bin *> BinList::TranslatedBins(const double X[6],const int dir,
a564 18
  double L[3];

  int procgrid[3];
  comm->get_procgrid(procgrid);

  double procdist[3];
  // no ghost region here
  if (nprocs > 1)
    {
      procdist[0] = 1./static_cast<double>(procgrid[0]);
      procdist[1] = 1./static_cast<double>(procgrid[1]);
      procdist[2] = 1./static_cast<double>(procgrid[2]);
    }
  else
    for (int i = 0; i < 3; i++) procdist[i] = 0.0;

  for (int i = 0; i < 3; i++) L[i] = 0.0;
  L[dir] = procdist[dir];
d567 6
a572 6
  Z[0] =   - binsize[0] + 2*small;
  Z[1] = 1 + binsize[0] - 2*small;
  Z[2] =   - binsize[1] + 2*small;
  Z[3] = 1 + binsize[1] - 2*small;
  Z[4] =   - binsize[2] + 2*small;
  Z[5] = 1 + binsize[2] - 2*small;
d583 1
a588 25
void BinList::GetRegion(vector<Bin *>RegionBins,double region[6])
{
  if (RegionBins.size() == 0) 
    {
      for (int i = 0; i < 6; i++) region[i] = 0.0;
      return;
    }
  // Find region corresponding to a set of bins
  (*RegionBins.begin())->get_binregion(region);

  vector<Bin *>::iterator pbin;
  for (pbin = RegionBins.begin()+1;pbin!=RegionBins.end();pbin++)
    {
      double fcb[6];
      (*pbin)->get_binregion(fcb);
      if (fcb[0] < region[0]) region[0] = fcb[0];
      if (fcb[1] > region[1]) region[1] = fcb[1];
      if (fcb[2] < region[2]) region[2] = fcb[2];
      if (fcb[3] > region[3]) region[3] = fcb[3];
      if (fcb[4] < region[4]) region[4] = fcb[4];
      if (fcb[5] > region[5]) region[5] = fcb[5];
    }  
}


d617 1
a617 10

	      // Adjust bounds
	      current_bin = &bins[m];
	      double fcb[6];
	      current_bin->get_binregion(fcb);
	      
	      if ( (fcb[0] >= X[0] && fcb[1] <= X[1]) &&
		   (fcb[2] >= X[2] && fcb[3] <= X[3]) &&
		   (fcb[4] >= X[4] && fcb[5] <= X[5]) )
		RegionBins.push_back(current_bin);	  
d667 6
a672 6
  Z[0] = X[0] - binsize[0];
  Z[1] = X[1] + binsize[0];
  Z[2] = X[2] - binsize[1];
  Z[3] = X[3] + binsize[1];
  Z[4] = X[4] - binsize[2];
  Z[5] = X[5] + binsize[2];
a724 51

vector<Bin *> BinList::GenerateGhostBinsDir(int dir,BinTools *bt,
					    const Box* b,Comm *comm)
{
  vector<Bin *> OwnBins,OwnGhostBins,ProcBins;
  vector<Bin *> TranslatedBins,TranslatedAllBins;
  vector<Bin *> GhostBinsDir;

  int loc[3];
  comm->get_myloc(loc);
  int procgrid[3];
  comm->get_procgrid(procgrid);

  // processor region + ghost region
  double X[6];
  X[0] = static_cast<double>(loc[0])/static_cast<double>(procgrid[0]) - binsize[0];
  X[1] = static_cast<double>(loc[0]+1)/static_cast<double>(procgrid[0]) + binsize[0];
  X[2] = static_cast<double>(loc[1])/static_cast<double>(procgrid[1]) - binsize[1];
  X[3] = static_cast<double>(loc[1]+1)/static_cast<double>(procgrid[1]) + binsize[0];
  X[4] = static_cast<double>(loc[2])/static_cast<double>(procgrid[2]) - binsize[2];
  X[5] = static_cast<double>(loc[2]+1)/static_cast<double>(procgrid[2]) + binsize[0];
  ProcBins = ReturnBins(X,b,comm);

  double region[6];
  region[0] = static_cast<double>(loc[0])/static_cast<double>(procgrid[0]);
  region[1] = static_cast<double>(loc[0]+1)/static_cast<double>(procgrid[0]);
  region[2] = static_cast<double>(loc[1])/static_cast<double>(procgrid[1]);
  region[3] = static_cast<double>(loc[1]+1)/static_cast<double>(procgrid[1]);
  region[4] = static_cast<double>(loc[2])/static_cast<double>(procgrid[2]);
  region[5] = static_cast<double>(loc[2]+1)/static_cast<double>(procgrid[2]);
  
  if (dir -2*(dir/2) == 0) 
    region[dir] += binsize[dir/2];      // min  0,2,4
  else
    region[dir] -= binsize[(dir-1)/2];  // max  1,3,5

  // Add ghost region
  region[0] -= binsize[0];
  region[1] += binsize[0];
  region[2] -= binsize[1];
  region[3] += binsize[1];
  region[4] -= binsize[2];
  region[5] += binsize[2];

  TranslatedAllBins = ReturnBins(region,b,comm);
  GhostBinsDir = bt->Subtract(ProcBins,TranslatedAllBins);

  return GhostBinsDir;
}


d821 3
a823 3
  binsize[0] = len[0]/static_cast<double>(ioctbin[0]);
  binsize[1] = len[1]/static_cast<double>(ioctbin[1]);
  binsize[2] = len[2]/static_cast<double>(ioctbin[2]);
@


1.1.6.15.2.9
log
@Link communication scheme with send bins.
@
text
@d935 192
@


1.1.6.15.2.10
log
@Problem with pbc_flags.
Update recent modifications.
@
text
@d155 4
a158 4
  mbin[0] = nbinx + 2*static_cast<int> (binsize[0]/rcutneigh[0]);
  mbin[1] = nbiny + 2*static_cast<int> (binsize[1]/rcutneigh[1]);
  mbin[2] = nbinz + 2*static_cast<int> (binsize[2]/rcutneigh[2]);
  mbins = mbin[0]*mbin[1]*mbin[2];
d162 3
a164 3
      glog.logfile  << "mbin[0] = " << mbin[0] << endl;
      glog.logfile  << "mbin[1] = " << mbin[1] << endl;
      glog.logfile  << "mbin[2] = " << mbin[2] << endl;
d172 1
a172 1
  mbinxhi = mbin[0] - mbinxlo;
d174 1
a174 1
  mbinyhi = mbin[1] - mbinylo;
d176 1
a176 1
  mbinzhi = mbin[2] - mbinzlo;
d190 3
a192 3
  pbin[0] = ioctbin[0]*2;
  pbin[1] = ioctbin[1]*2;
  pbin[2] = ioctbin[2]*2;
d194 1
a194 1
  pbins = pbin[0]*pbin[1]*pbin[2];
d197 3
a199 3
  qbin[0] = pbin[0] + 2;
  qbin[1] = pbin[1] + 2;
  qbin[2] = pbin[2] + 2;
d201 1
a201 1
  qbins = qbin[0]*qbin[1]*qbin[2];
d205 3
a207 3
      glog.logfile  << "pbin[0] = " << pbin[0] << endl;
      glog.logfile  << "pbin[1] = " << pbin[1] << endl;
      glog.logfile  << "pbin[2] = " << pbin[2] << endl;
d212 3
a214 3
      glog.logfile  << "qbin[0] = " << qbin[0] << endl;
      glog.logfile  << "qbin[1] = " << qbin[1] << endl;
      glog.logfile  << "qbin[2] = " << qbin[2] << endl;
d223 3
a225 3
  for (int k=0;k<mbin[2];k++)
    for (int j=0;j<mbin[1];j++)
      for (int i=0;i<mbin[0];i++)
d233 1
a233 1
	      int n =  k*mbin[1]*mbin[0] + j*mbin[0] + i; 
d277 3
a279 3
  for (int k=0;k<mbin[2];k++)
    for (int j=0;j<mbin[1];j++)
      for (int i=0;i<mbin[0];i++)
d286 1
a286 1
	      int n =  k*mbin[1]*mbin[0] + j*mbin[0] + i; 
d369 2
a370 2
  if ( (*ix < 0 || *ix >= mbin[0])|| (*iy < 0 || *iy >= mbin[1]) || 
       (*iz < 0 || *iz >= mbin[2]) ) 
d409 2
a410 2
  if ( (*ix < 0 || *ix >= mbin[0])|| (*iy < 0 || *iy >= mbin[1]) || 
       (*iz < 0 || *iz >= mbin[2]) ) 
d491 3
a493 3
  if ( (ixlo < 0 || ixlo >= mbin[0]) || (ixhi < 0 || ixhi >= mbin[0]) || 
       (iylo < 0 || iylo >= mbin[1]) || (iyhi < 0 || iyhi >= mbin[1]) || 
       (izlo < 0 || izlo >= mbin[2]) || (izhi < 0 || izhi >= mbin[2]) )
d566 3
a568 2
vector<Bin *> BinList::TranslateBins(vector<Bin *>RegionBins,const int dir,
				     const Box* b,Comm *comm,vector <int*> flags)
d570 21
a590 4
  Bin* current_bin;
  int bin[3],L[3];
  vector<Bin *> TranslateBins;
  vector<Bin *>::iterator pb;
d592 7
a598 1
  TranslateBins.resize(0);
d600 8
a607 3
  // number of bins in that proc in that direction
  for (int i = 0; i < 3; i++)  L[i] = 0;
  L[dir] = pbin[dir];
d609 8
a616 3
  cout << "dir =" << dir << "\t L=" << L[dir] << endl;
 
  for (pb = RegionBins.begin();pb!=RegionBins.end();pb++)
d618 2
a619 32
      if (flags[0][0] == 0) // no dim is accross pbc
	{
	  bin[0] = (*pb)->get_binx() + L[0];
	  bin[1] = (*pb)->get_biny() + L[1];
	  bin[2] = (*pb)->get_binz() + L[2];

	  cout << (*pb)->get_binx() << "\t" 
	       << (*pb)->get_biny() << "\t" 
	       << (*pb)->get_binz() << "\n" ;
	}
      else  // one dim is across pbc
      	{
      	  bin[0] = (*pb)->get_binx() + flags[0][1]*L[0];
      	  bin[1] = (*pb)->get_biny() + flags[1][2]*L[1];
      	  bin[2] = (*pb)->get_binz() + flags[2][3]*L[2];	  
      	}
      
      if (bin[0] >= mbin[0] || bin[1] >= mbin[1] || bin[2] >= mbin[2])
	{
	  cout << "bin[0] = " << bin[0] << " >= " << mbin[0] << "\t";
	  cout << "bin[1] = " << bin[1] << " >= " << mbin[1] << "\t";
	  cout << "bin[2] = " << bin[2] << " >= " << mbin[2] << "\n";
	      glog.abort("BinList::TranslateBins:\n"
			 "x,y or z too large");      	      
	}
      
      int m = Map(bin[0],bin[1],bin[2],comm);
      if (m != -1)
	{
	  current_bin = &bins[m];
	  TranslateBins.push_back(current_bin);
	}
d621 2
d624 12
a635 1
  return TranslateBins;
d638 1
d702 1
a702 1
	  int n = qbin[0]*qbin[1]*k + qbin[0]*j + i;
d719 1
a719 1
  vector<Bin *>::iterator pb;
d736 1
a736 1
  for (pb = collect.begin();pb!=collect.end();pb++)
d739 1
a739 1
      (*pb)->get_binregion(fcb);
d744 1
a744 1
	RegionGhostBins.push_back(*pb);
d759 6
a764 6
  if (ix == 0) ixx = mbin[0]-2;
  if (ix == mbin[0]-1) ixx = 1;
  if (iy == 0) iyy = mbin[1]-2;
  if (iy == mbin[1]-1) iyy = 1;
  if (iz == 0) izz = mbin[2]-2;
  if (iz == mbin[2]-1) izz = 1;
d794 2
d847 2
a848 2
  if( (ix == 0) || (ix == qbin[0]-1) || (iy == 0) || (iy == qbin[1]-1) ||
      (iz == 0) || (iz == qbin[2]-1) )
d852 3
a854 3
  rmx = loc[0]*(mbin[0]/procgrid[0] -mbinxlo);
  rmy = loc[1]*(mbin[1]/procgrid[1] -mbinxlo);
  rmz = loc[2]*(mbin[2]/procgrid[2] -mbinzlo);  
d860 1
a860 1
  if ((ilx < 0 || ilx >= qbin[0]) || (ily < 0 || ily >= qbin[1]) || (ilz < 0 || ilz >= qbin[2]) )
d863 1
a863 1
    n = qbin[0]*qbin[1]*ilz + qbin[0]*ily + ilx;
d878 3
a880 3
  int rmx = loc[0]*(mbin[0]/procgrid[0] -mbinxlo);
  int rmy = loc[1]*(mbin[1]/procgrid[1] -mbinylo);
  int rmz = loc[2]*(mbin[2]/procgrid[2] -mbinzlo);  
d886 1
a886 1
  if ((ilx < 0 || ilx >= qbin[0]) || (ily < 0 || ily >= qbin[1]) || (ilz < 0 || ilz >= qbin[2]) )
d889 1
a889 1
    n = qbin[0]*qbin[1]*ilz + qbin[0]*ily + ilx;
@


1.1.6.15.2.11
log
@Correct boundary flags.
Implement send/receive bins.
@
text
@d134 9
a142 6
  for (int i = 0; i < 3; i++) 
    {
      nbin[i] = ioctbin[i]*2*procgrid[i]; 
      if (nbin[i] == 0) nbin[i] = 1;
    }
  nbins = nbin[0]*nbin[1]*nbin[2];
d146 3
a148 3
      glog.logfile << "nbin[0] = " << nbin[0] << endl;
      glog.logfile << "nbin[1] = " << nbin[1] << endl;
      glog.logfile << "nbin[2] = " << nbin[2] << endl;
d155 3
a157 3
  for (int i = 0; i < 3; i++) 
    mbin[i] = nbin[i] + 2*static_cast<int> (binsize[i]/rcutneigh[i]);

d361 1
a361 1
  *ix = static_cast<int>(mbinxlo + X[0]*nbin[0]);
d364 1
a364 1
  *iy = static_cast<int>(mbinylo + X[1]*nbin[1]);
d367 1
a367 1
  *iz = static_cast<int>(mbinzlo + X[2]*nbin[2]);
d389 1
a389 1
    *ix = static_cast<int> ((X[0] - 1.0)*nbin[0]) + nbin[0] + mbinxlo;
d391 1
a391 1
    *ix = static_cast<int> (X[0]*nbin[0]) + mbinxlo;
d393 1
a393 1
    *ix = static_cast<int> (X[0]*nbin[0]) + mbinxlo - 1;
d396 1
a396 1
    *iy = static_cast<int> ((X[1] - 1.0)*nbin[1]) + nbin[1] + mbinylo;
d398 1
a398 1
    *iy = static_cast<int> (X[1]*nbin[1]) + mbinylo;
d400 1
a400 1
    *iy = static_cast<int> (X[1]*nbin[1]) + mbinylo - 1;
d403 1
a403 1
    *iz = static_cast<int> ((X[2] - 1.0)*nbin[2]) + nbin[2] + mbinzlo;
d405 1
a405 1
    *iz = static_cast<int> (X[2]*nbin[2]) + mbinzlo;
d407 1
a407 1
    *iz = static_cast<int> (X[2]*nbin[2]) + mbinzlo - 1;
d449 1
a449 1
    ixlo = static_cast<int> ((Y[0] - 1.0)*nbin[0]) + nbin[0] + mbinxlo;
d451 1
a451 1
    ixlo = static_cast<int> (Y[0]*nbin[0]) + mbinxlo;
d453 1
a453 1
    ixlo = static_cast<int> (Y[0]*nbin[0]) + mbinxlo - 1;
d456 1
a456 1
    ixhi = static_cast<int> ((Y[1] - 1.0)*nbin[0]) + nbin[0] + mbinxlo;
d458 1
a458 1
    ixhi = static_cast<int> (Y[1]*nbin[0]) + mbinxlo;
d460 1
a460 1
    ixhi = static_cast<int> (Y[1]*nbin[0]) + mbinxlo - 1;
d463 1
a463 1
    iylo = static_cast<int> ((Y[2] - 1.0)*nbin[1]) + nbin[1] + mbinylo;
d465 1
a465 1
    iylo = static_cast<int> (Y[2]*nbin[1]) + mbinylo;
d467 1
a467 1
    iylo = static_cast<int> (Y[2]*nbin[1]) + mbinylo - 1;
d470 1
a470 1
    iyhi = static_cast<int> ((Y[3] - 1.0)*nbin[1]) + nbin[1] + mbinylo;
d472 1
a472 1
    iyhi = static_cast<int> (Y[3]*nbin[1]) + mbinylo;
d474 1
a474 1
    iyhi = static_cast<int> (Y[3]*nbin[1]) + mbinylo - 1;
d477 1
a477 1
    izlo = static_cast<int> ((Y[4] - 1.0)*nbin[2]) + nbin[2] + mbinzlo;
d479 1
a479 1
    izlo = static_cast<int> (Y[4]*nbin[2]) + mbinzlo;
d481 1
a481 1
    izlo = static_cast<int> (Y[4]*nbin[2]) + mbinzlo - 1;
d484 1
a484 1
    izhi = static_cast<int> ((Y[5] - 1.0)*nbin[2]) + nbin[2] + mbinzlo;
d486 1
a486 1
    izhi = static_cast<int> (Y[5]*nbin[2]) + mbinzlo;
d488 1
a488 1
    izhi = static_cast<int> (Y[5]*nbin[2]) + mbinzlo - 1;
d576 1
a576 1
  // Length of one proc.
d578 1
a578 1
  L[dir] = pbin[dir]-1;
d580 2
a581 1
  // Translate bins
d584 1
a584 1
      if (flags[0][0] == 0 && flags[1][0] == 0 && flags[2][0] == 0)
d586 16
a601 5
	  bin[0] = (*pb)->get_binx() + L[0];	
	  bin[1] = (*pb)->get_biny() + L[1];	
	  bin[2] = (*pb)->get_binz() + L[2];  
	}
      else
d603 5
a607 23
	  if (flags[0][0] == 0) 
	    bin[0] = (*pb)->get_binx() + L[0];
	  else
	    bin[0] = (*pb)->get_binx() - flags[0][1]*(nbin[0]-pbin[0]-1);
	  
	  if (flags[1][0] == 0)
	    bin[1] = (*pb)->get_biny() + L[1];
	  else
	    bin[1] = (*pb)->get_biny() - flags[1][2]*(nbin[1]-pbin[1]-1);
	  
	  if (flags[2][0] == 0) 
	    bin[2] = (*pb)->get_binz() + L[2];
	  else
	    bin[2] = (*pb)->get_binz() - flags[2][3]*(nbin[2]-pbin[2]-1);	
	}
     
      if (bin[0] >= mbin[0] || bin[1] >= mbin[1] || bin[2] >= mbin[2] ||
	  bin[0] < 0        || bin[1] < 0        || bin[2] < 0)
	{
	  cout << "bin[0] = " << bin[0] << " \t bin[1] = " << bin[1] << " \t";
	  cout << "bin[2] = " << bin[2] << "\n";
	  glog.abort("BinList::TranslateBins:\n"
		     "x,y or z out of bounds");      	      
d617 1
d632 2
a633 2
  int ixlo = static_cast<int>(mbinxlo + X[0]*nbin[0]);
  int ixhi = static_cast<int>(mbinxlo + X[1]*nbin[0]);
d635 2
a636 2
  int iylo = static_cast<int>(mbinylo + X[2]*nbin[1]);
  int iyhi = static_cast<int>(mbinylo + X[3]*nbin[1]);
d638 2
a639 2
  int izlo = static_cast<int>(mbinzlo + X[4]*nbin[2]);
  int izhi = static_cast<int>(mbinzlo + X[5]*nbin[2]);
@


1.1.6.15.2.12
log
@Correct several bugs
@
text
@d123 1
a123 1
  // bin size is close to rcut 
a133 1
  // ioctbin = number of bins per octant.
a217 2
  // mbin is the number of bins. (mbin+1) intervals
  int ip;
d225 1
a242 1

d244 1
a244 1
		  
d333 1
a333 3
      if (m != -1)
	bins[m].set_particles(particles[i]);
	//bins[m].particles.push_back(particles[i]);
d347 1
a347 3
      if (m != -1) 
	bins[m].set_particles(particles[i]);
	//bins[m].particles.push_back(particles[i]);
d563 2
a564 2
vector<Bin *> BinList::TranslateBins(int trans[3],vector<Bin *>RegionBins,const int dir,
				     const Box* b,Comm *comm)
d573 1
a573 1
  // Length of one proc.in bins
d575 1
a575 1
  L[dir] = pbin[dir];
d578 1
a578 2
  
 for (pb = RegionBins.begin();pb!=RegionBins.end();pb++)
d580 32
a611 13
      bin[0] = (*pb)->get_binx() + trans[0]*L[0];	
      bin[1] = (*pb)->get_biny() + trans[1]*L[1];	
      bin[2] = (*pb)->get_binz() + trans[2]*L[2];  
      
      // Treat pbc here
      if (bin[0] >= mbin[0]) bin[0] -= mbin[0];
      if (bin[0] < 0) bin[0] += mbin[0];
      
      if (bin[1] >= mbin[1]) bin[1] -= mbin[1];
      if (bin[1] < 0) bin[1] += mbin[1];
      
      if (bin[2] >= mbin[2]) bin[2] -= mbin[2];
      if (bin[2] < 0) bin[2] += mbin[2];
a666 18
vector<Bin *> BinList::SelectRegionBins(const int X[6], const Box* b, Comm * comm)
{  
  Bin* current_bin;
  vector<Bin* > RegionBins;
  
  for (int k=X[4];k<X[5];k++)
    for (int j=X[2];j<X[3];j++)
      for (int i=X[0];i<X[1];i++)
	{	
	  int n = qbin[0]*qbin[1]*k + qbin[0]*j + i;
	  current_bin = &bins[n];
	  RegionBins.push_back(current_bin);
	}

  return RegionBins;
}


a669 1
  // X inside a given proc.
d687 2
a688 1
	  if (i==Z[0] || i==Z[1] || j==Z[2] || j==Z[3] ||  k==Z[4] || k==Z[5] )
a691 6

	      if (comm->get_Lnodefile()) 
		{
		  // comm->get_nodefile()  << "n=" << n << "\t i=" << i 
		  //		<< "\t j=" << j << "\t k=" << k << endl;
		}
d705 3
d828 5
d835 1
a835 1
  rmy = loc[1]*(mbin[1]/procgrid[1] -mbinylo);
d842 1
a842 2
  if ((ilx < 0 || ilx >= qbin[0]) || (ily < 0 || ily >= qbin[1]) || 
      (ilz < 0 || ilz >= qbin[2]) )
d845 2
a846 6
    {
      n = qbin[0]*qbin[1]*ilz + qbin[0]*ily + ilx;
      if (ilx==0 || ilx==qbin[0]-1 || ily==0 || ily==qbin[1]-1 ||
	  ilz==0 || ilz==qbin[2]-1)
	*ip = 1;
    }
a856 1

@


1.1.6.15.2.13
log
@Correct a few things.
@
text
@d338 1
a338 1
      //bins[m].particles.push_back(particles[i]);
d354 1
a354 1
      //bins[m].particles.push_back(particles[i]);
d532 80
d699 7
a705 1
 	    }
a826 43
vector<Bin *> BinList::TranslateBins(const int id,const int dir,const Box* b,
				     vector<Bin *>RegionBins,Comm *comm)
{ 
  Bin* current_bin;
  int tbin[3];
  vector<Bin *> TranslateBins;
  vector<Bin *>::iterator pb;

  TranslateBins.resize(0);

  int coeff =0;
  if (id == 0) 
    coeff = 1;
  else 
    coeff = -1;

  // Translate bins
  for (pb = RegionBins.begin();pb!=RegionBins.end();pb++)
    {
      tbin[0] = (*pb)->get_binx();
      tbin[1] = (*pb)->get_biny();
      tbin[2] = (*pb)->get_binz();

      tbin[dir] += coeff*pbin[dir];	

      int m = Map(tbin[0],tbin[1],tbin[2],comm);
      if (m != -1)
	{
	  current_bin = &bins[m];
	  TranslateBins.push_back(current_bin);
	}
    }

  if (TranslateBins.size() != RegionBins.size())
    {
      cout << dir << "\t" << RegionBins.size() << "\t" << TranslateBins.size() << endl;
     glog.abort("BinList::TranslateBins:\n"
  	 "Region and translated region not the same size");
   }

  return TranslateBins;
}

d879 1
a879 2
  if ((ilx < 0 || ilx >= qbin[0]) || (ily < 0 || ily >= qbin[1]) || 
      (ilz < 0 || ilz >= qbin[2]) )
a886 26
int BinList::Map(const int m,Comm *comm)
{
  int ix,iy,iz;

  for (int i = 0; i < mbin[0]; i++)
    for (int j = 0; j < mbin[1]; j++)
      for (int k = 0; k < mbin[2]; k++)
	if (m == mbin[1]*mbin[0]*k + mbin[0]*j + i) 
	  { 
	    ix = i; iy = j; iz = k;
	  }
  return Map(ix,iy,iz,comm);
}

void  BinList::GetBins(const int m,int bin[3])
{
  for (int i = 0; i < mbin[0]; i++)
    for (int j = 0; j < mbin[1]; j++)
      for (int k = 0; k < mbin[2]; k++)
	if (m == mbin[1]*mbin[0]*k + mbin[0]*j + i) 
	  { 
	    bin[0] = i; bin[1] = j; bin[2] = k;
	  }
}


a927 142

int BinList::pack_comm_size(Comm* comm,const int& num, const vector<int>& list) 
{
  int ibin,nsend;

  nsend = 0;

  for (int isend=0;isend<num;isend++) 
    {
      // caution : ibin is a global id number
      ibin = list[isend];
      int n = Map(ibin,comm);
      if (n != -1)
	nsend+=1+size_comm*bins[n].particles.size();
     }
  
  return nsend;
}


void BinList::pack_comm(const int& num, const vector<int>& list , double* buf, 
			   const int pbc[], const Box* b, Comm *comm) 
{
  int ibin,ntmp;
  int nsend = 0;
  vector<Particle>::iterator pi;
  for (int isend=0;isend<num;isend++) 
    {
      // ibin is a global id number 
      ibin = list[isend];
      int n = Map(ibin,comm);
      if (n != -1)
	{
	  buf[nsend] = static_cast<double>(bins[n].particles.size());
	  nsend++;
	  ntmp = nsend;
	  for (pi = bins[n].particles.begin();
	       pi != bins[n].particles.end();pi++) 
	    {
	      pi->get_x(&buf[nsend]);
	      nsend+=size_comm;
	    }      
	}
    }
}

void BinList::unpack_comm(const int& num, const vector<int>& list, 
			     const double* buf, Comm *comm) 
{
  int ibin;
  int nrecv=0;
  vector<Particle>::iterator pi;
  for (int irecv=0;irecv<num;irecv++) 
    {
      ibin = list[irecv];
      int n = Map(ibin,comm);
      if (n != -1)
	{
	  bins[n].particles.resize(static_cast<int>(buf[nrecv]));
	  nrecv++;
	  for (pi = bins[n].particles.begin();pi != bins[n].particles.end();pi++) 
	    {
	      pi->set_x(&buf[nrecv]);
	      nrecv+=size_comm;
	    }
	}
    }
}


int BinList::pack_reverse_size(const int& num, const vector<int>& list,Comm *comm) 
{
  
  int ibin,nsend;
  
  nsend = 0;
  for (int isend=0;isend<num;isend++) 
    {
      ibin = list[isend];
      int n = Map(ibin,comm);
      if (n != -1)
	nsend+=1+size_reverse*bins[n].particles.size();
    }
  
  return nsend;
}



void BinList::pack_reverse(const int& num, const vector<int>& list , double* buf, 
		       const int pbc[], const Box* b,Comm *comm) 
{
  int ibin,ntmp;
  int nsend = 0;
  for (int isend=0;isend<num;isend++) 
    {
      ibin = list[isend];
      int n = Map(ibin,comm);
      if (n != -1)
	{
	  buf[nsend] = static_cast<double>(bins[n].particles.size());
	  nsend++;
	  ntmp = nsend;
	  for (vector<Particle>::iterator pi = bins[n].particles.begin();
	       pi != bins[n].particles.end();pi++) 
	    {
	      pi->get_x(&buf[nsend]);
	      nsend+=size_reverse;
	    }
	  
	}
    } 
}

void BinList::unpack_reverse(const int& num, const vector<int>& list , 
				const double* buf, Comm *comm) 
{
  
  int ibin,nrecv;
  vector<Particle>::iterator pi;
  nrecv = 0;
  for (int irecv=0;irecv<num;irecv++) 
    {
      ibin = list[irecv];
      int n = Map(ibin,comm);
      if (n != -1)
	{
	  bins[n].particles.resize(static_cast<int>(buf[nrecv]));
	  nrecv++;
	  for (pi = bins[n].particles.begin();pi != bins[n].particles.end();pi++) 
	    {
	      pi->set_x(&buf[nrecv]);
	      nrecv+=size_reverse;
	    }
	}
    }
}





@


1.1.6.15.2.14
log
@Add a pointer to particle instead of an array of particle.

Bug in particles coordinates.
@
text
@d1 1
a62 1
#include "particlelist_inline.h"
d73 1
a73 1
void BinList::Setup(ParticleList* const p,BinTools *bt, const Box* b, 
d231 1
a231 1
	      // n = global numbering
d261 1
a261 20
  BinParticles(p,p->get_particles(),b,comm);


  vector<Bin >::iterator pbin;
  vector<Particle *>::iterator ppart;
  double x[3];
   for (pbin = bins.begin();pbin!=bins.end();pbin++)
    {
      if (comm->get_Lnodefile()) 
	comm->get_nodefile()<< (*pbin).get_id() << "\t" << (*pbin).get_binx() << "\t" << (*pbin).get_biny() 
			    << "\t" << (*pbin).get_binz() << "\n";
      
      for (ppart = (*pbin).particles.begin();
	   ppart!=(*pbin).particles.end();ppart++)
	{
	  (*ppart)->get_x(x);
	  if (comm->get_Lnodefile()) 
	    comm->get_nodefile()<< x[0] << "\t" << x[1] << "\t" << x[2] << "\n\n";
	}
    }
d307 3
a309 2
void BinList::BinParticles(ParticleList * const p, const Particle * particles,
			   const Box* b, Comm* comm)
a310 3
  int nparticles = p->get_nparticles();
  int nghost_particles = p->get_nghost_particles();

d337 2
a338 1
	bins[m].set_particles(p->get_particle(i));
d353 2
a354 1
	bins[m].set_particles(p->get_particle(i));
d356 1
d619 1
a619 1
	    }
d742 1
a742 1
				     vector<Bin *>RecvBins,Comm *comm)
a756 2
  vector<Particle *>::iterator pp;
  double x[3];
d758 1
a758 1
  for (pb = RecvBins.begin();pb!=RecvBins.end();pb++)
d774 1
a774 29
  // Move particles in RecvBins and Translated bins
  // No pbc here. Done later in pack_com, pack_reverse
  double rshift[3],lva[3],lvb[3],lvc[3];
  double lva2[3],lvb2[3],lvc2[3];
  b->get_lv(lva,lvb,lvc);
  int procgrid[3];
  comm->get_procgrid(procgrid);
  lva2[0] = lva[0]/(procgrid[0]*1.0);
  lva2[1] = lva[1]/(procgrid[1]*1.0);
  lva2[2] = lva[2]/(procgrid[2]*1.0);
  
  lvb2[0] = lvb[0]/(procgrid[0]*1.0);
  lvb2[1] = lvb[1]/(procgrid[1]*1.0);
  lvb2[2] = lvb[2]/(procgrid[2]*1.0);

  lvc2[0] = lvc[0]/(procgrid[0]*1.0);
  lvc2[1] = lvc[1]/(procgrid[1]*1.0);
  lvc2[2] = lvc[2]/(procgrid[2]*1.0);

  rshift[0] = 0.0;
  rshift[1] = 0.0;
  rshift[2] = 0.0;
  if (coeff == 1)
    {
      if (dir == 0) vec3_add(rshift,lva2,rshift);
      if (dir == 1) vec3_add(rshift,lvb2,rshift);
      if (dir == 2) vec3_add(rshift,lvc2,rshift);
    }
  else
d776 1
a776 45
      if (dir == 0) vec3_subtract(rshift,lva2,rshift);
      if (dir == 1) vec3_subtract(rshift,lvb2,rshift);
      if (dir == 2) vec3_subtract(rshift,lvc2,rshift);
    }

  
  vector<Particle *>::iterator ppart;
  for (pb = RecvBins.begin();pb!=RecvBins.end();pb++)
    for (ppart = (*pb)->particles.begin();
	 ppart < (*pb)->particles.end();ppart++)
      {
	(*ppart)->get_x(x);
	vec3_add(x,rshift,x);
	(*ppart)->set_x(x);
      }
  
  rshift[0] = 0.0;
  rshift[1] = 0.0;
  rshift[2] = 0.0;
  if (coeff == 1)
    {
      if (dir == 0) vec3_subtract(rshift,lva2,rshift);
      if (dir == 1) vec3_subtract(rshift,lvb2,rshift);
      if (dir == 2) vec3_subtract(rshift,lvc2,rshift);
    }
  else
    {
      if (dir == 0) vec3_add(rshift,lva2,rshift);
      if (dir == 1) vec3_add(rshift,lvb2,rshift);
      if (dir == 2) vec3_add(rshift,lvc2,rshift);
    }

  /*
  for (pb = TranslateBins.begin();pb!=TranslateBins.end();pb++)
    for (ppart = (*pb)->particles.begin();
	 ppart!=(*pb)->particles.end();ppart++)
      {
	(*ppart)->get_x(x);
	vec3_add(x,rshift,x);
	(*ppart)->set_x(x);
      }
  */
  if (TranslateBins.size() != RecvBins.size())
    {
      cout << dir << "\t" << RecvBins.size() << "\t" << TranslateBins.size() << endl;
d847 1
a847 1
  int ix=mbin[0],iy=mbin[1],iz=mbin[2];
a860 1
  bin[0] = mbin[0]; bin[1] = mbin[1]; bin[2] = mbin[2];
d913 1
a913 5


/* Communication scheme */
int BinList::pack_comm_size(Comm* comm,const int& num, const vector<int>& list,
			    vector <Bin *> SendBins) 
d921 1
d923 4
a926 2
      nsend+=1+size_comm*SendBins[ibin]->get_nparticles();
    }
d932 2
a933 2
void BinList::pack_comm(const int& num, const vector<int>& list ,vector <Bin *> SendBins,
			double* buf,const int pbc[], const Box* b, Comm *comm) 
a935 1
  double rshift[3],lva[3],lvb[3],lvc[3];
d937 1
a937 37
  vector<Particle *>::iterator pi;

  if (pbc[0] == 1) 
    {
      b->get_lv(lva,lvb,lvc);
      rshift[0] = 0.0;
      rshift[1] = 0.0;
      rshift[2] = 0.0;
      
      if (pbc[1]==-1) 
	{
	  vec3_subtract(rshift,lva,rshift);
	}
      else if (pbc[1]==1) 
	{
	  vec3_add(rshift,lva,rshift);
	}
      
      if (pbc[2]==-1) 
	{
	  vec3_subtract(rshift,lvb,rshift);
	} 
      else if (pbc[2]==1) 
	{
	  vec3_add(rshift,lvb,rshift);
	}
      
      if (pbc[3]==-1) 
	{
	  vec3_subtract(rshift,lvc,rshift);
	} 
      else if (pbc[3]==1) 
	{
	  vec3_add(rshift,lvc,rshift);
	}
    }
 
d942 2
a943 10
      buf[nsend] = static_cast<double>(SendBins[ibin]->get_nparticles());
      nsend++;
      ntmp = nsend;
      for (pi = SendBins[ibin]->particles.begin();
	   pi < SendBins[ibin]->particles.end();pi++) 
	{
	  (*pi)->get_x(&buf[nsend]);
	  nsend+=size_comm;
	}      
      if (pbc[0]) 
d945 5
a949 4
	  // Move back the pointer and apply shift
	  nsend=ntmp;
	  for (pi=SendBins[ibin]->particles.begin();
	       pi!=SendBins[ibin]->particles.end();pi++) 
d951 1
a951 2
	      (*pi)->get_x(&buf[nsend]);
	      vec3_add(&buf[nsend],rshift,&buf[nsend]);
d953 1
a953 1
	    }
d958 2
a959 8
void BinList::PrintVec(double x[3],Comm *comm)
{
  if (comm->get_Lnodefile()) 
    comm->get_nodefile()<< x[0] << "\t" << x[1] << "\t" << x[2] << endl;
}

void BinList::unpack_comm(const int& num, const vector<int>& list,
			  vector <Bin *> RecvBins,const double* buf, Comm *comm) 
d963 1
a963 1
  vector<Particle *>::iterator pi;
d967 2
a968 4
      RecvBins[ibin]->particles.resize(static_cast<int>(buf[nrecv]));
      nrecv++;
      for (pi = RecvBins[ibin]->particles.begin();
	   pi < RecvBins[ibin]->particles.end();pi++) 
d970 7
a976 2
	  (*pi)->set_x(&buf[nrecv]);
	  nrecv+=size_comm;
d982 1
a982 2
int BinList::pack_reverse_size(const int& num, const vector<int>& list,
			       vector <Bin *> RecvBins, Comm *comm) 
d991 3
a993 1
      nsend+=1+size_reverse*RecvBins[ibin]->get_nparticles();
d1001 2
a1002 2
void BinList::pack_reverse(const int& num, const vector<int>& list, vector <Bin *> RecvBins,
			   double* buf,const int pbc[], const Box* b,Comm *comm) 
a1004 1
  double rshift[3],lva[3],lvb[3],lvc[3];
a1005 37

  if (pbc[0]==1) 
    {
      b->get_lv(lva,lvb,lvc);
      rshift[0] = 0.0;
      rshift[1] = 0.0;
      rshift[2] = 0.0;
      
      if (pbc[1]==1) 
	{
	  vec3_subtract(rshift,lva,rshift);
	} 
      else if (pbc[1]==-1) 
	{
	  vec3_add(rshift,lva,rshift);
	}
      
      if (pbc[2]==1) 
	{
	  vec3_subtract(rshift,lvb,rshift);
	} 
      else if (pbc[2]==-1) 
	{
	  vec3_add(rshift,lvb,rshift);
	}
      
      if (pbc[3]==1) 
	{
	  vec3_subtract(rshift,lvc,rshift);
	} 
      else if (pbc[3]==-1) 
	{
	  vec3_add(rshift,lvc,rshift);
	}
    }

  vector<Particle *>::iterator pi;
d1009 2
a1010 10
      buf[nsend] = static_cast<double>(RecvBins[ibin]->get_nparticles());
      nsend++;
      ntmp = nsend;
      for (pi = RecvBins[ibin]->particles.begin();
	   pi != RecvBins[ibin]->particles.end();pi++) 
	{
	  (*pi)->get_x(&buf[nsend]);
	  nsend+=size_reverse;
	} 
      if (pbc[0]==1) 
d1012 5
a1016 4
	  // Move back the pointer and apply shift
	  nsend=ntmp;
	  for (pi=RecvBins[ibin]->particles.begin();
	       pi!=RecvBins[ibin]->particles.end();pi++) 
d1018 1
a1018 2
	      (*pi)->get_x(&buf[nsend]);
	      vec3_add(&buf[nsend],rshift,&buf[nsend]);
d1021 1
d1023 2
a1024 2
    }
} 
d1026 2
a1027 2
void BinList::unpack_reverse(const int& num, const vector<int>& list, vector <Bin *> SendBins,
			     const double* buf, Comm *comm) 
d1031 1
a1031 1
  vector<Particle *>::iterator pi;
d1036 2
a1037 4
      SendBins[ibin]->particles.resize(static_cast<int>(buf[nrecv]));
      nrecv++;
      for (pi = SendBins[ibin]->particles.begin();
	   pi != SendBins[ibin]->particles.end();pi++) 
d1039 7
a1045 2
	  (*pi)->set_x(&buf[nrecv]);
	  nrecv+=size_reverse;
d1050 4
@


1.1.6.15.2.15
log
@Latest additions to Monte Carlo branch
@
text
@d263 19
d766 2
a767 2
  vector<Particle *>::iterator pp;
  double x[3];
d770 4
a773 2
  if (id == 0) coeff = 1;
  else coeff = -1;
d775 2
d794 4
a797 14
  if (TranslateBins.size() != RecvBins.size())
    {
      cout << dir << "\t" << RecvBins.size() << "\t" << TranslateBins.size() << endl;
     glog.abort("BinList::TranslateBins:\n"
  	 "Region and translated region not the same size");
   }
  return TranslateBins;
}


void BinList::GetShift(double rshift[3],double sshift[3],int coeff,
		       int dir,const Box *b,Comm *comm)
{
  double lva[3],lvb[3],lvc[3];
d801 11
a811 11
  lva[0] /= (procgrid[0]*1.0);
  lva[1] /= (procgrid[1]*1.0);
  lva[2] /= (procgrid[2]*1.0);
  
  lvb[0] /= (procgrid[0]*1.0);
  lvb[1] /= (procgrid[1]*1.0);
  lvb[2] /= (procgrid[2]*1.0);

  lvc[0] /= (procgrid[0]*1.0);
  lvc[1] /= (procgrid[1]*1.0);
  lvc[2] /= (procgrid[2]*1.0);
d818 3
a820 3
      if (dir == 0) vec3_add(rshift,lva,rshift);
      if (dir == 1) vec3_add(rshift,lvb,rshift);
      if (dir == 2) vec3_add(rshift,lvc,rshift);
d824 3
a826 3
      if (dir == 0) vec3_subtract(rshift,lva,rshift);
      if (dir == 1) vec3_subtract(rshift,lvb,rshift);
      if (dir == 2) vec3_subtract(rshift,lvc,rshift);
d829 14
a842 3
  sshift[0] = 0.0;
  sshift[1] = 0.0;
  sshift[2] = 0.0;
d845 3
a847 3
      if (dir == 0) vec3_subtract(sshift,lva,sshift);
      if (dir == 1) vec3_subtract(sshift,lvb,sshift);
      if (dir == 2) vec3_subtract(sshift,lvc,sshift);
d851 23
a873 4
      if (dir == 0) vec3_add(sshift,lva,sshift);
      if (dir == 1) vec3_add(sshift,lvb,sshift);
      if (dir == 2) vec3_add(sshift,lvc,sshift);
    }
a875 1

a1033 5
  if (comm->get_Lnodefile()) 
    {
      comm->get_nodefile() << "Entered BinList::pack_comm" << endl;
    }

d1040 1
a1040 1

d1081 1
a1081 2
	}
           
d1089 1
a1089 2
	      // This line should have no effect
	      //	      (*pi)->get_x(&buf[nsend]);
a1093 1
      
a1106 8

  if (comm->get_Lnodefile()) 
    {
      comm->get_nodefile() << "Entered BinList::unpack_comm" << endl;
    }



d1142 2
a1143 3
void BinList::pack_reverse(const int& num, const vector<int>& list, 
			   vector <Bin *> RecvBins,
			   double* buf, Comm *comm) 
d1145 2
a1146 1
  int ibin;
a1148 36
  if (comm->get_Lnodefile()) 
    {
      comm->get_nodefile() << "Entered BinList::pack_reverse" << endl;
    }

  vector<Particle *>::iterator pi;
  for (int isend=0;isend<num;isend++) 
    {
      ibin = list[isend];
      buf[nsend] = static_cast<double>(RecvBins[ibin]->get_nparticles());
      nsend++;
      for (pi = RecvBins[ibin]->particles.begin();
	   pi != RecvBins[ibin]->particles.end();pi++) 
	{
	  (*pi)->get_x(&buf[nsend]);
	  nsend+=size_reverse;
	} 
      
    }
} 

void BinList::unpack_reverse(const int& num, const vector<int>& list, 
			     vector <Bin *> SendBins,
			     double* buf, const int pbc[], 
			     const Box* b, Comm *comm) 
{
  
  int ibin,nrecv,ntmp;
  vector<Particle *>::iterator pi;
  double rshift[3],lva[3],lvb[3],lvc[3];

  if (comm->get_Lnodefile()) 
    {
      comm->get_nodefile() << "Entered BinList::unpack_reverse" << endl;
    }

d1155 1
a1155 1

d1164 1
d1182 1
d1184 25
d1210 1
d1212 6
a1223 13

      if (pbc[0]==1) 
	{
	  // Save pointer and apply shift
	  ntmp=nrecv;
	  for (pi=SendBins[ibin]->particles.begin();
	       pi!=SendBins[ibin]->particles.end();pi++) 
	    {
	      vec3_add(&buf[nrecv],rshift,&buf[nrecv]);
	      nrecv+=size_reverse;
	    }
	  nrecv=ntmp;
	}
a1229 1

@


1.1.6.15.2.16
log
@Correct a few bugs.
Segmentation fault when domain is not squared.
@
text
@d166 1
a166 1
    } 
d187 1
a187 1
  // local numbering of bins without periodic region
d194 1
a194 2
  // local numbering of bins with periodic region and ghost bins
  // number of bins in a proc.
d457 1
a457 1
  
d465 1
a465 1
  if (Y[2] >= 1.0)
d471 1
a471 1
  
d478 2
a479 2
  
  if (Y[4] >= 1.0)
d485 1
a485 1
  
a492 9
  
  /*if (comm->get_Lnodefile()) 
    {
      comm->get_nodefile()<< ixlo << "\t" << ixhi << endl;
      comm->get_nodefile()<< iylo << "\t" << iyhi << endl;
      comm->get_nodefile()<< izlo << "\t" << izhi << endl;
    }
  */

d704 6
a709 6
  X[0] = static_cast<double>(loc[0]  )/static_cast<double>(procgrid[0]) - binsize[0];
  X[1] = static_cast<double>(loc[0]+1)/static_cast<double>(procgrid[0]) + binsize[0]; 
  X[2] = static_cast<double>(loc[1]  )/static_cast<double>(procgrid[1]) - binsize[1];
  X[3] = static_cast<double>(loc[1]+1)/static_cast<double>(procgrid[1]) + binsize[1];
  X[4] = static_cast<double>(loc[2]  )/static_cast<double>(procgrid[2]) - binsize[2];
  X[5] = static_cast<double>(loc[2]+1)/static_cast<double>(procgrid[2]) + binsize[2];
d713 1
a713 1
  region[0] = static_cast<double>(loc[0]  )/static_cast<double>(procgrid[0]);
d715 1
a715 1
  region[2] = static_cast<double>(loc[1]  )/static_cast<double>(procgrid[1]);
d717 1
a717 1
  region[4] = static_cast<double>(loc[2]  )/static_cast<double>(procgrid[2]);
d720 1
a720 1
  if (dir%2 == 0)
a723 1
    
a733 1

d751 2
a752 4
  if (id == 0) 
    coeff = 1;
  else 
    coeff = -1;
d773 1
a773 2
      cout << "dir=" << dir << "\t" << RecvBins.size() << "\t" 
	   << TranslateBins.size() << endl;
d781 53
d836 3
d845 1
a845 2
  /*
  int rmx,rmy,rmz;
a849 1
  int ilx,ily,ilz;
a852 5
  */

  int ilx = ix-loc[0]*pbin[0];
  int ily = iy-loc[1]*pbin[1];
  int ilz = iz-loc[2]*pbin[2];
d874 1
d878 7
a884 14
  /*int rmx,rmy,rmz;
  rmx = loc[0]*(mbin[0]/procgrid[0] -mbinxlo);
  rmy = loc[1]*(mbin[1]/procgrid[1] -mbinylo);
  rmz = loc[2]*(mbin[2]/procgrid[2] -mbinzlo);  
 
  int ilx,ily,ilz;
  ilx = ix-rmx;
  ily = iy-rmy;
  ilz = iz-rmz;
  */

  int ilx = ix-loc[0]*pbin[0];
  int ily = iy-loc[1]*pbin[1];
  int ilz = iz-loc[2]*pbin[2];
d888 1
a888 1
      n = -1;
d929 1
a929 1
  localbounds[0] = static_cast<double>(loc[0]  )/static_cast<double>(procgrid[0]);
d931 1
a931 1
  localbounds[2] = static_cast<double>(loc[1]  )/static_cast<double>(procgrid[1]);
d933 1
a933 1
  localbounds[4] = static_cast<double>(loc[2]  )/static_cast<double>(procgrid[2]);
d992 5
d1073 8
d1103 1
d1122 6
d1149 1
d1154 5
@


1.1.6.15.2.17
log
@Tweaked Monaco branch
@
text
@d69 2
a70 40
// Nomenclature used in comments
//    simulation box (box): cuboidal or parallelepiped 
//       region in which atoms reside.
//    processor domain (domain): cuboidal or parallelepiped 
//       sub-region of box assigned to each MPI process. 
//    local particles: particles assigned to each MPI process. 
//       They lie inside or close to the processor domain.
//    ghost particles: particles that are copies of local particles 
//       of neighboring processor domains
//    ghost region: the region surrounding each processor 
//       domain populated with ghost particles.
//    periodic region: region surrounding the simulation box 
//       populated with ghost particles

// Binning Design:
// The binning grid is constructed as a congruent subdivision 
// of the octant grid, which is a 2x2x2 subdivision
// of the processor domain. the processor domain grid is itself a 
// congruent subdivision of the simulation box.
// Unlike the processor domains and octants, the binning grid also 
// extends into the periodic region surrounding the simulation box.

// The bin size is defined to be the smallest size which 
// satisfies the above congruence requirement, while also 
// having dimensions greater than or equal to rcut, the 
// largest neighbor cutoff distance. A related 
// requirement is that the octant size be greater than or 
// equal to twice rcut, which is also enforced during
// the set up of the binning. The equality condition is a 
// special case which typically won't occur for simulations
// of real materials. In the case of inequality, Loct > 2*rcut and 
// Lbin > rcut, so that each octant will be divided
// into at least two bins per octant in each direction. 
// In addition, where appropriate, one bin will need to be 
// added on each end to capture the periodic region and the 
// ghost region. In the case of equality, Loct = 2*cut
// and Lbin = rcut. In this case each octant will be divided 
// into exactly two bins.

BinList::BinList() {
d73 7
a79 2
void BinList::Setup(ParticleList* const p, BinTools* bt, const Box* b, 
		    Comm* comm, ForceFieldList* ffl) {
d83 9
a91 7
  if (node == 0) {
    glog.logfile << "\n\n\n";
    glog.logfile << "Entering BinList::Setup()" << endl;
  }
  if (comm->get_Lnodefile()) {
    comm->get_nodefile() << "Entered BinList::Setup" << endl;
  }
a92 4
  // define some common variables
  comm->get_procgrid(procgrid);
  nprocs = procgrid[0]*procgrid[1]*procgrid[2];
  
d96 4
a100 19

  // octant size has to be at least 2*rcut
  // which implies that domain size must be at least 4*rcut
  if (4.0*rcut*procgrid[0] > w[0] || 
      4.0*rcut*procgrid[1] > w[1] || 
      4.0*rcut*procgrid[2] > w[2]) {
    if (comm->get_Lnodefile()) {
      comm->get_nodefile() << "ioctbin[0]=" << ioctbin[0] << "\t";
      comm->get_nodefile() << "ioctbin[1]=" << ioctbin[1] << "\t";
      comm->get_nodefile() << "ioctbin[2]=" << ioctbin[2] << "\n";
    }
    glog.error("BinList::Setup:\n"
	       "Octant dimension less than twice the neighbor cutoff distance");
  }

  // In fractional coordinates, if periodic box dimension is [0,1]^3 and 
  // cut off is rcut = force_cut_off + skin_distance then
  // simulation domain *with* periodic region is [-rcut,1+rcut]^3. 

d105 15
a119 14
  if (node == 0) {
    glog.logfile  << "procgrid[0] = " << procgrid[0] << endl;
    glog.logfile  << "procgrid[1] = " << procgrid[1] << endl;
    glog.logfile  << "procgrid[2] = " << procgrid[2] << endl;
    
    glog.logfile  << "w[0] = " << w[0] << endl;
    glog.logfile  << "w[1] = " << w[1] << endl;
    glog.logfile  << "w[2] = " << w[2] << endl;
    
    glog.logfile  << "rcut = " << rcut << endl;
    glog.logfile  << "rcutneigh[0] = " << rcutneigh[0] << endl;
    glog.logfile  << "rcutneigh[1] = " << rcutneigh[1] << endl;
    glog.logfile  << "rcutneigh[2] = " << rcutneigh[2] << endl;
  }
d121 1
a121 1
  // calculate octant dimensions and bin dimensions, in fractional coordinates
d123 1
d125 6
a130 5
  if (node == 0) {
    glog.logfile << "binsize[0] = " << binsize[0] << endl;
    glog.logfile << "binsize[1] = " << binsize[1] << endl;
    glog.logfile << "binsize[2] = " << binsize[2] << endl;
  }
d132 2
a133 1
  // global numbering of bins *without* periodic region
d135 5
a139 3
  for (int i = 0; i < 3; i++) {
    nbin[i] = ioctbin[i]*2*procgrid[i]; 
  }
d142 9
a150 8
  if (node == 0) {
    glog.logfile << "nbin[0] = " << nbin[0] << endl;
    glog.logfile << "nbin[1] = " << nbin[1] << endl;
    glog.logfile << "nbin[2] = " << nbin[2] << endl;
    glog.logfile << endl;
    glog.logfile << "nbins = " << nbins << endl;
    glog.logfile  << endl;
  }
d152 3
a154 4
  // global numbering of bins *with* periodic region 
  for (int i = 0; i < 3; i++) {
    mbin[i] = nbin[i] + 2;
  }
d158 9
a166 8
  if (node == 0) {
    glog.logfile  << "mbin[0] = " << mbin[0] << endl;
    glog.logfile  << "mbin[1] = " << mbin[1] << endl;
    glog.logfile  << "mbin[2] = " << mbin[2] << endl;
    glog.logfile  << endl;
    glog.logfile  << "mbins = " << mbins << endl;
    glog.logfile << endl;
  } 
d168 7
a174 7
  // Find lowest and highest bounds for bins *without* periodic region
  mbinxlo = 1;
  mbinxhi = mbin[0] - 1;
  mbinylo = 1;
  mbinyhi = mbin[1] - 1;
  mbinzlo = 1;
  mbinzhi = mbin[2] - 1;
d176 2
a177 1
  if (node == 0) {
d187 1
a187 1
  // local numbering of bins *without* ghost region
d194 1
a194 1
  // local numbering of bins *with* ghost region
d202 16
a217 15
  if (node == 0) {
    glog.logfile  << "pbin[0] = " << pbin[0] << endl;
    glog.logfile  << "pbin[1] = " << pbin[1] << endl;
    glog.logfile  << "pbin[2] = " << pbin[2] << endl;
    glog.logfile  << endl;
    glog.logfile  << "pbins = " << pbins << endl;
    glog.logfile  << endl;

    glog.logfile  << "qbin[0] = " << qbin[0] << endl;
    glog.logfile  << "qbin[1] = " << qbin[1] << endl;
    glog.logfile  << "qbin[2] = " << qbin[2] << endl;
    glog.logfile  << endl;
    glog.logfile  << "qbins = " << qbins << endl;
    glog.logfile  << endl;
  }
d222 1
d224 22
a245 14
  for (int k=0;k<mbin[2];k++) {
    for (int j=0;j<mbin[1];j++) {
      for (int i=0;i<mbin[0];i++) {
	// map global bin number to local position on proc.
	int m = CreateMap(i,j,k,&ip,comm);
	if (m != -1) {
	  // n = global numbering
	  int n =  k*mbin[1]*mbin[0] + j*mbin[0] + i; 
	  if (m >  bins.size()-1 || m < 0) {
	    cout <<  "m =" << m << " > bins.size =" << bins.size() 
		 << "in SetUp\n";
	    glog.abort("BinList::Setup:\n"
		       "m outside range of bins");
	  }
d247 12
a258 16
	  bins[m].set_id(n);
	  bins[m].set_binx(i);
	  bins[m].set_biny(j);
	  bins[m].set_binz(k);
	  
	  bins[m].set_ghostbin(ip);
	  
	  double fcb[6];
	  fcb[0] = (i-1)*binsize[0];
	  fcb[1] = i*binsize[0];
	  fcb[2] = (j-1)*binsize[1];
	  fcb[3] = j*binsize[1];
	  fcb[4] = (k-1)*binsize[2];
	  fcb[5] = k*binsize[2];
	  
	  bins[m].set_binregion(fcb);	
d260 1
a260 3
      }
    }
  }
d267 6
a272 5
      for (int iz = mbinzlo; iz < mbinzhi; iz++) {
	int m = Map(ix,iy,iz,comm);
	if (m != -1)
	  bins[m].set_nbrs(SelectNbrBins(ix,iy,iz,comm));
      }
d280 2
a281 1
      for (int i=0;i<mbin[0];i++) {
d284 19
a302 10
	  if (m != -1) {
	    double fcb[6];
	    int n =  k*mbin[1]*mbin[0] + j*mbin[0] + i; 
	    bins[m].get_binregion(fcb);
	    
	    if (nprocs == 1) {
	      cout << "(" << n << "/" << m << ") - \n";  
	      cout << fcb[0] << "\t" << fcb[1] << "\t" << fcb[2] << "\t"
		   << fcb[3] << "\t" << fcb[4] << "\t" << fcb[5] << endl;
	    }
a303 4
	    if (comm->get_Lnodefile()) {
	      comm->get_nodefile() << "(" << n << "/" << m << ") - \n";  
	      comm->get_nodefile() << fcb[0] << "\t" << fcb[1] << "\t" << fcb[2] << "\t"
				   << fcb[3] << "\t" << fcb[4] << "\t" << fcb[5] << endl;
d305 1
a305 3
		  
	  }
      }
d309 2
a310 1
			   const Box* b, Comm* comm) {
d316 5
a320 4
  if (node == 0) {
    glog.logfile << "\n\n\n";
    glog.logfile << "Entering BinList::BinParticles()" << endl;
  }
d328 13
a340 8
  for (int i = 0; i < nparticles; i++) {
    particles[i].get_x(x);
    Coord2Bin(x,b,&ix,&iy,&iz);
    int m = Map(ix,iy,iz,comm);
    if ( (m >= bins.size() || m < 0)&& m != -1) {
      cout << "m=" << m << endl;
      glog.abort("BinList::BinParticles(1):\n"
		 "Bin outside range",comm);
a341 4
    if (m != -1) {
      bins[m].set_particles(p->get_particle(i));
    }
  }
d343 13
a355 8
  for (int i = nparticles; i < nparticles + nghost_particles; i++) {
    particles[i].get_x(x);
    Coord2GhostBin(x,b,&ix,&iy,&iz);
    int m = Map(ix,iy,iz,comm);
    if ( (m >= bins.size() || m < 0) && m != -1) {
      cout << "m=" << m << endl;	
      glog.abort("BinList::BinParticles(2):\n"
		 "Bin outside range",comm);
a356 3
    if (m != -1) 
      bins[m].set_particles(p->get_particle(i));
  }
d360 2
a361 1
void BinList::Coord2Bin(const double x[3],const Box* b,int *ix,int *iy, int *iz) {
d374 9
a382 8
       (*iz < 0 || *iz >= mbin[2]) ) {
    cout << "ix, iy or iy in Coord2Bin out of range " << endl;
    cout << "ix=" << *ix << "\tiy=" << *iy << "\tiz=" << *iz << endl;
    cout << "x[0]=" << x[0] << "\tx[1]=" << x[1] << "\tx[2]=" << x[2] << endl;
    cout << "X[0]=" << X[0] << "\tX[1]=" << X[1] << "\tX[2]=" << X[2] << endl;
    glog.abort("BinList::Coord2Bin:\n"
	       "local particle out of range");
  }    
d385 2
a386 1
void BinList::Coord2GhostBin(const double x[3],const Box* b,int *ix,int *iy, int *iz) {
d391 1
a391 1
  
d399 1
a399 1
  if (X[1] >= 1.0)
d406 1
a406 1
  if (X[2] >= 1.0)
d414 9
a422 8
       (*iz < 0 || *iz >= mbin[2]) ) {
    cout << "ix, iy or iy in Coord2GhostBin out of range " << endl;
    cout << "ix=" << *ix << "\tiy=" << *iy << "\tiz=" << *iz << endl;
    cout << "x[0]=" << x[0] << "\tx[1]=" << x[1] << "\tx[2]=" << x[2] << endl;
    cout << "X[0]=" << X[0] << "\tX[1]=" << X[1] << "\tX[2]=" << X[2] << endl;
    glog.abort("BinList::Coord2GhostBin:\n"
	       "local particle out of range");
  }   
d425 2
a426 1
vector<Bin *> BinList::ReturnBins(const double X[6], const Box* b,Comm* comm) {  
d506 2
a507 1
       (izlo < 0 || izlo >= mbin[2]) || (izhi < 0 || izhi >= mbin[2]) ) {
d521 15
a535 12
      for (int i=ixlo;i<=ixhi;i++) {	  
	int m = Map(i,j,k,comm);
	if (m != -1) {
	  // Adjust bounds
	  current_bin = &bins[m];
	  double fcb[6];
	  current_bin->get_binregion(fcb);
	  
	  if ( (fcb[0] >= X[0] && fcb[1] <= X[1]) &&
	       (fcb[2] >= X[2] && fcb[3] <= X[3]) &&
	       (fcb[4] >= X[4] && fcb[5] <= X[5]) )
	    RegionBins.push_back(current_bin);	  
a536 1
      }
d538 1
a538 1
  return RegionBins;
d541 2
a542 1
vector<Bin *> BinList::SelectRegionBins(const double X[6], const Box* b, Comm * comm) {  
d563 11
a573 9
      for (int i=ixlo;i<=ixhi;i++) {	  
	int m = Map(i,j,k,comm);
	if (m != -1) {
	  current_bin = &bins[m];
	  
	  // Adjust bounds
	  current_bin = &bins[m];
	  double fcb[6];
	  current_bin->get_binregion(fcb);
d575 5
a579 4
	  if ( (fcb[0] >= X[0] && fcb[1] <= X[1]) &&
	       (fcb[2] >= X[2] && fcb[3] <= X[3]) &&
	       (fcb[4] >= X[4] && fcb[5] <= X[5]) )
	    RegionBins.push_back(current_bin);	  
a580 1
      }
d585 2
a586 1
vector<Bin *> BinList::SelectRegionBins(const int X[6], const Box* b, Comm * comm) {  
d592 6
a597 5
      for (int i=X[0];i<X[1];i++) {	
	int n = qbin[0]*qbin[1]*k + qbin[0]*j + i;
	current_bin = &bins[n];
	RegionBins.push_back(current_bin);
      }
d604 2
a605 1
vector<Bin *> BinList::SelectGhostRegionBins(const int X[6], const Box* b, Comm * comm) {  
d621 8
a628 5
      for (int i=Z[0];i<=Z[1];i++) {	
	int n = qbin[0]*qbin[1]*k + qbin[0]*j + i;
	if (i==Z[0] || i==Z[1] || j==Z[2] || j==Z[3] ||  k==Z[4] || k==Z[5] ) {
	  current_bin = &bins[n];
	  RegionGhostBins.push_back(current_bin);
a629 1
      }
d634 2
a635 1
vector<Bin *> BinList::SelectGhostRegionBins(const double X[6], const Box* b, Comm * comm) {  
d653 7
a659 6
  for (pb = collect.begin();pb!=collect.end();pb++) {
    double fcb[6];
    (*pb)->get_binregion(fcb);
    if ( (fcb[0] < X[0] || fcb[1] > X[1]) ||
	 (fcb[2] < X[2] || fcb[3] > X[3]) ||
	 (fcb[4] < X[4] || fcb[5] > X[5]) )
d661 2
a662 2
      RegionGhostBins.push_back(*pb);
  }
d667 2
a668 1
vector<Bin *> BinList::SelectNbrBins (const int ix,const int iy, const int iz, Comm * comm) {
d685 11
a695 7
      for (int i=ixx-1;i<=ixx+1;i++) {
	if (k != izz || j != iyy || i != ixx) {
	  int m = Map(i,j,k,comm);
	  if (m != -1) {
	    current_bin = &bins[m];
	    NeighborBins.push_back(current_bin);	  
	  }
a696 1
      }
d703 2
a704 1
					    const Box* b,Comm *comm) {
d753 2
a754 1
				     vector<Bin *>RecvBins,Comm *comm) { 
d769 2
a770 1
  for (pb = RecvBins.begin();pb!=RecvBins.end();pb++) {
d778 2
a779 1
      if (m != -1) {
d785 2
a786 1
  if (TranslateBins.size() != RecvBins.size()) {
d796 2
a797 1
int BinList::CreateMap(const int ix,const int iy,const int iz,int *ip,Comm *comm) {
d804 12
d823 7
a829 6
  else {
    n = qbin[0]*qbin[1]*ilz + qbin[0]*ily + ilx;
    if (ilx==0 || ilx==qbin[0]-1 || ily==0 || ily==qbin[1]-1 ||
	ilz==0 || ilz==qbin[2]-1)
      *ip = 1;
  }
d834 5
a838 2
int BinList::Map(const int ix,const int iy,const int iz,Comm *comm) {
  int n;
d843 11
d867 14
d893 3
a895 3
// This function sets up the octant dimensions and bin dimensions
//
void BinList::BinSize(Comm* comm) {
d911 4
a914 4
  // size of an octant - no ghost region -  same for all processes
  len[0] = 0.5/procgrid[0];
  len[1] = 0.5/procgrid[1];
  len[2] = 0.5/procgrid[2];
d922 7
a928 7
  // which implies that there must be at leat 2 bins per octant.
  // This condition also gets checked earlier.
  if (ioctbin[0] < 2 || ioctbin[1] < 2 || ioctbin[2] < 2) {
    if (comm->get_Lnodefile()) {
      comm->get_nodefile() << "ioctbin[0]=" << ioctbin[0] << "\t";
      comm->get_nodefile() << "ioctbin[1]=" << ioctbin[1] << "\t";
      comm->get_nodefile() << "ioctbin[2]=" << ioctbin[2] << "\n";
a929 3
    glog.error("BinList::BinSize:\n"
	       "Less than two bins per octant.");      
  }
d940 2
a941 1
			    vector <Bin *> SendBins) {
d946 5
a950 4
  for (int isend=0;isend<num;isend++) {
    ibin = list[isend];
    nsend+=1+size_comm*SendBins[ibin]->get_nparticles();
  }
d957 2
a958 1
			double* buf,const int pbc[], const Box* b, Comm *comm) {
d964 24
a987 12
  if (pbc[0] == 1) {
    b->get_lv(lva,lvb,lvc);
    rshift[0] = 0.0;
    rshift[1] = 0.0;
    rshift[2] = 0.0;
    
    if (pbc[1]==-1) {
      vec3_subtract(rshift,lva,rshift);
    }
    else if (pbc[1]==1) {
      vec3_add(rshift,lva,rshift);
    }
d989 8
a996 5
    if (pbc[2]==-1) {
      vec3_subtract(rshift,lvb,rshift);
    } 
    else if (pbc[2]==1) {
      vec3_add(rshift,lvb,rshift);
a997 8
    
    if (pbc[3]==-1) {
      vec3_subtract(rshift,lvc,rshift);
    } 
    else if (pbc[3]==1) {
      vec3_add(rshift,lvc,rshift);
    }
  }
d999 13
a1011 11
  for (int isend=0;isend<num;isend++) {
    // ibin is a global id number 
    ibin = list[isend];
    buf[nsend] = static_cast<double>(SendBins[ibin]->get_nparticles());
    nsend++;
    ntmp = nsend;
    for (pi = SendBins[ibin]->particles.begin();
	 pi < SendBins[ibin]->particles.end();pi++) {
      (*pi)->get_x(&buf[nsend]);
      nsend+=size_comm;
    }
d1013 14
a1026 10
    if (pbc[0]) {
      // Move back the pointer and apply shift
      nsend=ntmp;
      for (pi=SendBins[ibin]->particles.begin();
	   pi!=SendBins[ibin]->particles.end();pi++) {
	// This line should have no effect
	//	      (*pi)->get_x(&buf[nsend]);
	vec3_add(&buf[nsend],rshift,&buf[nsend]);
	nsend+=size_comm;
      }
a1027 2
    
  }
d1030 2
a1031 1
void BinList::PrintVec(double x[3],Comm *comm) {
d1037 2
a1038 1
			  vector <Bin *> RecvBins,const double* buf, Comm *comm)  {
d1042 11
a1052 8
  for (int irecv=0;irecv<num;irecv++) {
    ibin = list[irecv];
    RecvBins[ibin]->particles.resize(static_cast<int>(buf[nrecv]));
    nrecv++;
    for (pi = RecvBins[ibin]->particles.begin();
	 pi < RecvBins[ibin]->particles.end();pi++) {
      (*pi)->set_x(&buf[nrecv]);
      nrecv+=size_comm;
a1053 1
  }
d1058 2
a1059 1
			       vector <Bin *> RecvBins, Comm *comm) {
d1063 5
a1067 4
  for (int isend=0;isend<num;isend++) {
    ibin = list[isend];
    nsend+=1+size_reverse*RecvBins[ibin]->get_nparticles();
  }
d1076 2
a1077 1
			   double* buf, Comm *comm) {
d1081 13
a1093 11
  for (int isend=0;isend<num;isend++) {
    ibin = list[isend];
    buf[nsend] = static_cast<double>(RecvBins[ibin]->get_nparticles());
    nsend++;
    for (pi = RecvBins[ibin]->particles.begin();
	 pi != RecvBins[ibin]->particles.end();pi++) {
      (*pi)->get_x(&buf[nsend]);
      nsend+=size_reverse;
    } 
    
  }
d1099 2
a1100 1
			     const Box* b, Comm *comm) {
d1105 23
a1127 16
  if (pbc[0]==1) {
    b->get_lv(lva,lvb,lvc);
    rshift[0] = 0.0;
    rshift[1] = 0.0;
    rshift[2] = 0.0;
    
    if (pbc[1]==1) {
      vec3_subtract(rshift,lva,rshift);
    } else if (pbc[1]==-1) {
      vec3_add(rshift,lva,rshift);
    }
    if (pbc[2]==1) {
      vec3_subtract(rshift,lvb,rshift);
    } else if (pbc[2]==-1) {
      vec3_add(rshift,lvb,rshift);
    }
d1129 9
a1137 4
    if (pbc[3]==1) {
      vec3_subtract(rshift,lvc,rshift);
    } else if (pbc[3]==-1) {
      vec3_add(rshift,lvc,rshift);
d1140 25
a1164 1
  }
a1165 23
  nrecv = 0;
  for (int irecv=0;irecv<num;irecv++) {
    ibin = list[irecv];
    SendBins[ibin]->particles.resize(static_cast<int>(buf[nrecv]));
    nrecv++;

    if (pbc[0]==1) {
      // Save pointer and apply shift
      ntmp=nrecv;
      for (pi=SendBins[ibin]->particles.begin();
	   pi!=SendBins[ibin]->particles.end();pi++) {
	vec3_add(&buf[nrecv],rshift,&buf[nrecv]);
	nrecv+=size_reverse;
      }
      nrecv=ntmp;
    }
    for (pi = SendBins[ibin]->particles.begin();
	 pi != SendBins[ibin]->particles.end();pi++) {
      if (comm->get_Lnodefile()) {
	comm->get_nodefile()<< (*pi) << endl;
      }
      (*pi)->set_x(&buf[nrecv]);
      nrecv+=size_reverse;
a1166 2

  }
@


1.1.6.15.2.18
log
@Bin Communication fixed
@
text
@d213 1
a213 1
  mbinxhi = mbin[0] - 2;
d215 1
a215 1
  mbinyhi = mbin[1] - 2;
d217 1
a217 1
  mbinzhi = mbin[2] - 2;
a297 1

d303 3
a305 3
  for (int ix = mbinxlo; ix <= mbinxhi; ix++) 
    for (int iy = mbinylo; iy <= mbinyhi; iy++) 
      for (int iz = mbinzlo; iz <= mbinzhi; iz++) {
a309 3

  //  PrintBins(b, p, comm);

d313 4
a316 4
void BinList::PrintBins(const Box* b, const ParticleList* p, Comm* comm) const {
  double tmp[3];
  for (int k=0;k<mbin[2];k++) {
    for (int j=0;j<mbin[1];j++) {
d318 6
a323 5
	int m = Map(i,j,k,comm);
	if (m != -1) {
	  double fcb[6];
	  int n =  k*mbin[1]*mbin[0] + j*mbin[0] + i; 
	  bins[m].get_binregion(fcb);
d325 10
a334 14
	  if (comm->get_Lnodefile()) {
	    comm->get_nodefile() << "(" << n << "/" << m << ") - \n";  
	    comm->get_nodefile() << fcb[0] << "\t" << fcb[1] << "\t" << fcb[2] << "\t"
				 << fcb[3] << "\t" << fcb[4] << "\t" << fcb[5] << endl;
	    for (vector<int>::iterator pi = bins[m].particles.begin();
		 pi < bins[m].particles.end();pi++) {
	      const Particle* pp = p->get_particle_readonly(*pi);
	      pp->get_x(tmp);
	      comm->get_nodefile() << tmp[0] << " " <<
		tmp[1] << " " <<
		tmp[2] << " " <<
		pp->get_charge() << " " <<
		pp->get_type() << " " <<
		pp->get_tag() << " " << pp << endl;
d336 1
a337 1
	}
a338 2
    }
  }
a340 2
// This function assignes local particles to bins.
// It does not assign ghost particles; this happens in communication.
d369 1
a369 1
      bins[m].set_particles(i);
d373 12
d449 2
d452 1
a452 8
vector<Bin *> BinList::ReturnBinsLocal(
				  const int& ixlo, const int& ixhi, 
				  const int& iylo, const int& iyhi, 
				  const int& izlo, const int& izhi, 
				  const Box* b,Comm* comm) {  
  // return a list of bin pointers that intersect a 3D region
  // The region is defined by upper and lower local bin coordinates

d455 2
d459 79
a537 4
  if ( (ixlo < 0 || ixlo >= qbin[0]) || (ixhi < 0 || ixhi >= qbin[0]) || 
       (iylo < 0 || iylo >= qbin[1]) || (iyhi < 0 || iyhi >= qbin[1]) || 
       (izlo < 0 || izlo >= qbin[2]) || (izhi < 0 || izhi >= qbin[2]) ) {
    glog.abort("BinList::ReturnBinsLocal:\n"
a540 4
  if(ixhi<ixlo) {return RegionBins;};
  if(iyhi<iylo) {return RegionBins;};
  if(izhi<izlo) {return RegionBins;};

d544 12
a555 3
	int m = qbin[0]*qbin[1]*k + qbin[0]*j + i;
	current_bin = &bins[m];
	RegionBins.push_back(current_bin);	  
d618 1
d646 31
d707 1
d717 35
a751 23
  switch(dir) {
  case 0:
    GhostBinsDir = ReturnBinsLocal(0,0,0,qbin[1]-1,0,qbin[2]-1,b,comm);
    break;
  case 1:
    GhostBinsDir = ReturnBinsLocal(qbin[0]-1,qbin[0]-1,0,qbin[1]-1,0,qbin[2]-1,b,comm);
    break;
  case 2:
    GhostBinsDir = ReturnBinsLocal(0,qbin[0]-1,0,0,0,qbin[2]-1,b,comm);
    break;
  case 3:
    GhostBinsDir = ReturnBinsLocal(0,qbin[0]-1,qbin[1]-1,qbin[1]-1,0,qbin[2]-1,b,comm);
    break;
  case 4:
    GhostBinsDir = ReturnBinsLocal(0,qbin[0]-1,0,qbin[1]-1,0,0,b,comm);
    break;
  case 5:
    GhostBinsDir = ReturnBinsLocal(0,qbin[0]-1,0,qbin[1]-1,qbin[2]-1,qbin[2]-1,b,comm);
    break;
  default:
    glog.abort("BinList::ReturnBinsLocal:\n"
	       "dir outside range");    
  }
d821 1
a821 1
int BinList::Map(const int ix,const int iy,const int iz,Comm *comm) const {
d903 1
a903 2
  int ibin;
  int m;
d905 1
a905 1
  m = 0;
d909 1
a909 1
    m+=head_comm+size_comm*SendBins[ibin]->get_nparticles();
d912 1
a912 1
  return m;
d915 2
a916 1
void BinList::pack_comm(const ParticleList* p, const int& num, const vector<int>& list ,vector <Bin *> SendBins,
d918 1
a918 1
  int ibin;
d920 2
a921 8
  int m,mtmp;
  vector<int>::iterator pi;
  double regiontmp[6];

  if (comm->get_Lnodefile()) {
    comm->get_nodefile()<< "Entering BinList::pack_comm()" <<
      "\nNumber of bins  = " << num << endl;
  }
a950 1
  m = 0;
d954 3
a956 15

    SendBins[ibin]->get_binregion(regiontmp);
    if (comm->get_Lnodefile()) {
      comm->get_nodefile()<< "Particle count " << SendBins[ibin]->particles.size()
			  << "Particle count2 " << SendBins[ibin]->get_nparticles()
			  << "\nLocal Region " << regiontmp[0] << " " << regiontmp[1] << " " << regiontmp[2] 
			  << " " << regiontmp[3] << " " << regiontmp[4] << " " << regiontmp[5] 
			  << endl;
    }

    buf[m] = static_cast<double>(SendBins[ibin]->get_nparticles());

    m+=head_comm;
    mtmp = m;
    
d959 2
a960 18
      const Particle* pp = p->get_particle_readonly(*pi);
      pp->get_x(&buf[m]);
      m+=3;
      buf[m] = pp->get_charge();
      m++;
      buf[m] = nint(pp->get_type());
      m++;
      buf[m] = nint(pp->get_tag());
      m++;
      
      if (comm->get_Lnodefile()) {
	comm->get_nodefile() << buf[m-6] << " " <<
	  buf[m-5] << " " <<
	  buf[m-4] << " " <<
	  buf[m-3] << " " <<
	  buf[m-2] << " " <<
	  buf[m-1] << " " << *pi << endl;
      }
d965 1
a965 1
      m = mtmp;
d969 3
a971 2
	vec3_add(&buf[m],rshift,&buf[m]);
	m+=size_comm;
d983 1
a983 1
void BinList::unpack_comm(ParticleList* p, const int& num, const vector<int>& list,
d986 2
a987 13
  int m;
  int type_in,tag_in;
  double charge_in;
  const double* x_in;
  vector<int>::iterator pi;
  double regiontmp[6];

  if (comm->get_Lnodefile()) {
    comm->get_nodefile()<< "Entering BinList::unpack_comm()" <<
      "\nNumber of bins  = " << num << endl;
  }

  m = 0;
d990 2
a991 11
    RecvBins[ibin]->get_binregion(regiontmp);
    if (comm->get_Lnodefile()) {
      comm->get_nodefile()<< "Old particle count " << RecvBins[ibin]->particles.size()
			  << "\nNew particle count " << nint(buf[m]) 
			  << "\nGhost Region " << regiontmp[0] << " " << regiontmp[1] << " " << regiontmp[2] 
			  << " " << regiontmp[3] << " " << regiontmp[4] << " " << regiontmp[5] << endl;
    }
    // Clear particle pointer list, before creating new list
    RecvBins[ibin]->particles.clear();
    RecvBins[ibin]->particles.resize(nint(buf[m]));
    m+=head_comm;
d994 2
a995 18
      x_in = &buf[m];
      m+=3;
      charge_in = buf[m];
      m++;
      type_in = nint(buf[m]);
      m++;
      tag_in = nint(buf[m]);
      m++;
      // Create ghost particle and assign address to particle pointer list
      *pi = p->AddGhostParticle(type_in, tag_in, x_in, charge_in);
      if (comm->get_Lnodefile()) {
	comm->get_nodefile() << buf[m-6] << " " <<
	  buf[m-5] << " " <<
	  buf[m-4] << " " <<
	  buf[m-3] << " " <<
	  buf[m-2] << " " <<
	  buf[m-1] << " " << *pi << endl;
      }
d1004 2
a1005 2
  int ibin,m;
  m = 0;
d1008 1
a1008 1
    m+=head_reverse+size_reverse*RecvBins[ibin]->get_nparticles();
d1011 1
a1011 1
  return m;
d1016 1
a1016 1
void BinList::pack_reverse(const ParticleList* p, const int& num, const vector<int>& list, 
d1020 2
a1021 9
  int m;
  vector<int>::iterator pi;

  if (comm->get_Lnodefile()) {
    comm->get_nodefile()<< "Entering BinList::pack_reverse()" <<
      "\nNumber of bins  = " << num << endl;
  }

  m = 0;
d1024 2
a1025 11
    buf[m] =  static_cast<double>(RecvBins[ibin]->get_nparticles());
    RecvBins[ibin]->get_binregion(&buf[m+1]);

    if (comm->get_Lnodefile()) {
      comm->get_nodefile()<< "Particle count " << RecvBins[ibin]->get_nparticles()
			  << "\nGhost Region " << buf[m+1] << " " << buf[m+2] << " " << buf[m+3] 
			  << " " << buf[m+4] << " " << buf[m+5] << " " << buf[m+6] 
			  << endl;
    }

    m+=head_reverse;
d1028 2
a1029 8
      const Particle* pp = p->get_particle_readonly(*pi);
      pp->get_x(&buf[m]);
      m+=3;
      if (comm->get_Lnodefile()) {
	comm->get_nodefile() << buf[m-3] << " " <<
	  buf[m-2] << " " <<
	  buf[m-1] << " " << *pi << endl;
      }
d1035 1
a1035 1
void BinList::unpack_reverse(ParticleList* p, const int& num, const vector<int>& list, 
d1039 2
a1040 3
  int ibin,m,mtmp;
  vector<int>::iterator pi;
  Particle * pp;
a1041 12
  double regiontmp[6];

  // Note: This function assumes that particles packed into buffer exactly match
  // those in the receiving particle list. This is true, because the
  // particles originated in that list.
  // We can expect that for more complicated moves, this will be violated.


  if (comm->get_Lnodefile()) {
    comm->get_nodefile()<< "Entering BinList::unpack_reverse()" <<
      "\nNumber of bins  = " << num << endl;
  }
d1068 1
a1068 1
  m = 0;
d1071 2
a1072 16
    SendBins[ibin]->get_binregion(regiontmp);
    if (comm->get_Lnodefile()) {
      comm->get_nodefile()<< "Old particle count " << SendBins[ibin]->particles.size()
			  << "\nNew particle count " << nint(buf[m]) 
			  << "\nLocal Region " << regiontmp[0] << " " << regiontmp[1] << " " << regiontmp[2] 
			  << " " << regiontmp[3] << " " << regiontmp[4] << " " << regiontmp[5] 
			  << "\nGhost Region " << buf[m+1] << " " << buf[m+2] << " " << buf[m+3] 
			  << " " << buf[m+4] << " " << buf[m+5] << " " << buf[m+6] 
			  << endl;
    }
    if (SendBins[ibin]->particles.size() != nint(buf[m])) {
      glog.abort("BinList::unpack_reverse:\n"
		 "new particle count does not match old particle count");
    }
    SendBins[ibin]->particles.resize(nint(buf[m]));
    m+=head_reverse;
d1076 1
a1076 1
      mtmp=m;
d1079 2
a1080 2
	vec3_add(&buf[m],rshift,&buf[m]);
	m+=size_reverse;
d1082 1
a1082 1
      m=mtmp;
a1085 3
      Particle* pp = p->get_particle(*pi);
      pp->set_x(&buf[m]);
      m+=size_reverse;
d1087 1
a1087 3
	comm->get_nodefile() << buf[m-3] << " " <<
	  buf[m-2] << " " <<
	  buf[m-1] << " " << *pi << endl;
d1089 2
d1092 1
a1092 1
    
@


1.1.6.15.2.19
log
@Remove a const qualifier that was tripping up some compilers.
@
text
@d317 1
a317 1
void BinList::PrintBins(const Box* b, const ParticleList* p, Comm* comm) {
d483 41
d889 5
@


1.1.6.15.2.20
log
@Added EAM energy change calculation
@
text
@a62 1
#include "random.h"
a108 1
  iseed = 256;
d487 3
a489 3
  for (int k=X[4];k<=X[5];k++)
    for (int j=X[2];j<=X[3];j++)
      for (int i=X[0];i<=X[1];i++) {	
a555 4
// return 6 lists of bin pointers. Each list points to a 2D slab of
// ghost bins that are adjacent to one of the 6 faces of the 
// processor domain.

d734 4
a737 2
/* Data packaging functions */
int BinList::pack_comm_size(const ParticleList* p, const int& num, const vector<int>& list,
d746 1
a746 1
    m+=head_comm+(p->get_size_comm_mc())*(SendBins[ibin]->get_nparticles());
d755 3
a757 1
  int m;
d765 28
d798 1
a799 1
      SendBins[ibin]->get_binregion(regiontmp);
d810 35
a844 4

    p->pack_comm_mc(SendBins[ibin]->get_nparticles(),SendBins[ibin]->particles,
		 &buf[m],pbc,b);
    m+=(p->get_size_comm_mc())*(SendBins[ibin]->get_nparticles());
d852 4
d877 1
a877 1
    for (vector<int>::iterator pi = RecvBins[ibin]->particles.begin();
d879 18
a896 2
      *pi = p->unpack_comm_mc(&buf[m]);
      m+=p->get_size_comm_mc();
d902 3
a904 2
int BinList::pack_reverse_size(const ParticleList* p, const int& num, const vector<int>& list,
			       vector <Bin *> RecvBins) {
d909 1
a909 1
    m+=head_reverse+(p->get_size_reverse_mc())*(RecvBins[ibin]->get_nparticles());
d915 2
d918 2
a919 1
			   vector <Bin *> RecvBins, double* buf, Comm *comm) {
d922 1
d943 12
a954 5

    p->pack_reverse_mc(RecvBins[ibin]->get_nparticles(),RecvBins[ibin]->particles,
		 &buf[m]);
    m+=(p->get_size_reverse_mc())*(RecvBins[ibin]->get_nparticles());

d962 4
a965 1
  int ibin,m;
d979 25
d1024 7
a1030 49
    p->unpack_reverse_mc(SendBins[ibin]->get_nparticles(),SendBins[ibin]->particles,
		 &buf[m],pbc,b);
    m+=(p->get_size_reverse_mc())*(SendBins[ibin]->get_nparticles());

  }
}

void BinList::Cycle(ParticleList* p, vector<Bin*>& list, 
		    ForceFieldList* ff, const Box* b, Comm *comm)  {
  int ibin;
  int m;
  double boost[3];
  Particle* p_pnt;
  double e_remove, e_add, energy, dele;
  double barg,beta;
  bool Laccept;

  energy = 0.0;

  if (comm->get_Lnodefile()) {
    comm->get_nodefile()<< "Entering BinList::Cycle()" <<
      "\nNumber of bins  = " << list.size() << endl;
  }

  for (vector<Bin*>::iterator bpi = list.begin();
       bpi < list.end();bpi++) {
    for (vector<int>::iterator pi = (*bpi)->particles.begin();
	 pi < (*bpi)->particles.end();pi++) {
      p_pnt = p->get_particle(*pi);
      boost[0] = 1.0e-2*(0.5-ranlc(iseed));
      boost[1] = 1.0e-2*(0.5-ranlc(iseed));
      boost[2] = 1.0e-2*(0.5-ranlc(iseed));

      e_remove = ff->ComputeEnergyRemove(*pi, p, b, comm);
      p_pnt->increment_x(boost);
      e_add = ff->ComputeEnergyAdd(*pi, p, b, comm);
      dele = e_add + e_remove; 

      beta = 1.0;
      
      barg = -beta*dele;

      Laccept = false;
      if (barg > 0.0) {
	Laccept = true;
      } else if (barg > -20.0) {
	if (exp(barg) > ranlc(iseed)) {
	  Laccept = true;
	}
d1032 11
a1042 16

      if (Laccept) {
       energy += dele;
      } else {
	e_remove = ff->ComputeEnergyRemove(*pi, p, b, comm);
	p_pnt->decrement_x(boost);
	e_add = ff->ComputeEnergyAdd(*pi, p, b, comm);
	dele += e_add + e_remove; 
	if (fabs(dele) >= 1.0e-7) {
	  if (comm->get_Lnodefile()) {
	    comm->get_nodefile()<< "BinList::Cycle" <<
	      "Energy Change after Rejected Move = " << dele << endl;
	  }
	  glog.error("BinList::Cycle:\n"
		     "Energy Change after rejected move not zero");
	}
d1045 1
d1047 1
a1048 7
  if (comm->get_Lnodefile()) {
    comm->get_nodefile()<< "BinList::Cycle()" <<
      " energy  = " << energy << endl;
  }
  
       
}
@


1.1.6.15.2.21
log
@Added Metropolis acceptance criterion
@
text
@d762 5
d772 9
d797 5
d806 6
d842 5
d853 7
d882 5
d891 9
a899 1

a922 16
  int ntrial,naccept;
  //
  // These are simulation parameters
  // Should be read from input file
  //
  double transmax[3];
  double temp;
  double boltz;

  boltz = 8.6173e-5;
  transmax[0] = 1.0e-2;
  transmax[1] = 1.0e-2;
  transmax[2] = 1.0e-2;
  //  temp = 0.0;
  //  temp = 1.0e38;
  temp = 300.0;
d924 1
a924 1
  beta = 1.0/(temp*boltz);
a925 3
  energy = 0.0;
  ntrial = 0;
  naccept = 0;
d927 2
a928 1
    comm->get_nodefile()<< "\n\n\nEntering BinList::Cycle()\n";
a934 1
      ntrial++;
d936 3
a938 3
      boost[0] = transmax[0]*(0.5-ranlc(iseed));
      boost[1] = transmax[0]*(0.5-ranlc(iseed));
      boost[2] = transmax[0]*(0.5-ranlc(iseed));
d945 2
a959 1
       naccept++;
d978 2
a979 6
    comm->get_nodefile()<< 
      "accumulated energy change = " << energy << 
      "\nntrial = " << ntrial << 
      "\nnaccept = " << naccept << 
      "\nacceptance ratio = " << double(naccept)/double(ntrial) 
			<< "\n\n\n" << endl;
@


1.1.6.15.2.22
log
@Added in bin reallocation in montecarlo.cpp
@
text
@a368 2
  // clear out old particle pointers;
  ClearParticles();
d883 3
a885 5
  // these values should not exceed
  // the skin distance
  transmax[0] = 1.0e-1;
  transmax[1] = 1.0e-1;
  transmax[2] = 1.0e-1;
d888 1
a888 1
  temp = 3000.0;
d905 3
a907 3
      boost[0] = 2.0*transmax[0]*(0.5-ranlc(iseed));
      boost[1] = 2.0*transmax[0]*(0.5-ranlc(iseed));
      boost[2] = 2.0*transmax[0]*(0.5-ranlc(iseed));
d954 1
@


1.1.6.15.2.23
log
@Correct neighboring bins routine.
@
text
@d306 3
a308 3
  for (int ix = 0; ix < mbin[0]; ix++) 
    for (int iy = 0; iy < mbin[1]; iy++) 
      for (int iz = 0; iz < mbin[2]; iz++) {
d314 1
a314 1
  PrintBins(b, p, comm);
d318 2
a319 3
void BinList::PrintBins(const Box* b, const ParticleList* p, Comm* comm) 
{
  /*
d321 24
a344 29
  for (int k=0;k<mbin[2];k++) 
    for (int j=0;j<mbin[1];j++) 
      for (int i=0;i<mbin[0];i++) 
	  {
	    int m = Map(i,j,k,comm);
	    if (m != -1) 
	      {
		double fcb[6];
		int n =  k*mbin[1]*mbin[0] + j*mbin[0] + i; 
		bins[m].get_binregion(fcb);
		
		if (comm->get_Lnodefile()) 
		  {
		    comm->get_nodefile() << "(" << n << "/" << m << ") - \n";  
		    comm->get_nodefile() << fcb[0] << "\t" << fcb[1] << "\t" << fcb[2] << "\t"
					 << fcb[3] << "\t" << fcb[4] << "\t" << fcb[5] << endl;
		    for (vector<int>::iterator pi = bins[m].particles.begin();
			 pi < bins[m].particles.end();pi++) {
		      const Particle* pp = p->get_particle_readonly(*pi);
		      pp->get_x(tmp);
		      comm->get_nodefile() << tmp[0] << " " <<
			tmp[1] << " " <<
			tmp[2] << " " <<
			pp->get_charge() << " " <<
			pp->get_type() << " " <<
			pp->get_tag() << " " << pp << endl;
		    }
		  }
	      }
a345 21
  */

  for (int k=0;k<mbin[2];k++) 
    for (int j=0;j<mbin[1];j++) 
      for (int i=0;i<mbin[0];i++) 
	{
	  int m = Map(i,j,k,comm);
	  int n =  k*mbin[1]*mbin[0] + j*mbin[0] + i;
	  if (m != -1) 
	    {
	      if (comm->get_Lnodefile()) 
		{
		  comm->get_nodefile() << "Size: " << bins[m].get_nbrs().size() << "\t"
				       << "(i=" << i << "\t j=" << j << "\t k=" << k << ")\n";
		  for (int n = 0;n<bins[m].get_nbrs().size();n++)
		    comm->get_nodefile() << bins[m].get_nbrs()[n]->get_binx() << "\t"
					 << bins[m].get_nbrs()[n]->get_biny() << "\t"
					 << bins[m].get_nbrs()[n]->get_binz() << "\n";
		  comm->get_nodefile() << endl;
		}
	    }
d347 3
d530 1
a530 3
vector<Bin *> BinList::SelectNbrBins (const int ix,const int iy, const int iz, 
				      Comm * comm) 
{
a532 4
    
  // Convert to local bin number
  int loc[3];
  comm->get_myloc(loc);
d534 20
a553 25
  int ilx = ix-loc[0]*pbin[0];
  int ily = iy-loc[1]*pbin[1];
  int ilz = iz-loc[2]*pbin[2];

  for (int k=ilz-1;k<=ilz+1;k++)
    for (int j=ily-1;j<=ily+1;j++)
      for (int i=ilx-1;i<=ilx+1;i++) 
	{
	  int ii = i; 
	  int jj = j; 
	  int kk = k;
	  
	  if (i==-1) ii = qbin[0]-1;
	  if (j==-1) jj = qbin[1]-1;
	  if (k==-1) kk = qbin[2]-1;
	  if (i==qbin[0]) ii = 0;
	  if (j==qbin[1]) jj = 0;
	  if (k==qbin[2]) kk = 0;

	  if (kk != ilz || jj != ily || ii != ilx)
	    {
	      int n = qbin[0]*qbin[1]*ii + qbin[0]*jj + kk;
	      current_bin = &bins[n];
	      NeighborBins.push_back(current_bin);	  		
	    }
d555 1
a559 1

@


1.1.6.15.2.24
log
@Remove print statement.
@
text
@d314 1
a314 1
  //PrintBins(b, p, comm);
@


1.1.6.15.2.25
log
@Added bin-based energy calc
@
text
@d306 3
a308 8
  if (comm->get_Lnodefile()) {
    comm->get_nodefile() << "mbin = " << 
      mbin[0] << " " << mbin[1] << " " << mbin[2] << "\n";
  }

  for (int iz = 0; iz < mbin[2]; iz++) {
    for (int iy = 0; iy < mbin[1]; iy++) { 
      for (int ix = 0; ix < mbin[0]; ix++) {
d310 1
a310 1
	if (m != -1) {
a311 11
	  if (comm->get_Lnodefile()) {
	    //	    comm->get_nodefile() << "bin = " << m << " " << (bins[m]).get_id() << 
	    comm->get_nodefile() << "bin = " << m <<  
	      " neighbors = " << (bins[m].get_nbrs()).size();
	    for (int i = 0; i < (bins[m].get_nbrs()).size(); i++) {
	      //	      comm->get_nodefile() << " " << ((bins[m].get_nbrs())[i])->get_id(); 
	      comm->get_nodefile() << " " << int(((bins[m].get_nbrs())[i])-&(bins[0])); 
	    }
	    comm->get_nodefile() << "\n";
	  }
	}
d313 3
a315 3
    }
  }
  
d359 1
d383 6
a553 4
// This function returns a list of pointers to the neighbors of a bin
// The bin is specified using global index.
// Non-existent neighbors are not included.
//
d568 14
a581 11
  // Loop over 27 neighbor bins
  for (int k=ilz-1;k<=ilz+1;k++) {
    for (int j=ily-1;j<=ily+1;j++) {
      for (int i=ilx-1;i<=ilx+1;i++) {
	
	// Ignore non-existent neighbors 
	if (k < 0 || k >= qbin[2] ||
	    j < 0 || j >= qbin[1] ||
	    i < 0 || i >= qbin[0])  continue;
	// Ignore self
	if (k == ilz && j == ily && i == ilx) continue;
d583 9
a591 8
	int n = qbin[0]*qbin[1]*k + qbin[0]*j + i;
	current_bin = &bins[n];
	NeighborBins.push_back(current_bin);	  		
      }
    }
  }

  return NeighborBins;
d642 2
d738 8
d797 1
d903 2
d922 3
a924 3
  transmax[0] = 0.5e-1;
  transmax[1] = 0.5e-1;
  transmax[2] = 0.5e-1;
d948 1
a948 4
      // Brute force
      //      e_remove = ff->ComputeEnergyRemove(*pi, p, b, comm);
      // Bin-based
      e_remove = ff->ComputeEnergyRemove(*pi, *bpi, p, b, comm);
d950 1
a950 2
      //      e_add = ff->ComputeEnergyAdd(*pi, p, b, comm);
      e_add = ff->ComputeEnergyAdd(*pi, *bpi, p, b, comm);
d968 1
a968 2
	// e_remove = ff->ComputeEnergyRemove(*pi, p, b, comm);
	e_remove = ff->ComputeEnergyRemove(*pi, *bpi, p, b, comm);
d970 1
a970 2
	// e_add = ff->ComputeEnergyAdd(*pi, p, b, comm);
	e_add = ff->ComputeEnergyAdd(*pi, *bpi, p, b, comm);
@


1.1.6.15.2.26
log
@Improved performance of MC moves and turned on periodic output
@
text
@a917 3
//   transmax[0] = 0.0;
//   transmax[1] = 0.0;
//   transmax[2] = 0.0;
d923 1
a923 2
  //  temp = 3000.0;
  temp = 300.0;
a943 3
      // Save state of particles
      //      ff->SaveParticles(p, b, comm);
      ff->SaveParticles(*bpi, p, b, comm);
d968 2
a969 1
	// This is the new style save/restore method
d971 11
a981 20
	// Restore state of particles
	// ff->RestoreParticles(p, b, comm);
	ff->RestoreParticles(*bpi, p, b, comm);

// This is the old style reversal of particle move
// 	// e_remove = ff->ComputeEnergyRemove(*pi, p, b, comm);
// 	e_remove = ff->ComputeEnergyRemove(*pi, *bpi, p, b, comm);
// 	p_pnt->decrement_x(boost);
// 	// e_add = ff->ComputeEnergyAdd(*pi, p, b, comm);
// 	e_add = ff->ComputeEnergyAdd(*pi, *bpi, p, b, comm);
// 	dele += e_add + e_remove; 
// 	if (fabs(dele) >= 1.0e-7) {
// 	  if (comm->get_Lnodefile()) {
// 	    comm->get_nodefile()<< "BinList::Cycle" <<
// 	      "Energy Change after Rejected Move = " << dele << endl;
// 	  }
// 	  glog.error("BinList::Cycle:\n"
// 		     "Energy Change after rejected move not zero");
// 	}

@


1.1.6.15.2.27
log
@Added transmutation move (semigrand ensemble)
@
text
@d899 1
a899 1
void BinList::Translate(ParticleList* p, vector<Bin*>& list, 
d935 1
a935 1
    comm->get_nodefile()<< "\n\n\nEntering BinList::Translate()\n";
d990 1
a990 1
// 	    comm->get_nodefile()<< "BinList::Translate" <<
d993 1
a993 1
// 	  glog.error("BinList::Translate:\n"
a1010 134

void BinList::Transmutate(ParticleList* p, vector<Bin*>& list, 
		    ForceFieldList* ff, const Box* b, Comm *comm)  {
  Particle* p_pnt;
  double e_remove, e_add, energy, dele;
  double barg,beta;
  bool Laccept;
  int ntrial,naccept;
  int type_old, type_new;
  //
  // These are simulation parameters
  // Should be read from input file
  //
  enum {ntypesmax= 2};
  double chempot[ntypesmax];
  int np[ntypesmax];
  double temp;
  double boltz;

  boltz = 8.6173e-5;
  chempot[0] = 0.0;
  chempot[1] = 80.0;
  temp = 3000.0;

  beta = 1.0/(temp*boltz);

  energy = 0.0;
  ntrial = 0;
  naccept = 0;
  if (comm->get_Lnodefile()) {
    comm->get_nodefile()<< "\n\n\nEntering BinList::Transmutate()\n";
  }

  for (vector<Bin*>::iterator bpi = list.begin();
       bpi < list.end();bpi++) {

    // First count up the particle of each type
    np[0] = 0;
    np[1] = 0;
    for (vector<int>::iterator pi = (*bpi)->particles.begin();
	 pi < (*bpi)->particles.end();pi++) {
      p_pnt = p->get_particle(*pi);
      type_old = p_pnt->get_type();

      if (type_old != 0 && type_old != 1) {
	if (comm->get_Lnodefile()) {
	  comm->get_nodefile()<< "BinList::Transmutate" <<
	    "Type of particle for transmutation = " <<  type_old << endl;
	}
	glog.abort("BinList::Transmutate:\n"
		   "Invalid particle type for transmutation");
      }

      np[type_old]++;
    }

    if (comm->get_Lnodefile()) {
      comm->get_nodefile()<< 
	"Before sweep over particles " << 
	"\n np[0] = " << np[0] << 
	"\n np[1] = " << np[1] << 
			 endl;
    }

    //  Now try changing type of each particle
    for (vector<int>::iterator pi = (*bpi)->particles.begin();
	 pi < (*bpi)->particles.end();pi++) {
      ntrial++;
      p_pnt = p->get_particle(*pi);

      // Save state of particles
      ff->SaveParticles(*bpi, p, b, comm);
      type_old = p_pnt->get_type();

      e_remove = ff->ComputeEnergyRemove(*pi, *bpi, p, b, comm);

      // Switch particle type; assumes only two types
      type_new = (type_old == 0 ? 1 : 0);
      p_pnt->set_type(type_new);

      e_add = ff->ComputeEnergyAdd(*pi, *bpi, p, b, comm);
      dele = e_add + e_remove; 

      barg = -beta*(dele-(chempot[type_new]-chempot[type_old]));

//       if (comm->get_Lnodefile()) {
// 	comm->get_nodefile()<< 
// 	  "delmu-dele =  " << barg/beta <<  "\n"; 
//       }

      if (barg < -20.0) {
	Laccept = false;
      }	else if (barg > 20.0) {
	Laccept = true;
      } else if (np[type_old]/(np[type_new]+1) * exp(barg) > ranlc(iseed)) {
	Laccept = true;
      } else {
	Laccept = false;
      }

      if (Laccept) {
	np[type_old]--;
	np[type_new]++;
	energy += dele;
	naccept++;
      } else {
	// Restore state of particles
	// ff->RestoreParticles(p, b, comm);
	ff->RestoreParticles(*bpi, p, b, comm);
	p_pnt->set_type(type_old);

      }
    }

    if (comm->get_Lnodefile()) {
      comm->get_nodefile()<< 
	"After sweep over particles " << 
	"\n np[0] = " << np[0] << 
	"\n np[1] = " << np[1] << 
	endl;
    }

  }

  if (comm->get_Lnodefile()) {
    comm->get_nodefile()<< 
      "transmutate accumulated energy change = " << energy << 
      "\ntransmutate ntrial = " << ntrial << 
      "\ntransmutate naccept = " << naccept << 
      "\ntransmutate acceptance ratio = " << double(naccept)/double(ntrial) 
			<< "\n\n\n" << endl;
  }
  
}
@


1.1.4.1
log
@*** empty log message ***
@
text
@a0 741
#include <cmath>
#include <vector>
#include <string>
#include <iostream>
#include <iomanip>
#include <fstream>
using namespace std;
#include "mpi.h"
#include "grasp.h"
#include "particle.h"
#include "vec3.h"
#include "binlist.h"
#include "bin.h"
#include "forcefield.h"
#include "box.h"
#include "box_inline.h"
#include "fixed_object.h"
#include "particlelist.h"
#include "forcefieldlist.h"
#include "machine.h"
#include "comm.h"
#include "log.h"
extern Log glog;

BinList::BinList(){}


void BinList::Setup(const ParticleList* p, const Box* b, Comm* comm, ForceFieldList* ffl)
{
  int node;
  node = comm->get_node();
  int procgrid[3];
  comm->get_procgrid(procgrid);

  int nprocs = procgrid[0]*procgrid[1]*procgrid[2];
  
  if (node == 0) 
    {
      cout << "\n\n\n";
      cout << "Entering BinList::Setup()" << endl;
    }
  if (comm->get_Lnodefile()) 
    {
      comm->get_nodefile() << "Entered BinList::Setup" << endl;
    }

  double w[3];
  b->get_lw(w);

  // In fractional coodinates, if domain dimension is [0,1]^3 and 
  // cut off is rcut =  force_cut_off + skin_distance then
  // ghost domain dimension is [-cut,cut]^3. 
  rcut = ffl->get_rcutneighmaxall();

  double rcutneigh[3];
  rcutneigh[0] = rcut/w[0];
  rcutneigh[1] = rcut/w[1];
  rcutneigh[2] = rcut/w[2];
  
  if (node == 0)
    {
      cout  << "w[0] = " << w[0] << endl;
      cout  << "w[1] = " << w[1] << endl;
      cout  << "w[2] = " << w[2] << endl;

      cout  << "rcut = " << rcut << endl;
      cout  << "rcutneigh[0] = " << rcutneigh[0] << endl;
      cout  << "rcutneigh[1] = " << rcutneigh[1] << endl;
      cout  << "rcutneigh[2] = " << rcutneigh[2] << endl;
    }

  // bin size is 0.5*rcut
  nbinx = static_cast<int> (2.0/rcutneigh[0]);
  nbiny = static_cast<int> (2.0/rcutneigh[1]);
  nbinz = static_cast<int> (2.0/rcutneigh[2]);
  if (nbinx == 0) nbinx = 1;
  if (nbiny == 0) nbiny = 1;
  if (nbinz == 0) nbinz = 1;

  nbins = nbinx*nbiny*nbinz;

  if (node == 0)
    {
      cout  << "nbinx = " << nbinx << endl;
      cout  << "nbiny = " << nbiny << endl;
      cout  << "nbinz = " << nbinz << endl;
      cout << endl;
      cout  << "nbins = " << nbins << endl;
      cout << endl;
    }

  // Global bounds in fractional coordinates
  globalbounds[0] =   - rcutneigh[0] - small;
  globalbounds[1] = 1 + rcutneigh[0] + small;
  globalbounds[2] =   - rcutneigh[1] - small;
  globalbounds[3] = 1 + rcutneigh[1] + small;
  globalbounds[4] =   - rcutneigh[2] - small;
  globalbounds[5] = 1 + rcutneigh[2] + small;

  if (node == 0)
    {
      cout << "globalbounds\n";
      cout << globalbounds[0] << "\t" << globalbounds[1] << "\t";
      cout << globalbounds[2] << "\t" << globalbounds[3] << "\t";
      cout << globalbounds[4] << "\t" << globalbounds[5] << endl;
    }

  mbinx = static_cast<int>(2.0*w[0]*(globalbounds[1]-globalbounds[0])/rcut);
  mbiny = static_cast<int>(2.0*w[1]*(globalbounds[3]-globalbounds[2])/rcut);
  mbinz = static_cast<int>(2.0*w[2]*(globalbounds[5]-globalbounds[4])/rcut);
  mbins = mbinx*mbiny*mbinz;

  if (node == 0)
    {
      cout << "mbinx = " << mbinx << endl;
      cout << "mbiny = " << mbiny << endl;
      cout << "mbinz = " << mbinz << endl;
      cout << endl;
      cout << "mbins = " << mbins << endl;
      cout << endl;
    }
  
  // binsize in fractional coordinates
  binsizex = (globalbounds[1]-globalbounds[0])/static_cast<double>(mbinx);
  binsizey = (globalbounds[1]-globalbounds[0])/static_cast<double>(mbiny);
  binsizez = (globalbounds[1]-globalbounds[0])/static_cast<double>(mbinz);

  if (node == 0)
    {
      cout << "binsizex = " << binsizex << endl;
      cout << "binsizey = " << binsizey << endl;
      cout << "binsizez = " << binsizez << endl;
    }

  // Find lowest and highest bounds for bins in no-ghost region
  int addon[3];
  addon[0] = static_cast<int>(rcut/(binsizex*w[0])+1);
  addon[1] = static_cast<int>(rcut/(binsizex*w[1])+1);
  addon[2] = static_cast<int>(rcut/(binsizex*w[2])+1);

  mbinxlo = addon[0];
  mbinxhi = mbinx - addon[0];
  mbinylo = addon[1];
  mbinyhi = mbiny - addon[1];
  mbinzlo = addon[2];
  mbinzhi = mbinz - addon[2];

  if (node == 0)
    {
      cout  << "mbinxlo = " << mbinxlo << endl;
      cout  << "mbinxhi = " << mbinxhi << endl;
      cout  << "mbinylo = " << mbinylo << endl;
      cout  << "mbinyhi = " << mbinyhi << endl;
      cout  << "mbinzlo = " << mbinzlo << endl;
      cout  << "mbinzhi = " << mbinzhi << endl;
    }

  // Create bins - Fractional coordinates
  map = new int[mbins];
  Bin current_bin;
  int m = 0;
  double fcb[6],fcbc[6];
  for (int k=0;k<mbinz;k++)
    for (int j=0;j<mbiny;j++)
      for (int i=0;i<mbinx;i++)
	{
	  fcb[0] = static_cast<double>(i)/static_cast<double>(mbinx);
	  fcb[1] = static_cast<double>(i)/static_cast<double>(mbinx);
	  fcb[2] = static_cast<double>(j)/static_cast<double>(mbiny);
	  fcb[3] = static_cast<double>(j)/static_cast<double>(mbiny);
	  fcb[4] = static_cast<double>(k)/static_cast<double>(mbinz);
	  fcb[5] = static_cast<double>(k)/static_cast<double>(mbinz);

	  InvGlobalBounds(fcb,fcbc);

	  fcbc[1] += binsizex;
	  fcbc[3] += binsizey;
	  fcbc[5] += binsizez;
	  
	  if (CheckBin(comm,fcb) == 1)
	    {
	      int n =  k*mbiny*mbinx + j*mbinx + i;
	      current_bin.set_id(n);
	      map[n] = m;
	      current_bin.set_binx(i);
	      current_bin.set_biny(j);
	      current_bin.set_binz(k);
	      current_bin.set_binregion(fcbc);
	      bins.push_back(current_bin);
	      m++;
	    }

	  //cout << fcbc[0] << "  " << fcbc[1] << "\t" << fcbc[2] << "  "
	  //     << fcbc[3] << "\t" << fcbc[4] << "  " << fcbc[5] << endl;
	}

  cout << "Node (" << node << ") // size=" << bins.size() 
       << " m =" << m << "\n";

  BinParticles(p->get_nparticles(),p->get_nghost_particles(),p->get_particles(), b, comm);

  // Define neighboring bins  
  Bin checkbin;
  int nbrs[26];
  for (int ix = 0; ix < mbinx; ix++) 
    for (int iy = 0; iy < mbiny; iy++) 
      for (int iz = 0; iz < mbinz; iz++) 
	{
	  int n = mbinx*mbiny*iz + mbinx*iy + ix;

	  for (int k=0; k<26; k++) 
	    nbrs[k] = SelectNbrBins(ix,iy,iz)[k];
	  if (CheckBin2(comm,ix,iy,iz) == 1)
	    bins[map[n]].set_nbrs(nbrs);

	  if (n== 17) 
	    if (CheckBin2(comm,ix,iy,iz) == 1)
	      for (int k=0; k<26; k++) 
		cout << nbrs[k] << endl;
	}
   

  /////////   TESTS   /////////
  double region[6]; // Fractional region only
  region[0] = -0.25; region[1] = 0.25;
  region[2] = -0.25; region[3] = 0.25;
  region[4] = -0.25; region[5] = 0.25;
    
  // Test SelectRegionBins
  {
    vector<Bin *> temp_bins;
      if (node == 0)
	{
	  cout << "\n\nTest SelectRegionBins --- Trial region:\n";
	  cout << region[0] << "\t" << region[1] << "\t" << region[2] << "\t"
		       << region[3] << "\t" << region[4] << "\t" << region[5] << endl;
	}
    
    temp_bins = SelectRegionBins(region,b,comm);
    if (node == 0)
      {
	cout << "Bins check: "<<endl;
	cout << "Number of bins found: "<< temp_bins.size()<<endl;
      }
    vector<Bin *>::iterator pbin;
    for (pbin = temp_bins.begin();pbin!=temp_bins.end();pbin++)
      {
	cout << "Bin " <<(*pbin)->get_id()<<" : ";

	double fcb[6];	
	(*pbin)->get_binregion(fcb);
	cout << fcb[0]<<"\t"<<  fcb[1]<<"\t"<< fcb[2]<<"\t"
	     << fcb[3]<<"\t"<<  fcb[4]<<"\t"<< fcb[5]<<endl;
      }
  }

  // Test GhostSelectRegionBins 
  {
    vector<Bin *> temp_bins;
    if (node == 0)
      {
	cout << "\n\nTest SelectGhostRegionBins --- Trial region:\n";
	cout << region[0] << "\t" << region[1] << "\t" << region[2] << "\t"
		     << region[3] << "\t" << region[4] << "\t" << region[5] << endl;
      }
    
    temp_bins = SelectGhostRegionBins(region,b,comm);
    if (node == 0)
      {
	cout << "Ghost Bins check: "<<endl;
	cout << "Number of ghost bins found: "<< temp_bins.size()<<endl;
      }
    vector<Bin *>::iterator pbin;
    for (pbin = temp_bins.begin();pbin!=temp_bins.end();pbin++)
      {
	cout << "Bin " <<(*pbin)->get_id()<<" : ";

	double fcb[6];	
	(*pbin)->get_binregion(fcb);
	if (node == 0)
	  {
	    cout << fcb[0]<<"\t"<< fcb[1]<<"\t"<<fcb[2]<<"\t"
		 << fcb[3]<<"\t"<< fcb[4]<<"\t"<<fcb[5]<<endl;
	  }
      }
  }
}

/* Bin Particles */
void BinList::BinParticles(
	       const int& nparticles, const int& nghost_particles, 
	       const Particle* particles, const Box* b, Comm* comm)
{
  int node;
  node = comm->get_node();
  if (node == 0) 
    {
      cout << "\n\n\n";
      cout << "Entering BinList::BinParticles()" << endl;
    }
  if (comm->get_Lnodefile()) {
    comm->get_nodefile() << "Entered BinList::BinParticles" << endl;
  }

  // bin particles
  double x[3];
  for (int i = 0; i < nparticles; i++) 
    {
      particles[i].get_x(x);
      int ibin = Coord2BinLocal(x,b);
      if (CheckPoint(b,comm,x) == 1) 
  	  bins[map[ibin]].particles.push_back(particles[i]);
    }
  
  
  // bin ghost particles
  for (int i = nparticles; i < nparticles + nghost_particles; i++) 
    {
      particles[i].get_x(x);
      int ibin = Coord2BinGhost(x,b);
      if (CheckPoint(b,comm,x) == 1) 
	bins[map[ibin]].particles.push_back(particles[i]);
    }
  
}


int BinList::Coord2BinLocal(const double x[], const Box* b)
{
  int ix,iy,iz;
  int ibin;
  double X[3];

  X[0] = b->Fractional(0,x);
  ix = static_cast<int>(mbinxlo + X[0]*nbinx);

  X[1] = b->Fractional(1,x);
  iy = static_cast<int>(mbinylo + X[1]*nbiny);

  X[2] = b->Fractional(2,x);
  iz = static_cast<int>(mbinzlo + X[2]*nbinz);

  ibin = iz*mbiny*mbinx + iy*mbinx + ix;

  if (ibin < 0 || ibin >= mbins) 
    {
      cout << "ibin in Coord2BinLocal out of range " << ibin << endl;
      glog.abort("BinList::Coord2BinLocal:\n"
		 "ibin for local particle out of range");
    }    

  return ibin;
}

int BinList::Coord2BinGhost(const double x[], const Box* b)
{
  int ix,iy,iz;
  int ibin;
  double val[6],valc[6];
  double X[3];

  double w[3];
  b->get_lw(w);

  double raddon[3];
  raddon[0] = 1. + rcut/(binsizex*w[0]);

  X[0] = b->Fractional(0,x);
  X[1] = b->Fractional(1,x);
  X[2] = b->Fractional(2,x);

  if (X[0] > 1.0)
      ix = static_cast<int> ((X[0] - 1.0)*nbinx) + nbinx + mbinxlo;
  else if (X[0] >= 0.0)
    ix = static_cast<int> (X[0]*nbinx) + mbinxlo;
  else
    ix = static_cast<int> (X[0]*nbinx) + mbinxlo - 1;

  if (X[1] > 1.0)
    iy = static_cast<int> ((X[1] - 1.0)*nbiny) + nbiny + mbinylo;
  else if (X[1] >= 0.0)
    iy = static_cast<int> (X[1]*nbiny) + mbinylo;
  else
    iy = static_cast<int> (X[1]*nbiny) +mbinylo - 1;

  if (X[2] > 1.0)
    iz = static_cast<int> ((X[2] - 1.0)*nbinz) + nbinz + mbinzlo;
  else if (X[2] >= 0.0)
    iz = static_cast<int> (X[2]*nbinz) + mbinzlo;
  else
    iz = static_cast<int> (X[2]*nbinz) + mbinzlo -1;

  ibin = iz*mbiny*mbinx + iy*mbinx + ix;

  if (ibin < 0 || ibin >= mbins) 
    {
      cout << x[0] << "\t" << x[1] << "\t" << x[2] << endl;
      cout << "ibin in Coord2BinGhost out of range " << ibin << endl;
      glog.abort("BinList::Coord2BinGhost:\n"
		 "ibin for ghost particle out of range");
    } 
    
  return ibin;
}

vector<Bin *> BinList::SelectRegionBins(double reg[6], const Box* b,Comm* comm)
{  
  // enter a fractional region only.
  int node;
  node = comm->get_node();

  vector<Bin *> RegionBins;
  Bin *current_bin;
 
  double regc[6];
  GlobalBounds(reg,regc);

  int ixlo =  max(static_cast<int> (regc[0]*mbinx),mbinxlo);
  int ixhi =  min(static_cast<int> (regc[1]*mbinx+1),mbinxhi);
  int iylo =  max(static_cast<int> (regc[2]*mbiny),mbinylo);
  int iyhi =  min(static_cast<int> (regc[3]*mbiny+1),mbinyhi);
  int izlo =  max(static_cast<int> (regc[4]*mbinz),mbinzlo);
  int izhi =  min(static_cast<int> (regc[5]*mbinz+1),mbinzhi);

  for (int k=izlo;k<izhi;k++)
    for (int j=iylo;j<iyhi;j++)
      for (int i=ixlo;i<ixhi;i++)
	{
	  int n = mbinx*mbiny*k + mbinx*j + i;
	  if (n < 0 || n >= mbins) 
	    {
	      glog.logfile << "n out of range " << n << endl;
	      glog.abort("BinList::SelectRegionBins:\n"
			 "n out of range");
	    }    

	  if (CheckBin2(comm,i,j,k) == 1)
	    {
	      current_bin = &bins[map[n]];
	      RegionBins.push_back(current_bin);	  
	    }
	}
  
  return RegionBins;
}


vector<Bin *> BinList::SelectGhostRegionBins(double reg[6], const Box* b,Comm * comm)
{  
  // enter a fractional region only
  int node;
  node = comm->get_node();


 vector<Bin *> RegionGhostBins;
  Bin *current_bin;

  double regc[6];
  GlobalBounds(reg,regc);

  int ixlo =  static_cast<int>(regc[0]*mbinx);
  int ixhi =  static_cast<int>(regc[1]*mbinx+1);

  if(ixhi <= mbinxlo || ixlo >= mbinxhi) 
    {} 
  else if (ixlo >=mbinxlo && ixhi <= mbinxhi) 
    return  RegionGhostBins;
  else if (ixlo >= mbinxlo)
      ixlo = mbinxhi;
  else
    ixhi = mbinxlo;

  int iylo =  static_cast<int>(regc[2]*mbiny);
  int iyhi =  static_cast<int>(regc[3]*mbiny+1);

  if(iyhi <= mbinylo || iylo >= mbinyhi) 
    {} 
  else if (iylo >=mbinylo && iyhi <= mbinyhi) 
    return  RegionGhostBins;
  else if (iylo >= mbinylo)
      iylo = mbinyhi;
  else
    iyhi = mbinylo;

  int izlo =  static_cast<int>(regc[4]*mbinz);
  int izhi =  static_cast<int>(regc[5]*mbinz+1);

  if(izhi <= mbinzlo || izlo >= mbinzhi) 
    {} 
  else if (izlo >=mbinzlo && izhi <= mbinzhi) 
    return  RegionGhostBins;
  else if (izlo >= mbinzlo)
      izlo = mbinzhi;
  else
    izhi = mbinzlo;

  for (int k=izlo;k<izhi;k++)
    for (int j=iylo;j<iyhi;j++)
      for (int i=ixlo;i<ixhi;i++)
	{
	  int n = mbinx*mbiny*k + mbinx*j + i;
	  
	  if (n < 0 || n >= mbins) 
	    {
	      glog.logfile << "n out of range " << n << endl;
	      glog.abort("BinList::SelectGhostRegionBins:\n"
			 "n out of range");
	    }    
	  
	  if (CheckBin2(comm,i,j,k) == 1)
	    {
	    current_bin = &bins[map[n]];
	    RegionGhostBins.push_back(current_bin);	  
	  }
	}

  return RegionGhostBins;
}

vector<int > BinList::SelectNbrBins (const int ix,const int iy, const int iz)
{
  vector <int > nbrs;
  nbrs.resize(26);
  int ixx = ix;
  int iyy = iy;
  int izz = iz;

  if (ix == 0) ixx = mbinx-2;
  if (ix == mbinx-1) ixx = 1;
  if (iy == 0) iyy = mbiny-2;
  if (iy == mbiny-1) iyy = 1;
  if (iz == 0) izz = mbinz-2;
  if (iz == mbinz-1) izz = 1;

  int m = 0;
   for (int k=izz-1;k<=izz+1;k++)
    for (int j=iyy-1;j<=iyy+1;j++)
      for (int i=ixx-1;i<=ixx+1;i++)
	{
	  if (k != izz || j != iyy || i != ixx) // not self
	    {
	      int n = k*mbiny*mbinx + j*mbinx + i;
	      nbrs[m] = n;
	      m++;
	    }
	}

   return nbrs;
}

void BinList::GlobalBounds(double r[6],double rc[6])
{
  // coordinates -> fractional coordinates
  rc[0] = (r[0]  - globalbounds[0])/(globalbounds[1]-globalbounds[0]);
  rc[1] = (r[1]  - globalbounds[0])/(globalbounds[1]-globalbounds[0]);
  
  rc[2] = (r[2]  - globalbounds[2])/(globalbounds[3]-globalbounds[2]);
  rc[3] = (r[3]  - globalbounds[2])/(globalbounds[3]-globalbounds[2]);
  
  rc[4] = (r[4]  - globalbounds[4])/(globalbounds[5]-globalbounds[4]);
  rc[5] = (r[5]  - globalbounds[4])/(globalbounds[5]-globalbounds[4]);
}

void BinList::InvGlobalBounds(double r[6],double rc[6])
{
  // fractional coordinates -> coordinates
  rc[0] = globalbounds[0] + r[0]*(globalbounds[1]-globalbounds[0]);
  rc[1] = globalbounds[0] + r[1]*(globalbounds[1]-globalbounds[0]);
  
  rc[2] = globalbounds[2] + r[2]*(globalbounds[3]-globalbounds[2]);
  rc[3] = globalbounds[2] + r[3]*(globalbounds[3]-globalbounds[2]);
  
  rc[4] = globalbounds[4] + r[4]*(globalbounds[5]-globalbounds[4]);
  rc[5] = globalbounds[4] + r[5]*(globalbounds[5]-globalbounds[4]);
}


int BinList::CheckBin(const Comm *comm, double regbin[6])
{
  int loc[3];
  comm->get_myloc(loc);
  int procgrid[3];
  comm->get_procgrid(procgrid);

  double bnds[6],regproc[6];
  bnds[0] = static_cast<double>(loc[0])/static_cast<double>(procgrid[0]);
  bnds[1] = static_cast<double>(loc[0]+1)/static_cast<double>(procgrid[0]);
  bnds[2] = static_cast<double>(loc[1])/static_cast<double>(procgrid[1]);
  bnds[3] = static_cast<double>(loc[1]+1)/static_cast<double>(procgrid[1]);
  bnds[4] = static_cast<double>(loc[2])/static_cast<double>(procgrid[2]);
  bnds[5] = static_cast<double>(loc[2]+1)/static_cast<double>(procgrid[2]);
  InvGlobalBounds(bnds,regproc);

  regproc[0] -= small;
  regproc[1] += small;
  regproc[2] -= small;
  regproc[3] += small;
  regproc[4] -= small;
  regproc[5] += small;

  
  int node;
  node = comm->get_node();

  //cout << "node (" << node << ")--  ";
  //cout << regproc[0] << "\t" << regproc[1] << "\t" << regproc[2] << "\t"
  //     << regproc[3] << "\t" << regproc[4] << "\t" << regproc[5] << endl;


  int ires[3];
  //x
  if(regbin[0]>=regproc[0] && regbin[1] <=regproc[1])
    ires[0] = 1;
  else
    ires[0] = 0;

  //y
  if(regbin[2]>=regproc[2] && regbin[3] <=regproc[3])
    ires[1] = 1;
  else
    ires[1] = 0;

  //z
  if(regbin[4]>=regproc[4] && regbin[5] <=regproc[5])
    ires[2] = 1;
  else
    ires[2] = 0;

  return (ires[0] + ires[1] + ires[2])/3;
}


int BinList::CheckBin2(const Comm *comm,int i,int j,int k)
{
  int loc[3];
  comm->get_myloc(loc);
  int procgrid[3];
  comm->get_procgrid(procgrid);
  double bnds[6],regproc[6];

  bnds[0] = static_cast<double>(loc[0])/static_cast<double>(procgrid[0]);
  bnds[1] = static_cast<double>(loc[0]+1)/static_cast<double>(procgrid[0]);
  bnds[2] = static_cast<double>(loc[1])/static_cast<double>(procgrid[1]);
  bnds[3] = static_cast<double>(loc[1]+1)/static_cast<double>(procgrid[1]);
  bnds[4] = static_cast<double>(loc[2])/static_cast<double>(procgrid[2]);
  bnds[5] = static_cast<double>(loc[2]+1)/static_cast<double>(procgrid[2]);
  InvGlobalBounds(bnds,regproc);

  regproc[0] -= small;
  regproc[1] += small;
  regproc[2] -= small;
  regproc[3] += small;
  regproc[4] -= small;
  regproc[5] += small;


  double bndsc[6];
  bnds[0] =  static_cast<double>(i)/static_cast<double>(mbinx);
  bnds[1] =  static_cast<double>(i)/static_cast<double>(mbinx);
  bnds[2] =  static_cast<double>(j)/static_cast<double>(mbiny);
  bnds[3] =  static_cast<double>(j)/static_cast<double>(mbiny);
  bnds[4] =  static_cast<double>(k)/static_cast<double>(mbinz);
  bnds[5] =  static_cast<double>(k)/static_cast<double>(mbinz);
  InvGlobalBounds(bnds,bndsc);
  bndsc[1] += binsizex;
  bndsc[3] += binsizey;
  bndsc[5] += binsizez;

  int ires[3];
  //x
  if(bndsc[0]>=regproc[0] && bndsc[1] <=regproc[1])
    ires[0] = 1;
  else
    ires[0] = 0;

  //y
  if(bndsc[2]>=regproc[2] && bndsc[3] <=regproc[3])
    ires[1] = 1;
  else
    ires[1] = 0;

  //z
  if(bndsc[4]>=regproc[4] && bndsc[5] <=regproc[5])
    ires[2] = 1;
  else
    ires[2] = 0;

  return (ires[0] + ires[1] + ires[2])/3;
}

int BinList::CheckPoint(const Box *b, const Comm *comm, const double particle[3])
{
  int loc[3];
  comm->get_myloc(loc);

  int procgrid[3];
  comm->get_procgrid(procgrid);

  double bnds[6],regproc[6];
  bnds[0] = static_cast<double>(loc[0])/static_cast<double>(procgrid[0]);
  bnds[1] = static_cast<double>(loc[0]+1)/static_cast<double>(procgrid[0]);
  bnds[2] = static_cast<double>(loc[1])/static_cast<double>(procgrid[1]);
  bnds[3] = static_cast<double>(loc[1]+1)/static_cast<double>(procgrid[1]);
  bnds[4] = static_cast<double>(loc[2])/static_cast<double>(procgrid[2]);
  bnds[5] = static_cast<double>(loc[2]+1)/static_cast<double>(procgrid[2]);
  InvGlobalBounds(bnds,regproc);

  regproc[0] -= small;
  regproc[1] += small;
  regproc[2] -= small;
  regproc[3] += small;
  regproc[4] -= small;
  regproc[5] += small;

  double x[3];
  x[0] = b->Fractional(0,particle);
  x[1] = b->Fractional(1,particle);
  x[2] = b->Fractional(2,particle);

  int ires[3];
  //x  
  if(x[0]>=regproc[0] && x[0] <=regproc[1]) 
    ires[0] = 1;
  else
    ires[0] = 0;

  //y
  if(x[1]>=regproc[2] && x[1] <=regproc[3]) 
    ires[1] = 1;
  else
    ires[1] = 0;

  //z
  if(x[2]>=regproc[4] && x[2] <=regproc[5]) 
    ires[2] = 1;
  else
    ires[2] = 0;

  return (ires[0] + ires[1] + ires[2])/3;
}

@


1.1.2.1
log
@Fusion of ALex and Sylvie's versions.
Implementation of bins.
Add energy change.

saubry (04-06-05)
@
text
@a0 533
#include <cmath>
#include <vector>
#include <string>
#include <iostream>
#include <iomanip>
#include <fstream>
using namespace std;
#include "mpi.h"
#include "grasp.h"
#include "particle.h"
#include "vec3.h"
#include "binlist.h"
#include "bin.h"
#include "forcefield.h"
#include "box.h"
#include "box_inline.h"
#include "fixed_object.h"
#include "particlelist.h"
#include "forcefieldlist.h"
#include "machine.h"
#include "comm.h"
#include "log.h"
extern Log glog;

using namespace std;

BinList::BinList()
{
}


void BinList::Setup(const ParticleList* p, const Box* b, Comm* comm, ForceFieldList* ffl)
{
  int node;
  node = comm->get_node();
  
  if (node == 0) {
    glog.logfile << "\n\n\n";
    glog.logfile << "Entering BinList::Setup()" << endl;
  }
  if (comm->get_Lnodefile()) {
    comm->get_nodefile() << "Entered BinList::Setup" << endl;
  }

  double w[3];
  b->get_lw(w);
  double lva[3],lvb[3],lvc[3];
  b->get_lv(lva,lvb,lvc);
  double origin[3];
  b->get_o(origin);
  int procgrid[3];
  comm->get_procgrid(procgrid);
  int myloc[3];
  comm->get_myloc(myloc);

  // In fractional coodinates, if domain dimension is [0,1]^3 and 
  // cut off is rcut =  force_cut_off + skin_distance then
  // ghost domain dimension is [-cut,cut]^3. 
  double rcut = ffl->get_rcutneighmaxall();

  double bounds[3];
  bounds[0] = rcut/w[0];
  bounds[1] = rcut/w[1];
  bounds[2] = rcut/w[2];
  
  glog.logfile  << "rcut = " << rcut << endl;
  glog.logfile  << "bounds[0] = " << bounds[0] << endl;
  glog.logfile  << "bounds[1] = " << bounds[1] << endl;
  glog.logfile  << "bounds[2] = " << bounds[2] << endl;


  // bin size is 0.5*rcut
  nbinx = static_cast<int> (2.0/bounds[0]);
  nbiny = static_cast<int> (2.0/bounds[1]);
  nbinz = static_cast<int> (2.0/bounds[2]);
  if (nbinx == 0) nbinx = 1;
  if (nbiny == 0) nbiny = 1;
  if (nbinz == 0) nbinz = 1;

  nbins = nbinx*nbiny*nbinz;

  glog.logfile  << "nbinx = " << nbinx << endl;
  glog.logfile  << "nbiny = " << nbiny << endl;
  glog.logfile  << "nbinz = " << nbinz << endl;
  glog.logfile << endl;
  glog.logfile  << "nbins = " << nbins << endl;
  glog.logfile << endl;
  
  // Bounds for bins in local proc, taking ghost region into account.
  ghostbounds[0] = static_cast<double>(myloc[0])/static_cast<double>(procgrid[0])
    - bounds[0] - small;
  ghostbounds[1] = static_cast<double>(myloc[0]+1)/static_cast<double>(procgrid[0])
    + bounds[0] + small;
  ghostbounds[2] = static_cast<double>(myloc[1])/static_cast<double>(procgrid[1])
    - bounds[1] - small;
  ghostbounds[3] = static_cast<double>(myloc[1]+1)/static_cast<double>(procgrid[1])
    + bounds[1] + small;
  ghostbounds[4] = static_cast<double>(myloc[2])/static_cast<double>(procgrid[2])
    - bounds[2] - small;
  ghostbounds[5] = static_cast<double>(myloc[2]+1)/static_cast<double>(procgrid[2])
    + bounds[2];+ small;

  glog.logfile << "ghostbounds\n";
  glog.logfile << ghostbounds[0] << "\t" << ghostbounds[1] << "\t";
  glog.logfile << ghostbounds[2] << "\t" << ghostbounds[3] << "\t";
  glog.logfile << ghostbounds[4] << "\t" << ghostbounds[5] << endl;

  mbinx = static_cast<int>(2.0*w[0]*(ghostbounds[1]-ghostbounds[0])/rcut);
  mbiny = static_cast<int>(2.0*w[1]*(ghostbounds[3]-ghostbounds[2])/rcut);
  mbinz = static_cast<int>(2.0*w[2]*(ghostbounds[5]-ghostbounds[4])/rcut);



  // Find lowest and highest bounds for bins in no-ghost region
  double reg[6];
  reg[0] = 0.0;reg[1] = 1.0;
  reg[2] = 0.0;reg[3] = 1.0;
  reg[4] = 0.0;reg[5] = 1.0;
  vector<double> regc;
  regc.resize(6);
  regc = GhostBounds(reg);
  mbinxlo = static_cast<int> (regc[0]*mbinx)+1;
  mbinxhi = static_cast<int> (regc[1]*mbinx);
  mbinylo = static_cast<int> (regc[2]*mbiny)+1;
  mbinyhi = static_cast<int> (regc[3]*mbiny);
  mbinzlo = static_cast<int> (regc[4]*mbinz)+1;
  mbinzhi = static_cast<int> (regc[5]*mbinz);
    
  glog.logfile  << "mbinxlo = " << mbinxlo << endl;
  glog.logfile  << "mbinxhi = " << mbinxhi << endl;
  glog.logfile  << "mbinylo = " << mbinylo << endl;
  glog.logfile  << "mbinyhi = " << mbinyhi << endl;
  glog.logfile  << "mbinzlo = " << mbinzlo << endl;
  glog.logfile  << "mbinzhi = " << mbinzhi << endl;

  mbins = mbinx*mbiny*mbinz;

  glog.logfile << "mbinx = " << mbinx << endl;
  glog.logfile << "mbiny = " << mbiny << endl;
  glog.logfile << "mbinz = " << mbinz << endl;
  glog.logfile << endl;
  glog.logfile << "mbins = " << mbins << endl;
  glog.logfile << endl;

  // binsize in fractional coordinates
  binsizex = (ghostbounds[1]-ghostbounds[0])/mbinx;
  binsizey = (ghostbounds[1]-ghostbounds[0])/mbiny;
  binsizez = (ghostbounds[1]-ghostbounds[0])/mbinz;

  glog.logfile << "binsizex = " << binsizex << endl;
  glog.logfile << "binsizey = " << binsizey << endl;
  glog.logfile << "binsizez = " << binsizez << endl;

  // Create bins - Fractional coordinates
  Bin current_bin;
  double fcb[6];
  for (int k=0;k<mbinz;k++)
    for (int j=0;j<mbiny;j++)
      for (int i=0;i<mbinx;i++)
	{

	  double facx = (ghostbounds[1]-ghostbounds[0])/static_cast<double>(mbinx);
	  fcb[0] = ghostbounds[0] + i*facx;
	  fcb[1] = ghostbounds[0] + (i+1)*facx;
    
	  double facy = (ghostbounds[3]-ghostbounds[2])/static_cast<double>(mbiny);
	  fcb[2] = ghostbounds[2] + j*facy;
	  fcb[3] = ghostbounds[2] + (j+1)*facy;

	  double facz = (ghostbounds[5]-ghostbounds[4])/static_cast<double>(mbinz);
	  fcb[4] = ghostbounds[4] + i*facz;
	  fcb[5] = ghostbounds[4] + (i+1)*facz;

	  current_bin.set_id( k*mbiny*mbinx + j*mbinx + i);
	  current_bin.set_binx(i);
	  current_bin.set_biny(j);
	  current_bin.set_binz(k);
	  current_bin.set_binregion(fcb);
	  bins.push_back(current_bin);

	  //glog.logfile << fcb[0] << "  " << fcb[1] << "\t" << fcb[2] << "  "
	  //     << fcb[3] << "\t" << fcb[4] << "  " << fcb[5] << endl;
	}

  BinParticles(p->get_nparticles(),p->get_nghost_particles(),p->get_particles(), b, comm);

  // Define neighboring bins   
  vector<Bin *> neighbin;
  neighbin.resize(26);
  for (int i = 0; i < mbins; i++) 
    {
      for (int j = 0; j <26; j++)
	neighbin[j] = SelectNbrBins(&bins[i])[j];
      bins[i].set_nbrs(neighbin);
    }

  for (int j = 0; j <26; j++)
    {
      neighbin[j] = bins[17].get_nbrs()[j];
      glog.logfile  << neighbin[j]->get_id() << endl;
    }
  

  /////////   TESTS   /////////
  double region[6]; // Fractional region only
  region[0] = -0.25; region[1] = 0.25;
  region[2] = -0.25; region[3] = 0.25;
  region[4] = -0.25; region[5] = 0.25;
    
  // Test SelectRegionBins
  {
    vector<Bin *> temp_bins;
    glog.logfile << "\n\nTest SelectRegionBins --- Trial region:\n";
    glog.logfile << region[0] << "\t" << region[1] << "\t" << region[2] << "\t"
	         << region[3] << "\t" << region[4] << "\t" << region[5] << endl;
    
    temp_bins = SelectRegionBins(region,b);
    glog.logfile << "Bins check: "<<endl;
    glog.logfile << "Number of bins found: "<< temp_bins.size()<<endl;
    vector<Bin *>::iterator pbin;
    for (pbin = temp_bins.begin();pbin!=temp_bins.end();pbin++)
      {
	glog.logfile << "Bin " <<(*pbin)->get_id()<<" : ";

	double fcb[6];	
	(*pbin)->get_binregion(fcb);
	glog.logfile << fcb[0]<<"\t"<<  fcb[1]<<"\t"<< fcb[2]<<"\t"
	     << fcb[3]<<"\t"<<  fcb[4]<<"\t"<< fcb[5]<<endl;
      }
  }

  // Test GhostSelectRegionBins 
  {
    vector<Bin *> temp_bins;
    glog.logfile << "\n\nTest SelectGhostRegionBins --- Trial region:\n";
    glog.logfile << region[0] << "\t" << region[1] << "\t" << region[2] << "\t"
  	         << region[3] << "\t" << region[4] << "\t" << region[5] << endl;
    
    temp_bins = SelectGhostRegionBins(region,b);
    glog.logfile << "Ghost Bins check: "<<endl;
    glog.logfile << "Number of ghost bins found: "<< temp_bins.size()<<endl;
    vector<Bin *>::iterator pbin;
    for (pbin = temp_bins.begin();pbin!=temp_bins.end();pbin++)
      {
	glog.logfile << "Bin " <<(*pbin)->get_id()<<" : ";

	double fcb[6];	
	(*pbin)->get_binregion(fcb);
	glog.logfile << fcb[0]<<"\t"<< fcb[1]<<"\t"<<fcb[2]<<"\t"
	             << fcb[3]<<"\t"<< fcb[4]<<"\t"<<fcb[5]<<endl;
      }
  }
}

/* Bin Particles */
void BinList::BinParticles(
	       const int& nparticles, const int& nghost_particles, 
	       const Particle* particles, const Box* b, Comm* comm)
{
  int node;
  node = comm->get_node();
  if (node == 0) {
    glog.logfile << "\n\n\n";
    glog.logfile << "Entering BinList::BinParticles()" << endl;
  }
  if (comm->get_Lnodefile()) {
    comm->get_nodefile() << "Entered BinList::BinParticles" << endl;
  }

  // bin particles
  double x[3];
  for (int i = 0; i < nparticles; i++) 
    {
      particles[i].get_x(x);
      int ibin = Coord2BinLocal(x,b);
      bins[ibin].particles.push_back(particles[i]);
    }

  // bin ghost particles
  for (int i = nparticles; i < nparticles + nghost_particles; i++) 
    {
      particles[i].get_x(x);
      int ibin = Coord2BinGhost(x,b);
      bins[ibin].particles.push_back(particles[i]);
    }
}


int BinList::Coord2BinLocal(const double x[], const Box* b)
{
  int ix,iy,iz;
  int ibin;
  double value;

  value = b->Fractional(0,x);
  ix = static_cast<int> (value*mbinx);

  value = b->Fractional(1,x);
  iy = static_cast<int> (value*mbiny);

  value = b->Fractional(2,x);
  iz = static_cast<int> (value*mbinz) ;

  ibin = iz*mbiny*mbinx + iy*mbinx + ix;

  if (ibin < 0 || ibin >= mbins) {
    glog.logfile << "ibin in Coord2BinLocal out of range " << ibin << endl;
    glog.abort("BinList::Coord2BinLocal:\n"
	       "ibin for local particle out of range");
  }    

  return ibin;
}

int BinList::Coord2BinGhost(const double x[], const Box* b)
{
  int ix,iy,iz;
  int ibin;
  double val[6];
  vector <double> valc;

  val[0] = b->Fractional(0,x);
  val[1] = b->Fractional(1,x);
  val[2] = b->Fractional(2,x);

  valc = GhostBounds(val);
  ix = static_cast<int>(valc[0]);
  iy = static_cast<int>(valc[2]);
  iz = static_cast<int>(valc[4]);

  ibin = iz*mbiny*mbinx + iy*mbinx + ix;

  if (ibin < 0 || ibin >= mbins) 
    {
      glog.logfile << "ibin in Coord2BinGhost out of range " << ibin << endl;
      glog.abort("BinList::Coord2BinGhost:\n"
		 "ibin for ghost particle out of range");
    } 
    
  return ibin;
}

vector<Bin *> BinList::SelectRegionBins(double reg[6], const Box* b)
{  
  // enter a fractional region only.
  
  vector<Bin *> RegionBins;
  Bin *current_bin;
 
  vector<double> bndsc;
  bndsc.resize(6);
  bndsc = GhostBounds(reg);

  int ixlo =  max(static_cast<int> (bndsc[0]*mbinx),mbinxlo);
  int ixhi =  min(static_cast<int> (bndsc[1]*mbinx+1),mbinxhi);
  int iylo =  max(static_cast<int> (bndsc[2]*mbiny),mbinylo);
  int iyhi =  min(static_cast<int> (bndsc[3]*mbiny+1),mbinyhi);
  int izlo =  max(static_cast<int> (bndsc[4]*mbinz),mbinzlo);
  int izhi =  min(static_cast<int> (bndsc[5]*mbinz+1),mbinzhi);

  glog.logfile << "ixlo=" << ixlo << endl;
  glog.logfile << "ixhi=" << ixhi << endl;
  glog.logfile << "iylo=" << iylo << endl;
  glog.logfile << "iyhi=" << iyhi << endl;
  glog.logfile << "izlo=" << izlo << endl;
  glog.logfile << "izhi=" << izhi << endl;

  for (int k=izlo;k<izhi;k++)
    for (int j=iylo;j<iyhi;j++)
      for (int i=ixlo;i<ixhi;i++)
	{
	  int n = mbinx*mbiny*k + mbinx*j + i;
	  if (n < 0 || n >= mbins) 
	    {
	      glog.logfile << "n out of range " << n << endl;
	      glog.abort("BinList::SelectRegionBins:\n"
			 "n out of range");
	    }    

	  current_bin = &bins[n];
	  RegionBins.push_back(current_bin);	  
	}
  
  return RegionBins;
}


vector<Bin *> BinList::SelectGhostRegionBins(double reg[6], const Box* b)
{  
  // enter a fractional region only
  vector<Bin *> RegionGhostBins;
  Bin *current_bin;

  vector<double> bndsc;
  bndsc.resize(6);
  bndsc = GhostBounds(reg);

  int ixlo =  static_cast<int> (bndsc[0]*mbinx);
  int ixhi =  static_cast<int> (bndsc[1]*mbinx)+1;

  if(ixhi <= mbinxlo || ixlo >= mbinxhi) 
    {} 
  else if (ixlo >=mbinxlo && ixhi <= mbinxhi) 
    return  RegionGhostBins;
  else if (ixlo >= mbinxlo)
      ixlo = mbinxhi;
  else
    ixhi = mbinxlo;

  int iylo =  static_cast<int> (bndsc[2]*mbiny);
  int iyhi =  static_cast<int> (bndsc[3]*mbiny)+1;

  if(iyhi <= mbinylo || iylo >= mbinyhi) 
    {} 
  else if (iylo >=mbinylo && iyhi <= mbinyhi) 
    return  RegionGhostBins;
  else if (iylo >= mbinylo)
      iylo = mbinyhi;
  else
    iyhi = mbinylo;

  int izlo =  static_cast<int> (bndsc[4]*mbinz);
  int izhi =  static_cast<int> (bndsc[5]*mbinz)+1;

  if(izhi <= mbinzlo || izlo >= mbinzhi) 
    {} 
  else if (izlo >=mbinzlo && izhi <= mbinzhi) 
    return  RegionGhostBins;
  else if (izlo >= mbinzlo)
      izlo = mbinzhi;
  else
    izhi = mbinzlo;

  glog.logfile << "ixlo=" << ixlo << endl;
  glog.logfile << "ixhi=" << ixhi << endl;
  glog.logfile << "iylo=" << iylo << endl;
  glog.logfile << "iyhi=" << iyhi << endl;
  glog.logfile << "izlo=" << izlo << endl;
  glog.logfile << "izhi=" << izhi << endl;


  for (int k=izlo;k<izhi;k++)
    for (int j=iylo;j<iyhi;j++)
      for (int i=ixlo;i<ixhi;i++)
	{
	  int n = mbinx*mbiny*k + mbinx*j + i;
	  
	  if (n < 0 || n >= mbins) 
	    {
	      glog.logfile << "n out of range " << n << endl;
	      glog.abort("BinList::SelectGhostRegionBins:\n"
			 "n out of range");
	    }    
	  
	  current_bin = &bins[n];
	  RegionGhostBins.push_back(current_bin);	  
	}

  return RegionGhostBins;
}

vector<Bin *> BinList::SelectNbrBins (Bin* ibin)
{
  int n,m;
  int nbrs[26];
  n = ibin->get_id();

  int ix = ibin->get_binx();
  int iy = ibin->get_biny();
  int iz = ibin->get_binz();

  int ixx = ix;
  int iyy = iy;
  int izz = iz;

  if (ix == 0) ixx = mbinx-2;
  if (ix == mbinx-1) ixx = 1;
  if (iy == 0) iyy = mbiny-2;
  if (iy == mbiny-1) iyy = 1;
  if (iz == 0) izz = mbinz-2;
  if (iz == mbinz-1) izz = 1;


  m = 0;
   for (int k=izz-1;k<=izz+1;k++)
    for (int j=iyy-1;j<=iyy+1;j++)
      for (int i=ixx-1;i<=ixx+1;i++)
	{
	  if (k != izz || j != iyy || i != ixx)
	    {
	      nbrs[m] = k*mbiny*mbinx + j*mbinx + i;
	      m++;
	    }
	}


  vector<Bin *> NeighborBins;
  Bin *current_bin;
  for (int i = 0; i < 26; i++) 
    {
      int j = nbrs[i];

      if (j < 0 || j >= mbins) 
	{
	  glog.logfile << "j out of range " << j << endl;
	  glog.abort("BinList::SelectNbrBins:\n"
	  	     "j out of range");
	}    

      current_bin = &bins[j];
      NeighborBins.push_back(current_bin);	  
    }

  return NeighborBins;
}

vector <double> BinList::GhostBounds(double r[])
{
  vector <double> rc;
  rc.resize(6);

    rc[0] = (r[0]  - ghostbounds[0])/(ghostbounds[1]-ghostbounds[0]);
    rc[1] = (r[1]  - ghostbounds[0])/(ghostbounds[1]-ghostbounds[0]);

    rc[2] = (r[2]  - ghostbounds[2])/(ghostbounds[3]-ghostbounds[2]);
    rc[3] = (r[3]  - ghostbounds[2])/(ghostbounds[3]-ghostbounds[2]);

    rc[4] = (r[4]  - ghostbounds[4])/(ghostbounds[5]-ghostbounds[4]);
    rc[5] = (r[5]  - ghostbounds[4])/(ghostbounds[5]-ghostbounds[4]);

  return rc;
}

@


1.1.2.2
log
@Modify binlist to create bins array locally (to each proc).
Begin implementing octantlist.

saubry (04-07-05).
@
text
@d25 2
d47 4
d53 2
a54 2
  int loc[3];
  comm->get_myloc(loc);
d61 4
a64 4
  double rcutneigh[3];
  rcutneigh[0] = rcut/w[0];
  rcutneigh[1] = rcut/w[1];
  rcutneigh[2] = rcut/w[2];
d66 5
a70 7
  if (node == 0)
    {
      glog.logfile  << "rcut = " << rcut << endl;
      glog.logfile  << "rcutneigh[0] = " << rcutneigh[0] << endl;
      glog.logfile  << "rcutneigh[1] = " << rcutneigh[1] << endl;
      glog.logfile  << "rcutneigh[2] = " << rcutneigh[2] << endl;
    }
d73 3
a75 3
  nbinx = static_cast<int> (2.0/rcutneigh[0]);
  nbiny = static_cast<int> (2.0/rcutneigh[1]);
  nbinz = static_cast<int> (2.0/rcutneigh[2]);
d82 25
a106 32
  if (node == 0)
    {
      glog.logfile  << "nbinx = " << nbinx << endl;
      glog.logfile  << "nbiny = " << nbiny << endl;
      glog.logfile  << "nbinz = " << nbinz << endl;
      glog.logfile << endl;
      glog.logfile  << "nbins = " << nbins << endl;
      glog.logfile << endl;
    }

  // Ghost region in fractional coordinates
  ghostbounds[0] = static_cast<double>(loc[0])/static_cast<double>(procgrid[0])
    - rcutneigh[0] - small;
  ghostbounds[1] = static_cast<double>(loc[0]+1)/static_cast<double>(procgrid[0])
    + rcutneigh[0] + small;
  ghostbounds[2] = static_cast<double>(loc[1])/static_cast<double>(procgrid[1])
    - rcutneigh[1] - small;
  ghostbounds[3] = static_cast<double>(loc[1]+1)/static_cast<double>(procgrid[1])
    + rcutneigh[1] + small;
  ghostbounds[4] = static_cast<double>(loc[2])/static_cast<double>(procgrid[2])
    - rcutneigh[2] - small;
  ghostbounds[5] = static_cast<double>(loc[2]+1)/static_cast<double>(procgrid[2])
    + rcutneigh[2] + small;

  if (node == 0)
    {
      glog.logfile << "ghostbounds\n";
      glog.logfile << ghostbounds[0] << "\t" << ghostbounds[1] << "\t";
      glog.logfile << ghostbounds[2] << "\t" << ghostbounds[3] << "\t";
      glog.logfile << ghostbounds[4] << "\t" << ghostbounds[5] << endl;
    }

d115 1
a115 1
  double reg[6],regc[6];
d119 3
a121 1
  GhostBounds(reg,regc);
d129 6
a134 9
  if (node == 0)
    {
      glog.logfile  << "mbinxlo = " << mbinxlo << endl;
      glog.logfile  << "mbinxhi = " << mbinxhi << endl;
      glog.logfile  << "mbinylo = " << mbinylo << endl;
      glog.logfile  << "mbinyhi = " << mbinyhi << endl;
      glog.logfile  << "mbinzlo = " << mbinzlo << endl;
      glog.logfile  << "mbinzhi = " << mbinzhi << endl;
    }
d138 7
a144 10
  if (node == 0)
    {
      glog.logfile << "mbinx = " << mbinx << endl;
      glog.logfile << "mbiny = " << mbiny << endl;
      glog.logfile << "mbinz = " << mbinz << endl;
      glog.logfile << endl;
      glog.logfile << "mbins = " << mbins << endl;
      glog.logfile << endl;
    }
  
d150 3
a152 6
  if (node == 0)
    {
      glog.logfile << "binsizex = " << binsizex << endl;
      glog.logfile << "binsizey = " << binsizey << endl;
      glog.logfile << "binsizez = " << binsizez << endl;
    }
a154 3
  double facx = (ghostbounds[1]-ghostbounds[0])/static_cast<double>(mbinx);
  double facy = (ghostbounds[3]-ghostbounds[2])/static_cast<double>(mbiny);
  double facz = (ghostbounds[5]-ghostbounds[4])/static_cast<double>(mbinz);
d161 2
d165 2
a166 1
	  
d169 2
a170 1
	  
d173 7
a179 10
	  
	  if (CheckBin(comm,fcb) == 1)
	    {
	      current_bin.set_id( k*mbiny*mbinx + j*mbinx + i);
	      current_bin.set_binx(i);
	      current_bin.set_biny(j);
	      current_bin.set_binz(k);
	      current_bin.set_binregion(fcb);
	      bins.push_back(current_bin);
	    }
d200 1
a200 1
      if (node == 0) glog.logfile  << neighbin[j]->get_id() << endl;
d213 3
a215 6
      if (node == 0)
	{
	  glog.logfile << "\n\nTest SelectRegionBins --- Trial region:\n";
	  glog.logfile << region[0] << "\t" << region[1] << "\t" << region[2] << "\t"
		       << region[3] << "\t" << region[4] << "\t" << region[5] << endl;
	}
d218 2
a219 5
    if (node == 0)
      {
	glog.logfile << "Bins check: "<<endl;
	glog.logfile << "Number of bins found: "<< temp_bins.size()<<endl;
      }
d223 1
a223 1
	if (node == 0) glog.logfile << "Bin " <<(*pbin)->get_id()<<" : ";
d227 2
a228 5
	if (node == 0)
	  {
	    glog.logfile << fcb[0]<<"\t"<<  fcb[1]<<"\t"<< fcb[2]<<"\t"
			 << fcb[3]<<"\t"<<  fcb[4]<<"\t"<< fcb[5]<<endl;
	  }
d235 3
a237 6
    if (node == 0)
      {
	glog.logfile << "\n\nTest SelectGhostRegionBins --- Trial region:\n";
	glog.logfile << region[0] << "\t" << region[1] << "\t" << region[2] << "\t"
		     << region[3] << "\t" << region[4] << "\t" << region[5] << endl;
      }
d240 2
a241 5
    if (node == 0)
      {
	glog.logfile << "Ghost Bins check: "<<endl;
	glog.logfile << "Number of ghost bins found: "<< temp_bins.size()<<endl;
      }
d245 1
a245 1
	if (node == 0) glog.logfile << "Bin " <<(*pbin)->get_id()<<" : ";
d249 2
a250 5
	if (node == 0)
	  {
	    glog.logfile << fcb[0]<<"\t"<< fcb[1]<<"\t"<<fcb[2]<<"\t"
			 << fcb[3]<<"\t"<< fcb[4]<<"\t"<<fcb[5]<<endl;
	  }
d262 4
a265 5
  if (node == 0) 
    {
      glog.logfile << "\n\n\n";
      glog.logfile << "Entering BinList::BinParticles()" << endl;
    }
d306 5
a310 6
  if (ibin < 0 || ibin >= mbins) 
    {
      glog.logfile << "ibin in Coord2BinLocal out of range " << ibin << endl;
      glog.abort("BinList::Coord2BinLocal:\n"
		 "ibin for local particle out of range");
    }    
d319 2
a320 1
  double val[6],valc[6];
d323 2
a324 2
  val[2] = b->Fractional(1,x);
  val[4] = b->Fractional(2,x);
d326 1
a326 1
  GhostBounds(val,valc);
d346 1
d350 17
a366 9
  double regc[6];
  GhostBounds(reg,regc);

  int ixlo =  max(static_cast<int> (regc[0]*mbinx),mbinxlo);
  int ixhi =  min(static_cast<int> (regc[1]*mbinx+1),mbinxhi);
  int iylo =  max(static_cast<int> (regc[2]*mbiny),mbinylo);
  int iyhi =  min(static_cast<int> (regc[3]*mbiny+1),mbinyhi);
  int izlo =  max(static_cast<int> (regc[4]*mbinz),mbinzlo);
  int izhi =  min(static_cast<int> (regc[5]*mbinz+1),mbinzhi);
d394 3
a396 2
  double regc[6];
  GhostBounds(reg,regc);
d398 2
a399 2
  int ixlo =  static_cast<int> (regc[0]*mbinx);
  int ixhi =  static_cast<int> (regc[1]*mbinx)+1;
d410 2
a411 2
  int iylo =  static_cast<int> (regc[2]*mbiny);
  int iyhi =  static_cast<int> (regc[3]*mbiny)+1;
d422 2
a423 2
  int izlo =  static_cast<int> (regc[4]*mbinz);
  int izhi =  static_cast<int> (regc[5]*mbinz)+1;
d434 8
d517 1
a517 1
void BinList::GhostBounds(double r[6],double rc[6])
d519 2
a520 10
  // coordinates -> fractional coordinates
  rc[0] = (r[0]  - ghostbounds[0])/(ghostbounds[1]-ghostbounds[0]);
  rc[1] = (r[1]  - ghostbounds[0])/(ghostbounds[1]-ghostbounds[0]);
  
  rc[2] = (r[2]  - ghostbounds[2])/(ghostbounds[3]-ghostbounds[2]);
  rc[3] = (r[3]  - ghostbounds[2])/(ghostbounds[3]-ghostbounds[2]);
  
  rc[4] = (r[4]  - ghostbounds[4])/(ghostbounds[5]-ghostbounds[4]);
  rc[5] = (r[5]  - ghostbounds[4])/(ghostbounds[5]-ghostbounds[4]);
}
d522 2
a523 12
void BinList::InvGhostBounds(double r[6],double rc[6])
{
  // fractional coordinates -> coordinates
  rc[0] = ghostbounds[0] + r[0]*(ghostbounds[1]-ghostbounds[0]);
  rc[1] = ghostbounds[0] + r[1]*(ghostbounds[1]-ghostbounds[0]);
  
  rc[2] = ghostbounds[2] + r[2]*(ghostbounds[3]-ghostbounds[2]);
  rc[3] = ghostbounds[2] + r[3]*(ghostbounds[3]-ghostbounds[2]);
  
  rc[4] = ghostbounds[4] + r[4]*(ghostbounds[5]-ghostbounds[4]);
  rc[5] = ghostbounds[4] + r[5]*(ghostbounds[5]-ghostbounds[4]);
}
d525 2
a526 30
int BinList::CheckBin(Comm *comm, double regbin[6])
{
  int loc[3];
  comm->get_myloc(loc);
  double bnds[6],regproc[6];
  bnds[0] = loc[0];
  bnds[1] = loc[0] + 1;
  bnds[2] = loc[1];
  bnds[3] = loc[1] + 1;
  bnds[4] = loc[2];
  bnds[5] = loc[2] + 1;
  InvGhostBounds(bnds,regproc);

  regproc[0] -= small;
  regproc[1] += small;
  regproc[2] -= small;
  regproc[3] += small;
  regproc[4] -= small;
  regproc[5] += small;

  //cout << regproc[0] << "\t" << regproc[1] << "\t" << regproc[2] << "\t"
  //     << regproc[3] << "\t" << regproc[4] << "\t" << regproc[5] << endl;


  int ires[3];
  //x  
  if(regbin[0]>=regproc[0] && regbin[1] <=regproc[1]) 
    ires[0] = 1;
  else
    ires[0] = 0;
d528 2
a529 11
  //y
  if(regbin[2]>=regproc[2] && regbin[3] <=regproc[3]) 
    ires[1] = 1;
  else
    ires[1] = 0;

  //z
  if(regbin[4]>=regproc[4] && regbin[5] <=regproc[5]) 
    ires[2] = 1;
  else
    ires[2] = 0;
d531 1
a531 1
  return (ires[0] + ires[1] + ires[2])/3;
@


1.1.2.3
log
@Correct binparticles routine.
Add map index.

saubry 04-12-05
@
text
@d25 3
a27 1
BinList::BinList(){}
a33 4
  int procgrid[3];
  comm->get_procgrid(procgrid);

  int nprocs = procgrid[0]*procgrid[1]*procgrid[2];
d35 7
a41 9
  if (node == 0) 
    {
      cout << "\n\n\n";
      cout << "Entering BinList::Setup()" << endl;
    }
  if (comm->get_Lnodefile()) 
    {
      comm->get_nodefile() << "Entered BinList::Setup" << endl;
    }
d45 4
d53 1
a53 1
  rcut = ffl->get_rcutneighmaxall();
d62 4
a65 8
      cout  << "w[0] = " << w[0] << endl;
      cout  << "w[1] = " << w[1] << endl;
      cout  << "w[2] = " << w[2] << endl;

      cout  << "rcut = " << rcut << endl;
      cout  << "rcutneigh[0] = " << rcutneigh[0] << endl;
      cout  << "rcutneigh[1] = " << rcutneigh[1] << endl;
      cout  << "rcutneigh[2] = " << rcutneigh[2] << endl;
d80 28
a107 6
      cout  << "nbinx = " << nbinx << endl;
      cout  << "nbiny = " << nbiny << endl;
      cout  << "nbinz = " << nbinz << endl;
      cout << endl;
      cout  << "nbins = " << nbins << endl;
      cout << endl;
a109 7
  // Global bounds in fractional coordinates
  globalbounds[0] =   - rcutneigh[0] - small;
  globalbounds[1] = 1 + rcutneigh[0] + small;
  globalbounds[2] =   - rcutneigh[1] - small;
  globalbounds[3] = 1 + rcutneigh[1] + small;
  globalbounds[4] =   - rcutneigh[2] - small;
  globalbounds[5] = 1 + rcutneigh[2] + small;
d111 19
d132 6
a137 4
      cout << "globalbounds\n";
      cout << globalbounds[0] << "\t" << globalbounds[1] << "\t";
      cout << globalbounds[2] << "\t" << globalbounds[3] << "\t";
      cout << globalbounds[4] << "\t" << globalbounds[5] << endl;
a139 3
  mbinx = static_cast<int>(2.0*w[0]*(globalbounds[1]-globalbounds[0])/rcut);
  mbiny = static_cast<int>(2.0*w[1]*(globalbounds[3]-globalbounds[2])/rcut);
  mbinz = static_cast<int>(2.0*w[2]*(globalbounds[5]-globalbounds[4])/rcut);
d144 6
a149 6
      cout << "mbinx = " << mbinx << endl;
      cout << "mbiny = " << mbiny << endl;
      cout << "mbinz = " << mbinz << endl;
      cout << endl;
      cout << "mbins = " << mbins << endl;
      cout << endl;
d153 3
a155 3
  binsizex = (globalbounds[1]-globalbounds[0])/static_cast<double>(mbinx);
  binsizey = (globalbounds[1]-globalbounds[0])/static_cast<double>(mbiny);
  binsizez = (globalbounds[1]-globalbounds[0])/static_cast<double>(mbinz);
d159 3
a161 26
      cout << "binsizex = " << binsizex << endl;
      cout << "binsizey = " << binsizey << endl;
      cout << "binsizez = " << binsizez << endl;
    }

  // Find lowest and highest bounds for bins in no-ghost region

  addon[0] = static_cast<int>(rcut/(binsizex*w[0])+1);
  addon[1] = static_cast<int>(rcut/(binsizex*w[1])+1);
  addon[2] = static_cast<int>(rcut/(binsizex*w[2])+1);

  mbinxlo = addon[0];
  mbinxhi = mbinx - addon[0];
  mbinylo = addon[1];
  mbinyhi = mbiny - addon[1];
  mbinzlo = addon[2];
  mbinzhi = mbinz - addon[2];

  if (node == 0)
    {
      cout  << "mbinxlo = " << mbinxlo << endl;
      cout  << "mbinxhi = " << mbinxhi << endl;
      cout  << "mbinylo = " << mbinylo << endl;
      cout  << "mbinyhi = " << mbinyhi << endl;
      cout  << "mbinzlo = " << mbinzlo << endl;
      cout  << "mbinzhi = " << mbinzhi << endl;
d165 3
a167 1
  map = new int[mbins];
d169 1
a169 2
  int m = 0;
  double fcb[6],fcbc[6];
d174 8
a181 12
	  fcb[0] = static_cast<double>(i)/static_cast<double>(mbinx);
	  fcb[1] = static_cast<double>(i)/static_cast<double>(mbinx);
	  fcb[2] = static_cast<double>(j)/static_cast<double>(mbiny);
	  fcb[3] = static_cast<double>(j)/static_cast<double>(mbiny);
	  fcb[4] = static_cast<double>(k)/static_cast<double>(mbinz);
	  fcb[5] = static_cast<double>(k)/static_cast<double>(mbinz);

	  InvGlobalBounds(fcb,fcbc);

	  fcbc[1] += binsizex;
	  fcbc[3] += binsizey;
	  fcbc[5] += binsizez;
d185 1
a185 3
	      int n =  k*mbiny*mbinx + j*mbinx + i;
	      current_bin.set_id(n);
	      map[n] = m;
d189 1
a189 1
	      current_bin.set_binregion(fcbc);
a190 1
	      m++;
d193 2
a194 2
	  //cout << fcbc[0] << "  " << fcbc[1] << "\t" << fcbc[2] << "  "
	  //     << fcbc[3] << "\t" << fcbc[4] << "  " << fcbc[5] << endl;
a196 3
  cout << "Node (" << node << ") // size=" << bins.size() 
       << " m =" << m << "\n";

d200 1
a200 1
  /*vector<Bin *> neighbin;
d205 2
a206 2
	neighbin[j] = SelectNbrBins(&bins[map[i]],comm)[j];
      bins[map[i]].set_nbrs(neighbin);
d211 2
a212 2
      neighbin[j] = bins[map[17]].get_nbrs()[j];
      cout  << neighbin[j]->get_id() << endl;
d214 1
a214 1
  */
d217 1
a217 1
    /*double region[6]; // Fractional region only
d227 2
a228 2
	  cout << "\n\nTest SelectRegionBins --- Trial region:\n";
	  cout << region[0] << "\t" << region[1] << "\t" << region[2] << "\t"
d232 1
a232 1
    temp_bins = SelectRegionBins(region,b,comm);
d235 2
a236 2
	cout << "Bins check: "<<endl;
	cout << "Number of bins found: "<< temp_bins.size()<<endl;
d241 1
a241 1
	cout << "Bin " <<(*pbin)->get_id()<<" : ";
d245 5
a249 2
	cout << fcb[0]<<"\t"<<  fcb[1]<<"\t"<< fcb[2]<<"\t"
	     << fcb[3]<<"\t"<<  fcb[4]<<"\t"<< fcb[5]<<endl;
d252 1
a252 1
    */
d254 1
a254 1
  /*{
d258 2
a259 2
	cout << "\n\nTest SelectGhostRegionBins --- Trial region:\n";
	cout << region[0] << "\t" << region[1] << "\t" << region[2] << "\t"
d263 1
a263 1
    temp_bins = SelectGhostRegionBins(region,b,comm);
d266 2
a267 2
	cout << "Ghost Bins check: "<<endl;
	cout << "Number of ghost bins found: "<< temp_bins.size()<<endl;
d272 1
a272 1
	cout << "Bin " <<(*pbin)->get_id()<<" : ";
d276 5
a280 5
	//if (node == 0)
	//  {
	    //cout << fcb[0]<<"\t"<< fcb[1]<<"\t"<<fcb[2]<<"\t"
	    //		 << fcb[3]<<"\t"<< fcb[4]<<"\t"<<fcb[5]<<endl;
	//  }
a282 1
  */
d294 2
a295 2
      cout << "\n\n\n";
      cout << "Entering BinList::BinParticles()" << endl;
d307 1
a307 2
      if (CheckPoint(b,comm,x) == 1) 
  	  bins[map[ibin]].particles.push_back(particles[i]);
d309 1
a309 2
  
  
d315 1
a315 2
      if (CheckPoint(b,comm,x) == 1) 
	bins[map[ibin]].particles.push_back(particles[i]);
a316 1
  
d324 1
a324 1
  double X[3];
d326 2
a327 2
  X[0] = b->Fractional(0,x);
  ix = static_cast<int>(mbinxlo + X[0]*nbinx);
d329 2
a330 2
  X[1] = b->Fractional(1,x);
  iy = static_cast<int>(mbinylo + X[1]*nbiny);
d332 2
a333 2
  X[2] = b->Fractional(2,x);
  iz = static_cast<int>(mbinzlo + X[2]*nbinz);
d339 1
a339 1
      cout << "ibin in Coord2BinLocal out of range " << ibin << endl;
a351 4
  double X[3];

  double w[3];
  b->get_lw(w);
d353 8
a360 27
  double raddon[3];
  raddon[0] = 1. + rcut/(binsizex*w[0]);

  X[0] = b->Fractional(0,x);
  X[1] = b->Fractional(1,x);
  X[2] = b->Fractional(2,x);

  if (X[0] > 1.0)
      ix = static_cast<int> ((X[0] - 1.0)*nbinx) + nbinx + mbinxlo;
  else if (X[0] >= 0.0)
    ix = static_cast<int> (X[0]*nbinx) + mbinxlo;
  else
    ix = static_cast<int> (X[0]*nbinx) + mbinxlo - 1;

  if (X[1] > 1.0)
    iy = static_cast<int> ((X[1] - 1.0)*nbiny) + nbiny + mbinylo;
  else if (X[1] >= 0.0)
    iy = static_cast<int> (X[1]*nbiny) + mbinylo;
  else
    iy = static_cast<int> (X[1]*nbiny) +mbinylo - 1;

  if (X[2] > 1.0)
    iz = static_cast<int> ((X[2] - 1.0)*nbinz) + nbinz + mbinzlo;
  else if (X[2] >= 0.0)
    iz = static_cast<int> (X[2]*nbinz) + mbinzlo;
  else
    iz = static_cast<int> (X[2]*nbinz) + mbinzlo -1;
d366 1
a366 2
      cout << x[0] << "\t" << x[1] << "\t" << x[2] << endl;
      cout << "ibin in Coord2BinGhost out of range " << ibin << endl;
d374 1
a374 1
vector<Bin *> BinList::SelectRegionBins(double reg[6], const Box* b,Comm* comm)
a376 3
  int node;
  node = comm->get_node();

d381 1
a381 1
  GlobalBounds(reg,regc);
d402 2
a403 5
	  if (CheckBin2(comm,i,j,k) == 1)
	    {
	      current_bin = &bins[map[n]];
	      RegionBins.push_back(current_bin);	  
	    }
d410 1
a410 1
vector<Bin *> BinList::SelectGhostRegionBins(double reg[6], const Box* b,Comm * comm)
d413 1
a413 5
  int node;
  node = comm->get_node();


 vector<Bin *> RegionGhostBins;
d417 1
a417 1
  GlobalBounds(reg,regc);
d419 2
a420 2
  double ixlo =  regc[0]*mbinx;
  double ixhi =  regc[1]*mbinx+1;
d431 2
a432 2
  double iylo =  regc[2]*mbiny;
  double iyhi =  regc[3]*mbiny+1;
d443 2
a444 2
  double izlo =  regc[4]*mbinz;
  double izhi =  regc[5]*mbinz+1;
d468 2
a469 5
	  if (CheckBin2(comm,i,j,k) == 1)
	    {
	    current_bin = &bins[map[n]];
	    RegionGhostBins.push_back(current_bin);	  
	  }
d475 1
a475 1
vector<Bin *> BinList::SelectNbrBins (Bin* ibin, Comm* comm)
a476 3
  int node;
  node = comm->get_node();

d478 1
a478 1
  int nbrs[26], nbx[26],nby[26],nbz[26];
a503 3
	      nbx[m] = i;
	      nby[m] = j;
	      nbz[m] = k;
d523 2
a524 5
	  if (CheckBin2(comm,nbx[i],nby[i],nbz[i]) == 1)
	    {
	    current_bin = &bins[map[j]];
	    NeighborBins.push_back(current_bin);	  
	  }
d530 1
a530 1
void BinList::GlobalBounds(double r[6],double rc[6])
d533 2
a534 2
  rc[0] = (r[0]  - globalbounds[0])/(globalbounds[1]-globalbounds[0]);
  rc[1] = (r[1]  - globalbounds[0])/(globalbounds[1]-globalbounds[0]);
d536 2
a537 2
  rc[2] = (r[2]  - globalbounds[2])/(globalbounds[3]-globalbounds[2]);
  rc[3] = (r[3]  - globalbounds[2])/(globalbounds[3]-globalbounds[2]);
d539 2
a540 2
  rc[4] = (r[4]  - globalbounds[4])/(globalbounds[5]-globalbounds[4]);
  rc[5] = (r[5]  - globalbounds[4])/(globalbounds[5]-globalbounds[4]);
d543 1
a543 1
void BinList::InvGlobalBounds(double r[6],double rc[6])
d546 2
a547 2
  rc[0] = globalbounds[0] + r[0]*(globalbounds[1]-globalbounds[0]);
  rc[1] = globalbounds[0] + r[1]*(globalbounds[1]-globalbounds[0]);
d549 2
a550 2
  rc[2] = globalbounds[2] + r[2]*(globalbounds[3]-globalbounds[2]);
  rc[3] = globalbounds[2] + r[3]*(globalbounds[3]-globalbounds[2]);
d552 2
a553 2
  rc[4] = globalbounds[4] + r[4]*(globalbounds[5]-globalbounds[4]);
  rc[5] = globalbounds[4] + r[5]*(globalbounds[5]-globalbounds[4]);
d556 1
a556 2

int BinList::CheckBin(const Comm *comm, double regbin[6])
a559 3
  int procgrid[3];
  comm->get_procgrid(procgrid);

d561 7
a567 7
  bnds[0] = static_cast<double>(loc[0])/static_cast<double>(procgrid[0]);
  bnds[1] = static_cast<double>(loc[0]+1)/static_cast<double>(procgrid[0]);
  bnds[2] = static_cast<double>(loc[1])/static_cast<double>(procgrid[1]);
  bnds[3] = static_cast<double>(loc[1]+1)/static_cast<double>(procgrid[1]);
  bnds[4] = static_cast<double>(loc[2])/static_cast<double>(procgrid[2]);
  bnds[5] = static_cast<double>(loc[2]+1)/static_cast<double>(procgrid[2]);
  InvGlobalBounds(bnds,regproc);
a575 5
  
  int node;
  node = comm->get_node();

  //cout << "node (" << node << ")--  ";
a580 110
  //x
  if(regbin[0]>=regproc[0] && regbin[1] <=regproc[1])
    ires[0] = 1;
  else
    ires[0] = 0;

  //y
  if(regbin[2]>=regproc[2] && regbin[3] <=regproc[3])
    ires[1] = 1;
  else
    ires[1] = 0;

  //z
  if(regbin[4]>=regproc[4] && regbin[5] <=regproc[5])
    ires[2] = 1;
  else
    ires[2] = 0;

  return (ires[0] + ires[1] + ires[2])/3;
}


int BinList::CheckBin2(const Comm *comm,int i,int j,int k)
{
  int loc[3];
  comm->get_myloc(loc);
  int procgrid[3];
  comm->get_procgrid(procgrid);
  double bnds[6],regproc[6];

  bnds[0] = static_cast<double>(loc[0])/static_cast<double>(procgrid[0]);
  bnds[1] = static_cast<double>(loc[0]+1)/static_cast<double>(procgrid[0]);
  bnds[2] = static_cast<double>(loc[1])/static_cast<double>(procgrid[1]);
  bnds[3] = static_cast<double>(loc[1]+1)/static_cast<double>(procgrid[1]);
  bnds[4] = static_cast<double>(loc[2])/static_cast<double>(procgrid[2]);
  bnds[5] = static_cast<double>(loc[2]+1)/static_cast<double>(procgrid[2]);
  InvGlobalBounds(bnds,regproc);

  regproc[0] -= small;
  regproc[1] += small;
  regproc[2] -= small;
  regproc[3] += small;
  regproc[4] -= small;
  regproc[5] += small;


  double bndsc[6];
  bnds[0] =  static_cast<double>(i)/static_cast<double>(mbinx);
  bnds[1] =  static_cast<double>(i)/static_cast<double>(mbinx);
  bnds[2] =  static_cast<double>(j)/static_cast<double>(mbiny);
  bnds[3] =  static_cast<double>(j)/static_cast<double>(mbiny);
  bnds[4] =  static_cast<double>(k)/static_cast<double>(mbinz);
  bnds[5] =  static_cast<double>(k)/static_cast<double>(mbinz);
  InvGlobalBounds(bnds,bndsc);
  bndsc[1] += binsizex;
  bndsc[3] += binsizey;
  bndsc[5] += binsizez;

  int ires[3];
  //x
  if(bndsc[0]>=regproc[0] && bndsc[1] <=regproc[1])
    ires[0] = 1;
  else
    ires[0] = 0;

  //y
  if(bndsc[2]>=regproc[2] && bndsc[3] <=regproc[3])
    ires[1] = 1;
  else
    ires[1] = 0;

  //z
  if(bndsc[4]>=regproc[4] && bndsc[5] <=regproc[5])
    ires[2] = 1;
  else
    ires[2] = 0;

  return (ires[0] + ires[1] + ires[2])/3;
}

int BinList::CheckPoint(const Box *b, const Comm *comm, const double particle[3])
{
  int loc[3];
  comm->get_myloc(loc);

  int procgrid[3];
  comm->get_procgrid(procgrid);

  double bnds[6],regproc[6];
  bnds[0] = static_cast<double>(loc[0])/static_cast<double>(procgrid[0]);
  bnds[1] = static_cast<double>(loc[0]+1)/static_cast<double>(procgrid[0]);
  bnds[2] = static_cast<double>(loc[1])/static_cast<double>(procgrid[1]);
  bnds[3] = static_cast<double>(loc[1]+1)/static_cast<double>(procgrid[1]);
  bnds[4] = static_cast<double>(loc[2])/static_cast<double>(procgrid[2]);
  bnds[5] = static_cast<double>(loc[2]+1)/static_cast<double>(procgrid[2]);
  InvGlobalBounds(bnds,regproc);

  regproc[0] -= small;
  regproc[1] += small;
  regproc[2] -= small;
  regproc[3] += small;
  regproc[4] -= small;
  regproc[5] += small;

  double x[3];
  x[0] = b->Fractional(0,particle);
  x[1] = b->Fractional(1,particle);
  x[2] = b->Fractional(2,particle);

  int ires[3];
d582 1
a582 1
  if(x[0]>=regproc[0] && x[0] <=regproc[1]) 
d588 1
a588 1
  if(x[1]>=regproc[2] && x[1] <=regproc[3]) 
d594 1
a594 1
  if(x[2]>=regproc[4] && x[2] <=regproc[5]) 
@


1.1.2.4
log
@Correct neighboring bins.
@
text
@d202 9
a210 12
  // Define neighboring bins  
  Bin checkbin;
  vector<Bin > nb;
  nb.resize(26);
  for (int ix = 0; ix < mbinx; ix++) 
    for (int iy = 0; iy < mbiny; iy++) 
      for (int iz = 0; iz < mbinz; iz++) 
	{
	  int n = mbinx*mbiny*iz + mbinx*iy + ix; 
	  if (CheckBin2(comm,ix,iy,iz) == 1)
	    bins[map[n]].set_nbrs(SelectNbrBins(ix,iy,iz,comm));
	}
d212 1
a212 1
  /*for (int j = 0; j <26; j++)
d214 1
a214 1
      nb[j] = bins[map[17]].get_nbrs()[j];
a217 1
  
d220 1
a220 1
  double region[6]; // Fractional region only
d252 1
a252 1

d254 1
a254 1
  {
d276 5
a280 5
	if (node == 0)
	  {
	    cout << fcb[0]<<"\t"<< fcb[1]<<"\t"<<fcb[2]<<"\t"
		 << fcb[3]<<"\t"<< fcb[4]<<"\t"<<fcb[5]<<endl;
	  }
d283 1
d458 2
a459 2
  int ixlo =  static_cast<int>(regc[0]*mbinx);
  int ixhi =  static_cast<int>(regc[1]*mbinx+1);
d470 2
a471 2
  int iylo =  static_cast<int>(regc[2]*mbiny);
  int iyhi =  static_cast<int>(regc[3]*mbiny+1);
d482 2
a483 2
  int izlo =  static_cast<int>(regc[4]*mbinz);
  int izhi =  static_cast<int>(regc[5]*mbinz+1);
d517 1
a517 1
vector<Bin *> BinList::SelectNbrBins (const int ix,const int iy, const int iz, Comm* comm)
d522 1
a522 1
  int m;
d524 5
@


