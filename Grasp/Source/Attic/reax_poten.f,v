head	3.2;
access;
symbols
	PreMonaco:3.2
	REAX-2:3.2.2.7
	REAXFF:3.2.0.2;
locks; strict;
comment	@c @;


3.2
date	2004.12.16.23.40.44;	author athomps;	state dead;
branches
	3.2.2.1;
next	3.1;

3.1
date	2004.12.16.23.07.39;	author athomps;	state Exp;
branches;
next	;

3.2.2.1
date	2004.12.16.23.59.24;	author athomps;	state Exp;
branches;
next	3.2.2.2;

3.2.2.2
date	2004.12.22.22.59.07;	author athomps;	state Exp;
branches;
next	3.2.2.3;

3.2.2.3
date	2005.01.03.00.29.17;	author athomps;	state Exp;
branches;
next	3.2.2.4;

3.2.2.4
date	2005.01.07.22.51.01;	author athomps;	state Exp;
branches;
next	3.2.2.5;

3.2.2.5
date	2005.01.29.02.15.37;	author athomps;	state Exp;
branches;
next	3.2.2.6;

3.2.2.6
date	2005.02.03.21.40.18;	author athomps;	state Exp;
branches;
next	3.2.2.7;

3.2.2.7
date	2005.02.10.01.50.42;	author athomps;	state Exp;
branches;
next	;


desc
@@


3.2
log
@Removed files inadvertently added to main branch
@
text
@**********************************************************************
*                                                                    *
*     REAXFF Reactive force field program                            *
*                                                                    *
*     Developed and written by Adri van Duin, duin@@wag.caltech.edu   *
*                                                                    *
*     Copyright (c) 2001-2010 California Institute of Technology     *
*                                                                    *
*     This is an open-source program. Feel free to modify its        *
*     contents. Please keep me informed of any useful modification   *
*     or addition that you made. Please do not distribute this       *
*     program to others; if people are interested in obtaining       *
*     a copy of this program let them contact me first.              *
*                                                                    *
**********************************************************************
******************************************************************** 


      subroutine calval

********************************************************************** 
      include 'cbka.blk'
      include 'cbkc.blk'
      include 'cbkdhdc.blk'
      include 'cbkdrdc.blk'
      include 'cbkh.blk'
      include 'cbknvl.blk'
      include 'cbkrbo.blk'
      include 'cbkvalence.blk'
      include 'cellcoord.blk'
      include 'control.blk'
      dimension a(3),b(3),j(3),dradc(3,3),drbdc(3,3),dtdc(3,3),
     $dargdc(3,3),dndc(3,3),dadc(3),dbdc(3)
********************************************************************** 
*                                                                    *
*     Calculate valency angles and their derivatives to cartesian    *
*     coordinates                                                    *
*     Valency angle energies are calculated in valang                *
*                                                                    *
********************************************************************** 
********************************************************************** 
*     Description of variables used in this routine.       
*                                                          
*     ndebug: stored in cbka.blk; control-parameter
*     third: local variable                  
*     twothird: local variable    
*     dadc(3): local array; stores derivative distance to cartesians    
*     dbdc(3): local array; stores derivative distance to cartesians
*     i1: local do-loop counter
*     i2: local do-loop counter
*     k1: local do-loop counter
*     k2: local do-loop counter
*     dradc(3,3): local array; stores derivatives bond lengths to
*                 cartesians
*     drbdc(3,3): local array; stores derivatives bond lengths to
*                 cartesians
*     nval: stored in cbka.blk; number of valence angles
*     ity: local integer; atom type                        
*     iv(nvalmax,6): stored in cbka.blk; valence angle identifiers
*     j(3): local integer array; stores valence angle atom numbers
*     la: local integer: stores bond numbers in valence angle
*     lb: local integer: stores bond numbers in valence angle
*     ivl1: local integer; stores symmetric copy number of bond
*     ivl2: local integer; stores symmetric copy number of bond
*     ibsym(nbomax): stored in cbka.blk; symmetric copy number of bond
*     isign1: local integer; -1 or 1                       
*     isign2: local integer; -1 or 1                       
*     rla: local variable; stores bond length for bond la
*     rlb: local variable; stores bond length for bond lb
*     rbo(nbomax): stored in cbka.blk; stores bond lengths
*     ix1,iy1,iz1,ix2,iy2,iz2: local integers; periodic cell shifts
*     nvlx(nat*nat),nvly(nat,nat),nvlz(nat*nat): stored in cbka.blk
*                  nonbonded-list periodic cell shifts     
*     a(3): local variable; distance in x,y and z-direction between atoms
*     b(3): local variable; distance in x,y and z-direction between atoms
*     c(nat,3): stored in cbka.blk; cartesian coordinate array
*     tm11,tm21,tm22,tm31,tm32,tm33: stored in cbka.blk; periodic cell
*                  matrix                                  
*     poem: local variable; product of bond lengths                                 
*     tel: local variable; cross-product of x,y and z-interatomic
*                  distances                    
*     arg: local variable; cosine of angle between bonds a and b
*     arg2: local variable; square of arg
*     s1ma22: local variable; used to check whether angle gets to 180
*                  degrees
*     s1ma2: local variable; square root of s1ma22                         
*     hl: local variable; angle (in radians) between bonds a and b
*     h(nvamax): stored in cbka.blk; angle (in radians) between bonds a
*                  and b
*     ib(nbomax,3): stored in cbka.blk: bond distance identifiers                   
*     drdc(nbomax,3,2): stored in cbka.blk; derivatives bond distances
*                  to cartesian coordinates
*     dndc(3,3): local variable; temporary storage for calculating
*                  derivatives of valence angle to cartesians
*     dtdc(3,3): local variable; temporary storage for calculating
*                  derivatives of valence angle to cartesians
*     dargdc(3,3): local variable; temporary storage for calculating
*                  derivatives of valence angle to cartesians
*     dhdc(nvamax,3,3): stored in cbka.blk; derivatives of valence angle 
*                  to cartesians
*                                                          
********************************************************************** 
      if (ndebug.eq.1) then
      open (65,file='fort.65',status='unknown',access='append')
      write (65,*) 'In calval'
      call timer(65)
      close (65)
      end if

      third=1.0/3.0
      twothird=2.0/3.0
      dadc(1)=-1.0
      dadc(2)=1.0
      dadc(3)=0.0
      dbdc(1)=0.0
      dbdc(2)=1.0
      dbdc(3)=-1.0
      do k1=1,3
      do k2=1,3
      dradc(k1,k2)=0.0
      drbdc(k1,k2)=0.0
      end do
      end do
      if (nval.eq.0) return
 
      do 10 i1=1,nval
      ity=iv(i1,1)
      j(1)=iv(i1,2)
      j(2)=iv(i1,3)
      j(3)=iv(i1,4)
**********************************************************************
*                                                                    *
*     Determine valency angle                                        *
*                                                                    *
**********************************************************************
      la=iv(i1,5)
      lb=iv(i1,6)
      ivl1=ibsym(la)
      ivl2=ibsym(lb)
      isign1=1
      isign2=1
      if (j(1).lt.j(2)) isign1=-1
      if (j(3).lt.j(2)) isign2=-1
      rla=rbo(la)
      rlb=rbo(lb)
      ix1=isign1*nvlx(ivl1)
      iy1=isign1*nvly(ivl1)
      iz1=isign1*nvlz(ivl1)
      ix2=isign2*nvlx(ivl2)
      iy2=isign2*nvly(ivl2)
      iz2=isign2*nvlz(ivl2)
 
*     call dista2(j(2),j(1),dis,a(1),a(2),a(3))
*     call dista2(j(2),j(3),dis,b(1),b(2),b(3))
      a(1)=c(j(2),1)-c(j(1),1)+ix1*tm11
      a(2)=c(j(2),2)-c(j(1),2)+ix1*tm21+iy1*tm22
      a(3)=c(j(2),3)-c(j(1),3)+ix1*tm31+iy1*tm32+iz1*tm33
      b(1)=c(j(2),1)-c(j(3),1)+ix2*tm11
      b(2)=c(j(2),2)-c(j(3),2)+ix2*tm21+iy2*tm22
      b(3)=c(j(2),3)-c(j(3),3)+ix2*tm31+iy2*tm32+iz2*tm33

      poem=rla*rlb
      tel=a(1)*b(1)+a(2)*b(2)+a(3)*b(3)
      arg=tel/poem
      arg2=arg*arg
      s1ma22=1.0-arg2
      if (s1ma22.lt.1.0d-10) s1ma22=1.0d-10
      s1ma2=sqrt(s1ma22)
      if (arg.gt.1.0) arg=1.0
      if (arg.lt.-1.0) arg=-1.0
      hl=acos(arg)
      h(i1)=hl
**********************************************************************
*                                                                    *
*     Calculate derivative valency angle to cartesian coordinates    *
*                                                                    *
**********************************************************************
      if (j(1).eq.ib(la,2)) then
      do k1=1,3
      dradc(k1,1)=drdc(la,k1,1)
      dradc(k1,2)=drdc(la,k1,2)
      end do
      else
      do k1=1,3
      dradc(k1,1)=drdc(la,k1,2)
      dradc(k1,2)=drdc(la,k1,1)
      end do
      end if
      if (j(2).eq.ib(lb,2)) then
      do k1=1,3
      drbdc(k1,2)=drdc(lb,k1,1)
      drbdc(k1,3)=drdc(lb,k1,2)
      end do
      else
      do k1=1,3
      drbdc(k1,2)=drdc(lb,k1,2)
      drbdc(k1,3)=drdc(lb,k1,1)
      end do
      end if
      do k1=1,3
      do k2=1,3
      dndc(k1,k2)=rla*drbdc(k1,k2)+rlb*dradc(k1,k2)
      dtdc(k1,k2)=a(k1)*dbdc(k2)+b(k1)*dadc(k2)
      dargdc(k1,k2)=(dtdc(k1,k2)-arg*dndc(k1,k2))/poem
      dhdc(i1,k1,k2)=-dargdc(k1,k2)/s1ma2
      end do
      end do
      
   10 continue

      return
      end
********************************************************************** 
********************************************************************** 

      subroutine boncor

********************************************************************** 
      include 'cbka.blk'
      include 'cbkabo.blk'
      include 'cbkbo.blk'
      include 'cbkboncor.blk'
      include 'cbkbosi.blk'
      include 'cbkbopi.blk'
      include 'cbkbopi2.blk'
      include 'cbkconst.blk'
      include 'cbkdbopi2ndc.blk'
      include 'cbkdbopidc.blk'
      include 'cbkdbopindc.blk'
      include 'cbkff.blk'
      include 'cbkia.blk'
      include 'cbkidbo.blk'
      include 'cbknubon2.blk'
      include 'cbkrbo.blk'
      include 'control.blk'
      include 'small.blk'
      include 'cbkdbodc.blk'
      if (ndebug.eq.1) then
      open (65,file='fort.65',status='unknown',access='append')
      write (65,*) 'In boncor'
      call timer(65)
      close (65)
      end if
********************************************************************** 
*                                                                    *
*     Correction for overcoordination and 1-3 bond orders            *
*                                                                    *
********************************************************************** 
********************************************************************** 
*     Description of variables used in this routine.       
*                                                          
*     ndebug: stored in cbka.blk; control-parameter
*     i1: local do-loop counter
*     i2: local do-loop counter
*     k1: local do-loop counter
*     k2: local do-loop counter
*     nbon: stored in cbka.blk; number of bonds in system
*     ibt: local integer; stores bond type
*     ib(nbomax,3): stored in cbka.blk: bond distance identifiers                   
*     j1: local integer; stores atom number 1st atom in bond
*     j2: local integer; stores atom number 2nd atom in bond
*     ovc(nbotym): stored in cbka.blk: force field parameter for
*                  overcoordination correction
*     v13cor(nbotym): stored in cbka.blk: force field parameter for
*                  1-3 bond order correction
*     idbo1(nbomax): stored in cbka.blk; number of atoms in the
*                  derivative of the bond order
*     idbo(nbomax,2*mbond): stored in cbka.blk; atom numbers of the
*                  atoms in the derivative of the bond order
*     dbondc(nbomax,3,2*mbond): stored in cbka.blk; derivative of
*                  corrected total bond orders to cartesians
*     dbosindc(nbomax,3,2*mbond): stored in cbka.blk; derivative of
*                  corrected sigma bond orders to cartesians
*     dbopindc(nbomax,3,2*mbond): stored in cbka.blk; derivative of
*                  corrected pi bond orders to cartesians
*     dbopi2ndc(nbomax,3,2*mbond): stored in cbka.blk; derivative of
*                  corrected double pi bond orders to cartesians
*     dbodc(nbomax,3,2): stored in cbka.blk; derivative of
*                  uncorrected total bond orders to cartesians
*     dbosidc(nbomax,3,2): stored in cbka.blk; derivative of
*                  uncorrected sigma bond orders to cartesians
*     dbopidc(nbomax,3,2): stored in cbka.blk; derivative of
*                  uncorrected pi bond orders to cartesians
*     dbopi2dc(nbomax,3,2): stored in cbka.blk; derivative of
*                  uncorrected double pi bond orders to cartesians
*     boo: local variable; storage of uncorrected total bond order
*     bo(nbomax): stored in cbka.blk; total bond order          
*     bopi(nbomax): stored in cbka.blk; pi bond order          
*     bopi2(nbomax): stored in cbka.blk; double pi bond order          
*     bopio: local variable; storage of uncorrected pi bond order
*     bopi2o: local variable; storage of uncorrected double pi bond order
*     iti: local integer; atom type first atom in bond     
*     itj: local integer; atom type second atom in bond     
*     ia(nat,mbond+3): stored in cbka.blk; connection table without bond
*                  order cutoff
*     aboi: local variable: total bond order around atom i
*     aboj: local variable: total bond order around atom j
*     abo(nat): stored in cbka.blk; total bond order around atoms
*     vp131: local variable; force field cross-term        
*     vp132: local variable; force field cross-term        
*     vp133: local variable; force field cross-term        
*     bo131(nsort): stored in cbka.blk; force field parameter for 1-3
*                  bond order correction
*     bo132(nsort): stored in cbka.blk; force field parameter for 1-3
*                  bond order correction
*     bo133(nsort): stored in cbka.blk; force field parameter for 1-3
*                  bond order correction
*     corrtot:local variable; total correction on bond order
*     dbodsboi1: local variable; derivative of bond order to sum of bond
*                  orders around atom i
*     dbodsboj1: local variable; derivative of bond order to sum of bond
*                  orders around atom j
*     ovi: local variable; overcoordination on atom i      
*     ovj: local variable; overcoordination on atom j      
*     aval(nat): stored in cbka.blk; nr. of valence electrons on atom       
*     exphu1: local variable; stores exponential
*     exphu2: local variable; stores exponential
*     exp11: local variable; stores exponential
*     exp21: local variable; stores exponential
*     vpar(npamax): stored in cbka.blk: general parameters                                  
*     exphu12: local variable; stores sum of exponential
*     ovcor: local variable; temporary storage for BO/ovcor corr.
*     huli: local variable; temporary storage for BO/ovcor corr.
*     hulj: local variable; temporary storage for BO/ovcor corr.
*     corr1: local variable; temporary storage for BO/ovcor corr.
*     corr2: local variable; temporary storage for BO/ovcor corr.
*     dbodsboi2: local variable; derivative of 1-3 BO correction to sum 
*                  of bond orders around atom i 
*     dbodsboj2: local variable; derivative of 1-3 BO correction to sum 
*                  of bond orders around atom i 
*     bocor1: local variable; 1-3 bond order correction                            
*     bocor2: local variable; 1-3 bond order correction                            
*     ovi2: local variable; overcoordination on atom i with reference to
*                  total number of electrons on atom i, including lone
*                  pairs     
*     ovj2: local variable; overcoordination on atom j with reference to
*                  total number of electrons on atom j, including lone
*                  pairs     
*     valf(nsort): stored in cbka.blk; total number of electrons on 
*                  atom, including lone pairs
*     cor1: local variable; temporary storage for BO/1-3 bond corr.
*     cor2: local variable; temporary storage for BO/1-3 bond corr.
*     exphu3: local variable; storage exponential
*     exphu4: local variable; storage exponential
*     corrtot2: local variable; square of corrtot                                  
*     dbodboo: local variable; derivative of corrected total bond order to 
*                   uncorrected bond order
*     dbopidbopio: local variable; derivative of corrected pi bond order
*                   to uncorrected pi bond order
*     dbopidboo: local variable; derivative of corrected pi bond order
*                   to uncorrected total bond order
*     dbopi2dbopi2o: local variable; derivative of corrected double pi bond order
*                   to uncorrected double pi bond order
*     dbopi2dboo: local variable; derivative of corrected double pi bond order
*                   to uncorrected total bond order
*     dbodsboit: local variable; derivative of total bond order to sum
*                   of bond orders around atom i
*     dbodsbojt: local variable; derivative of total bond order to sum
*                   of bond orders around atom j
*     vhui: local variable; temporary storage              
*     vhuj: local variable; temporary storage              
*     dbopidsboit: local variable; derivative of pi bond order to sum
*                   of bond orders around atom i
*     dbopidsbojt: local variable; derivative of pi bond order to sum
*                   of bond orders around atom j
*     dbopi2dsboit: local variable; derivative of pi bond order to sum
*                   of bond orders around atom i
*     dbopi2dsbojt: local variable; derivative of pi bond order to sum
*                   of bond orders around atom j
*     nco: local integer; counter for number of atoms in derivative
*     ihl: local integer; helps to access right dbodc-term
*     nubon2(nat,mbond): stored in cbka.blk; stored bond number as a
*                   function of atom number and connection number
*     iob: local integer; atom number of second atom in bond
*     ncubo: local integer; stores number of current bond  
*     na: stored in cbka.blk: number of atoms in system 
*     zero: stored in cbka.blk: value 0.00
*                                                          
********************************************************************** 
      do 10 i1=1,nbon
      ibt=ib(i1,1)
      j1=ib(i1,2)
      j2=ib(i1,3)
      if (ovc(ibt).lt.0.001.and.v13cor(ibt).lt.0.001) then
      idbo1(i1)=2
      idbo(i1,1)=j1
      idbo(i1,2)=j2
      do k1=1,3
      dbondc(i1,k1,1)=dbodc(i1,k1,1)
      dbondc(i1,k1,2)=dbodc(i1,k1,2)
      dbosindc(i1,k1,1)=dbosidc(i1,k1,1)
      dbosindc(i1,k1,2)=dbosidc(i1,k1,2)
      dbopindc(i1,k1,1)=dbopidc(i1,k1,1)
      dbopindc(i1,k1,2)=dbopidc(i1,k1,2)
      dbopi2ndc(i1,k1,1)=dbopi2dc(i1,k1,1)
      dbopi2ndc(i1,k1,2)=dbopi2dc(i1,k1,2)
      end do
      goto 10
      end if
      boo=bo(i1)
      bopio=bopi(i1)
      bopi2o=bopi2(i1)
      iti=ia(j1,1)
      itj=ia(j2,1)
      aboi=abo(j1)
      aboj=abo(j2)
      vp131=sqrt(bo131(iti)*bo131(itj))
      vp132=sqrt(bo132(iti)*bo132(itj))
      vp133=sqrt(bo133(iti)*bo133(itj))
      corrtot=1.0
      dbodsboi1=zero
      dbodsboj1=zero
      if (ovc(ibt).gt.0.001) then
      ovi=aboi-aval(iti)
      ovj=aboj-aval(itj)

********************************************************************** 
*                                                                    *
*     Correction for overcoordination                                *
*                                                                    *
********************************************************************** 
      exphu1=exp(-vpar(2)*ovi)
      exphu2=exp(-vpar(2)*ovj)
      exp11=exp(-vpar(1)*ovi)
      exp21=exp(-vpar(1)*ovj)
      exphu12=(exphu1+exphu2)
      ovcor=-(1.0/vpar(2))*log(0.50*exphu12)
      huli=((1.0/ovc(ibt))*aval(iti)+exp11+exp21)
      hulj=((1.0/ovc(ibt))*aval(itj)+exp11+exp21)
      corr1=huli/(huli+ovcor)
      corr2=hulj/(hulj+ovcor)
      corrtot=0.50*(corr1+corr2)

      dbodsboi1=0.50*(-vpar(1)*exp11/(huli+ovcor)-
     $(corr1/(huli+ovcor))*
     $(-vpar(1)*exp11+exphu1/exphu12)-vpar(1)*exp11/(hulj+ovcor)-
     $(corr2/(hulj+ovcor))*(-vpar(1)*exp11+exphu1/exphu12))
      dbodsboj1=0.50*(-vpar(1)*exp21/(huli+ovcor)-
     $(corr1/(huli+ovcor))*
     $(-vpar(1)*exp21+exphu2/exphu12)-vpar(1)*exp21/(hulj+ovcor)-
     $(corr2/(hulj+ovcor))*(-vpar(1)*exp21+exphu2/exphu12))
      end if
********************************************************************** 
*                                                                    *
*     Correction for 1-3 bond orders                                 *
*                                                                    *
********************************************************************** 
      dbodsboi2=zero
      dbodsboj2=zero
      bocor1=1.0
      bocor2=1.0
      if (v13cor(ibt).gt.0.001) then
      ovi2=aboi-valf(iti)
      ovj2=aboj-valf(itj)
*     ovi2=aboi-aval(iti)
*     ovj2=aboj-aval(itj)
      cor1=vp131*boo*boo-ovi2
      cor2=vp131*boo*boo-ovj2
      exphu3=v13cor(ibt)*exp(-vp132*cor1+vp133)
      exphu4=v13cor(ibt)*exp(-vp132*cor2+vp133)
      bocor1=1.0/(1.0+exphu3)
      bocor2=1.0/(1.0+exphu4)
      dbodsboi2=-bocor1*bocor1*bocor2*vp132*exphu3
      dbodsboj2=-bocor1*bocor2*bocor2*vp132*exphu4
      end if

      bo(i1)=boo*corrtot*bocor1*bocor2
      if (bo(i1).lt.1e-10) bo(i1)=zero
      corrtot2=corrtot*corrtot
      bopi(i1)=bopio*corrtot2*bocor1*bocor2
      bopi2(i1)=bopi2o*corrtot2*bocor1*bocor2
      if (bopi(i1).lt.1e-10) bopi(i1)=zero
      if (bopi2(i1).lt.1e-10) bopi2(i1)=zero

      dbodboo=corrtot*bocor1*bocor2+corrtot*
     $bocor1*bocor1*bocor2*boo*vp132*vp131*2.0*boo*exphu3+
     $corrtot*bocor1*bocor2*bocor2*boo*
     $vp132*vp131*exphu4*2.0*boo

      dbopidbopio=corrtot2*bocor1*bocor2

      dbopidboo=corrtot2*
     $bocor1*bocor1*bocor2*boo*vp132*vp131*2.0*bopio*exphu3+
     $corrtot2*bocor1*bocor2*bocor2*boo*
     $vp132*vp131*exphu4*2.0*bopio

      dbopi2dbopi2o=corrtot2*bocor1*bocor2

      dbopi2dboo=corrtot2*
     $bocor1*bocor1*bocor2*boo*vp132*vp131*2.0*bopi2o*exphu3+
     $corrtot2*bocor1*bocor2*bocor2*boo*
     $vp132*vp131*exphu4*2.0*bopi2o

      dbodsboit=boo*dbodsboi1*bocor1*bocor2+boo*corrtot*dbodsboi2
      dbodsbojt=boo*dbodsboj1*bocor1*bocor2+boo*corrtot*dbodsboj2

      vhui=2.0*corrtot*dbodsboi1*bocor1*bocor2+corrtot2*dbodsboi2
      vhuj=2.0*corrtot*dbodsboj1*bocor1*bocor2+corrtot2*dbodsboj2
      dbopidsboit=bopio*vhui
      dbopidsbojt=bopio*vhuj

      dbopi2dsboit=bopi2o*vhui
      dbopi2dsbojt=bopi2o*vhuj

********************************************************************** 
*                                                                    *
*     Calculate bond order derivatives                               *
*                                                                    *
********************************************************************** 
      idbo1(i1)=2+ia(j1,2)+ia(j2,2)
      idbo(i1,1)=j1
      idbo(i1,2)=j2
      nco=0
      do k1=1,3
      dbondc(i1,k1,1)=dbodc(i1,k1,1)*dbodboo
      dbondc(i1,k1,2)=dbodc(i1,k1,2)*dbodboo
*     dbosindc(i1,k1,1)=dbosidc(i1,k1,1)*dbosidboo
*     dbosindc(i1,k1,2)=dbosidc(i1,k1,2)*dbosidboo
      dbopindc(i1,k1,1)=dbopidc(i1,k1,1)*dbopidbopio+
     $dbodc(i1,k1,1)*dbopidboo
      dbopindc(i1,k1,2)=dbopidc(i1,k1,2)*dbopidbopio+
     $dbodc(i1,k1,2)*dbopidboo
      dbopi2ndc(i1,k1,1)=dbopi2dc(i1,k1,1)*dbopi2dbopi2o+
     $dbodc(i1,k1,1)*dbopi2dboo
      dbopi2ndc(i1,k1,2)=dbopi2dc(i1,k1,2)*dbopi2dbopi2o+
     $dbodc(i1,k1,2)*dbopi2dboo
      end do
      do i2=1,ia(j1,2)
      ihl=0
      iob=ia(j1,2+i2)
      if (iob.lt.j1) ihl=1
      ncubo=nubon2(j1,i2)
      idbo(i1,2+nco+1)=iob
      do k1=1,3
      dbondc(i1,k1,1)=dbondc(i1,k1,1)+dbodc(ncubo,k1,1+ihl)*dbodsboit
      dbondc(i1,k1,2+nco+1)=dbodc(ncubo,k1,2-ihl)*dbodsboit

*     dbosindc(i1,k1,1)=dbosindc(i1,k1,1)+
*    $dbodc(ncubo,k1,1+ihl)*dbosidsboit
*     dbosindc(i1,k1,2+nco+1)=dbodc(ncubo,k1,2-ihl)*dbosidsboit

      dbopindc(i1,k1,1)=dbopindc(i1,k1,1)+
     $dbodc(ncubo,k1,1+ihl)*dbopidsboit
      dbopindc(i1,k1,2+nco+1)=dbodc(ncubo,k1,2-ihl)*dbopidsboit

      dbopi2ndc(i1,k1,1)=dbopi2ndc(i1,k1,1)+
     $dbodc(ncubo,k1,1+ihl)*dbopi2dsboit
      dbopi2ndc(i1,k1,2+nco+1)=dbodc(ncubo,k1,2-ihl)*dbopi2dsboit

      end do
      nco=nco+1
      end do
      do i2=1,ia(j2,2)
      ihl=0
      iob=ia(j2,2+i2)
      if (iob.lt.j2) ihl=1
      ncubo=nubon2(j2,i2)
      idbo(i1,2+nco+1)=iob
      do k1=1,3

      dbondc(i1,k1,2)=dbondc(i1,k1,2)+dbodc(ncubo,k1,1+ihl)*dbodsbojt
      dbondc(i1,k1,2+nco+1)=dbodc(ncubo,k1,2-ihl)*dbodsbojt

*     dbosindc(i1,k1,2)=dbosindc(i1,k1,2)+
*    $dbodc(ncubo,k1,1+ihl)*dbosidsbojt
*     dbosindc(i1,k1,2+nco+1)=dbodc(ncubo,k1,2-ihl)*dbosidsbojt

      dbopindc(i1,k1,2)=dbopindc(i1,k1,2)+
     $dbodc(ncubo,k1,1+ihl)*dbopidsbojt
      dbopindc(i1,k1,2+nco+1)=dbodc(ncubo,k1,2-ihl)*dbopidsbojt

      dbopi2ndc(i1,k1,2)=dbopi2ndc(i1,k1,2)+
     $dbodc(ncubo,k1,1+ihl)*dbopi2dsbojt
      dbopi2ndc(i1,k1,2+nco+1)=dbodc(ncubo,k1,2-ihl)*dbopi2dsbojt

      end do
      nco=nco+1
      end do

   10 continue

      do i1=1,na
      abo(i1)=zero
      end do
*     do i1=1,na
*     do i2=1,ia(i1,2)
*     iob=ia(i1,2+i2)
*     ncubo=nubon2(i1,i2)
*     abo(i1)=abo(i1)+bo(ncubo)
*     end do
*     end do
      do i1=1,nbon
      j1=ib(i1,2)
      j2=ib(i1,3)
      abo(j1)=abo(j1)+bo(i1)
      if (j1.ne.j2) abo(j2)=abo(j2)+bo(i1)
      end do

   15 continue
      return
      end
********************************************************************** 
********************************************************************** 

      subroutine lonpar

********************************************************************** 
      include 'cbka.blk'
      include 'cbkabo.blk'
      include 'cbkconst.blk'
      include 'cbkd.blk'
      include 'cbkdcell.blk'
      include 'cbkenergies.blk'
      include 'cbkff.blk'
      include 'cbkia.blk'
      include 'cbkidbo.blk'
      include 'cbklonpar.blk'
      include 'cbknmp.blk'
      include 'cbknubon2.blk'
      include 'control.blk'
      include 'small.blk'
      if (ndebug.eq.1) then
      open (65,file='fort.65',status='unknown',access='append')
      write (65,*) 'In lonpar'
      call timer(65)
      close (65)
      end if
**********************************************************************
*                                                                    *
*     Calculate lone pair energy and first derivatives               *
*                                                                    *
**********************************************************************
      elp=zero
      do i1=1,na
**********************************************************************
*                                                                    *
*     Determine number of lone pairs on atoms
*                                                                    *
**********************************************************************
      ity=ia(i1,1)
      voptlp=0.50*(stlp(ity)-aval(ity))
      vlp(i1)=zero
      vund=abo(i1)-stlp(ity)
      vlph=2.0*int(vund/2.0)
      vlpex=vund-vlph
      vp16h=vpar(16)-1.0

      expvlp=exp(-vpar(16)*(2.0+vlpex)*(2.0+vlpex))
      dvlpdsbo(i1)=-vpar(16)*2.0*(2.0+vlpex)*expvlp
      vlp(i1)=expvlp-int(vund/2.0)
*     expvlp=exp(-vpar(16)*(2.0+vlpex))
*     dvlpdsbo(i1)=-vpar(16)*expvlp
*     expvlp=exp(-6.0*((-0.50*vlpex)**vpar(16)))
*     vlp(i1)=(1.0-expvlp)-int(vund/2.0)
*     dvlpdsbo(i1)=-0.5*6.0*vpar(16)*((-0.5*vlpex)**vp16h)*
*    $expvlp
**********************************************************************
*                                                                    *
*     Calculate lone pair energy                                     *
*                                                                    *
**********************************************************************
      diffvlp=voptlp-vlp(i1)
      exphu1=exp(-75.0*diffvlp)
      hulp1=1.0/(1.0+exphu1)
      elph=vlp1(ity)*diffvlp*hulp1
*     elph=vlp1(ity)*diffvlp
      delpdvlp=-vlp1(ity)*hulp1-vlp1(ity)*diffvlp*hulp1*hulp1*
     $75.0*exphu1
      elp=elp+elph
      delpdsbo=delpdvlp*dvlpdsbo(i1)
**********************************************************************
*                                                                    *
*     Calculate first derivative of lone pair energy to              *
*     cartesian coordinates                                          *
*                                                                    *
**********************************************************************
      if (icpres.eq.0) then
      do i3=1,ia(i1,2)
      iob=ia(i1,2+i3)
      ncubo=nubon2(i1,i3)
      do i4=1,idbo1(ncubo)
      ihu=idbo(ncubo,i4)
      do k1=1,3
      d(k1,ihu)=d(k1,ihu)+delpdsbo*dbondc(ncubo,k1,i4)
      end do
      end do
      end do
      else
      do i3=1,ia(i1,2)
      iob=ia(i1,2+i3)
      ncubo=nubon2(i1,i3)
      do i4=1,idbo1(ncubo)
      ihu=idbo(ncubo,i4)
      ix=nmpx(i1,ihu)
      iy=nmpy(i1,ihu)
      iz=nmpz(i1,ihu)
      kcell=14+ix+3*iy+9*iz
      do k1=1,3
      dcell(k1,ihu,kcell)=dcell(k1,ihu,kcell)+
     $delpdsbo*dbondc(ncubo,k1,i4)
      end do
      end do
      end do
      end if

      end do

      return
      end
********************************************************************** 
********************************************************************** 

      subroutine covbon

********************************************************************** 
      include 'cbka.blk'
      include 'cbkabo.blk'
      include 'cbkbo.blk'
      include 'cbkbosi.blk'
      include 'cbkbopi.blk'
      include 'cbkbopi2.blk'
      include 'cbkconst.blk'
      include 'cbkcovbon.blk'
      include 'cbkd.blk'
      include 'cbkdbopi2ndc.blk'
      include 'cbkdbopindc.blk'
      include 'cbkdcell.blk'
      include 'cbkenergies.blk'
      include 'cbkff.blk'
      include 'cbkia.blk'
      include 'cbkidbo.blk'
      include 'cbknmp.blk'
      include 'cbknubon2.blk'
      include 'cbkrbo.blk'
      include 'control.blk'
      include 'small.blk'
********************************************************************** 
*                                                                    *
*     Calculate bond energy and first derivatives                    *
*                                                                    *
********************************************************************** 
      if (ndebug.eq.1) then
      open (65,file='fort.65',status='unknown',access='append')
      write (65,*) 'In covbon'
      call timer(65)
      close (65)
      end if
      eb=0.0d0
      if (nbon.eq.0) return
********************************************************************** 
*                                                                    *
*     Calculate bond energies                                        *
*                                                                    *
********************************************************************** 
      if (ndebug.eq.1) then
      open (65,file='fort.65',status='unknown',access='append')
      write(65,*) 'Bond forces'
      write(65,*) 'nbon = ',nbon
      endif

      do 20 i1=1,nbon

      boa=bo(i1)
*     if (boa.lt.cutof2) goto 20
      j1=ib(i1,2)
      j2=ib(i1,3)
      vsymm=1.0
      if (j1.eq.j2) vsymm=0.5

      bopia=bopi(i1)
      bopi2a=bopi2(i1)
      bosia=boa-bopia-bopi2a
      if (bosia.lt.zero) bosia=zero
      it1=ia(j1,1)
      it2=ia(j2,1)
      ibt=ib(i1,1)
      de1h=vsymm*de1(ibt)
      de2h=vsymm*de2(ibt)
      de3h=vsymm*de3(ibt)

      bopo1=bosia**psp(ibt)
      exphu1=exp(psi(ibt)*(1.0-bopo1))
      ebh=-de1h*bosia*exphu1-de2h*bopia-de3h*bopi2a

      debdbo=-de1h*exphu1+de1h*exphu1*psp(ibt)*psi(ibt)*bopo1
      debdbopi=-de2h
      debdbopi2=-de3h

      eb=eb+ebh

      if (ndebug.eq.1) then
         write(65,*) 'debdbo = ',debdbo,idbo1(i1)
      endif
      if (icpres.eq.0) then
      do i2=1,idbo1(i1)
      ihu=idbo(i1,i2)
      do k1=1,3
      d(k1,ihu)=d(k1,ihu)+debdbo*(dbondc(i1,k1,i2)-dbopindc(i1,k1,i2)-
     $dbopi2ndc(i1,k1,i2))+
     $debdbopi*dbopindc(i1,k1,i2)+
     $debdbopi2*dbopi2ndc(i1,k1,i2)
      if (ndebug.eq.1) then
         if (k1.eq.1) then
            write(65,'(f10.4,f12.8,6f10.4)') 
     $           debdbo,dbondc(i1,k1,i2),dbopindc(i1,k1,i2),
     $           dbopi2ndc(i1,k1,i2),debdbopi,dbopindc(i1,k1,i2),
     $           debdbopi2,dbopi2ndc(i1,k1,i2)
         endif
      endif
      end do
      end do
      else
      do i2=1,idbo1(i1)
      ihu=idbo(i1,i2)
      ix=nmpx(j1,ihu)
      iy=nmpy(j1,ihu)
      iz=nmpz(j1,ihu)
      kcell=14+ix+3*iy+9*iz
      do k1=1,3
      dcell(k1,ihu,kcell)=dcell(k1,ihu,kcell)+debdbo*
     $(dbondc(i1,k1,i2)-dbopindc(i1,k1,i2)-dbopi2ndc(i1,k1,i2))+
     $debdbopi*dbopindc(i1,k1,i2)+
     $debdbopi2*dbopi2ndc(i1,k1,i2)
      end do
      end do
      end if
**********************************************************************
*                                                                    *
*     Stabilisation terminal triple bond                             *
*                                                                    *
**********************************************************************
      if (boa.lt.1.50.or.abs(vpar(11)).lt.0.01) goto 20
      ba=(boa-2.50)*(boa-2.50)
      exphu=exp(-vpar(8)*ba)
      oboa=abo(j1)-boa
      obob=abo(j2)-boa
      exphua1=exp(-vpar(4)*oboa)
      exphub1=exp(-vpar(4)*obob)
      ovoab=abo(j1)-aval(it1)+abo(j2)-aval(it2)
      exphuov=exp(vpar(5)*ovoab)
      hulpov=1.0/(1.0+25.0*exphuov)
      
      estriph=vpar(11)*exphu*hulpov*(exphua1+exphub1)
      eb=eb+estriph

      decobdbo=vpar(4)*vpar(11)*exphu*hulpov*(exphua1+exphub1)
     $-2.0*vpar(11)*vpar(8)*(boa-2.50)*hulpov*exphu*
     $(exphua1+exphub1)
      decobdboua=-25.0*vpar(5)*vpar(11)*exphu*exphuov*hulpov*hulpov*
     $(exphua1+exphub1)-vpar(11)*exphu*vpar(4)*hulpov*exphua1
      decobdboub=-25.0*vpar(5)*vpar(11)*exphu*exphuov*hulpov*hulpov*
     $(exphua1+exphub1)-vpar(11)*exphu*vpar(4)*hulpov*exphub1

      if (icpres.eq.0) then

      do i2=1,idbo1(i1)
      ihu=idbo(i1,i2)
      do k1=1,3
      d(k1,ihu)=d(k1,ihu)+decobdbo*dbondc(i1,k1,i2)
      end do
      end do

      do i3=1,ia(j1,2)
      iob=ia(j1,2+i3)
      ncubo=nubon2(j1,i3)
      do i4=1,idbo1(ncubo)
      ihu=idbo(ncubo,i4)
      do k1=1,3
      d(k1,ihu)=d(k1,ihu)+decobdboua*dbondc(ncubo,k1,i4)
      end do
      end do
      end do

      do i3=1,ia(j2,2)
      iob=ia(j2,2+i3)
      ncubo=nubon2(j2,i3)
      do i4=1,idbo1(ncubo)
      ihu=idbo(ncubo,i4)
      do k1=1,3
      d(k1,ihu)=d(k1,ihu)+decobdboub*dbondc(ncubo,k1,i4)
      end do
      end do
      end do

      else

      do i2=1,idbo1(i1)
      ihu=idbo(i1,i2)
      ix=nmpx(j1,ihu)
      iy=nmpy(j1,ihu)
      iz=nmpz(j1,ihu)
      kcell=14+ix+3*iy+9*iz
      do k1=1,3
      dcell(k1,ihu,kcell)=dcell(k1,ihu,kcell)+
     $decobdbo*dbondc(i1,k1,i2)
      end do
      end do

      do i3=1,ia(j1,2)
      iob=ia(j1,2+i3)
      ncubo=nubon2(j1,i3)
      do i4=1,idbo1(ncubo)
      ihu=idbo(ncubo,i4)
      ix=nmpx(j1,ihu)
      iy=nmpy(j1,ihu)
      iz=nmpz(j1,ihu)
      kcell=14+ix+3*iy+9*iz
      do k1=1,3
      dcell(k1,ihu,kcell)=dcell(k1,ihu,kcell)+
     $decobdboua*dbondc(ncubo,k1,i4)
      end do
      end do
      end do

      do i3=1,ia(j2,2)
      iob=ia(j2,2+i3)
      ncubo=nubon2(j2,i3)
      do i4=1,idbo1(ncubo)
      ihu=idbo(ncubo,i4)
      ix=nmpx(j1,ihu)
      iy=nmpy(j1,ihu)
      iz=nmpz(j1,ihu)
      kcell=14+ix+3*iy+9*iz
      do k1=1,3
      dcell(k1,ihu,kcell)=dcell(k1,ihu,kcell)+
     $decobdboub*dbondc(ncubo,k1,i4)
      end do
      end do
      end do

      end if
********************************************************************** 
*                                                                    *
*     Calculate penalty for lone pairs sharing a bond                *
*                                                                    *
********************************************************************** 
*     elpbh=de2(ibt)*(2.0-boa)*boa*vlp(j1)*vlp(j2)
*     write (65,'(2i4,8f12.4)')j1,j2,boa,vlp(j1),vlp(j2),elpbh
*     delpbdbo=-de2(ibt)*vlp(j1)*vlp(j2)*boa+de2(ibt)*vlp(j1)*
*    $vlp(j2)*(2.0-boa)
*     delpbdvlp1=de2(ibt)*(2.0-boa)*boa*vlp(j2)
*     delpbdvlp2=de2(ibt)*(2.0-boa)*boa*vlp(j1)
*     delpbdsbo1=delpbdvlp1*dvlpdsbo(j1)
*     delpbdsbo2=delpbdvlp2*dvlpdsbo(j2)
*     eb=eb+elpbh

*     do i2=1,idbo1(i1)
*     ihu=idbo(i1,i2)
*     do k1=1,3
*     d(k1,ihu)=d(k1,ihu)+delpbdbo*dbondc(i1,k1,i2)
*     end do
*     end do

*     do i3=1,ia(j1,2)
*     iob=ia(j1,2+i3)
*     ncubo=nubon2(j1,i3)
*     do i4=1,idbo1(ncubo)
*     ihu=idbo(ncubo,i4)
*     do k1=1,3
*     d(k1,ihu)=d(k1,ihu)+delpbdsbo1*dbondc(ncubo,k1,i4)
*     end do
*     end do
*     end do

*     do i3=1,ia(j2,2)
*     iob=ia(j2,2+i3)
*     ncubo=nubon2(j2,i3)
*     do i4=1,idbo1(ncubo)
*     ihu=idbo(ncubo,i4)
*     do k1=1,3
*     d(k1,ihu)=d(k1,ihu)+delpbdsbo2*dbondc(ncubo,k1,i4)
*     end do
*     end do
*     end do

   20 continue

      if (ndebug.eq.1) then
      close (65)
      endif

      return
      end
********************************************************************** 
********************************************************************** 

      subroutine ovcor

********************************************************************** 
      include 'cbka.blk'
      include 'cbkabo.blk'
      include 'cbkbo.blk'
      include 'cbkbopi.blk'
      include 'cbkbopi2.blk'
      include 'cbkconst.blk'
      include 'cbkd.blk'
      include 'cbkdbopi2ndc.blk'
      include 'cbkdbopindc.blk'
      include 'cbkdcell.blk'
      include 'cbkenergies.blk'
      include 'cbkff.blk'
      include 'cbkia.blk'
      include 'cbkidbo.blk'
      include 'cbklonpar.blk'
      include 'cbknmp.blk'
      include 'cbknubon2.blk'
      include 'cbkrbo.blk'
      include 'control.blk'
      include 'small.blk'
********************************************************************** 
*                                                                    *
*     Calculate atom energy                                          *
*     Correction for over- and undercoordinated atoms                *
*                                                                    *
********************************************************************** 
      dimension vlptemp(nat)
      if (ndebug.eq.1) then
      open (65,file='fort.65',status='unknown',access='append')
      write (65,*) 'In ovcor'
      call timer(65)
      close (65)
      end if
      do i1=1,na
      ity1=ia(i1,1)
      vlptemp(i1)=vlp(i1)
      if (amas(ity1).gt.21.0) vlptemp(i1)=0.50*(stlp(ity1)-aval(ity1))  !Only for 1st-row elements
      end do
   25 ea=zero
      eaot=zero
      eaut=zero

      do 30 i1=1,na
      ity1=ia(i1,1)
      dfvl=1.0                         
      if (amas(ity1).gt.21.0) dfvl=0.0  !Only for 1st-row elements
********************************************************************** 
*                                                                    *
*     Calculate overcoordination energy                              *
*     Valency is corrected for lone pairs                            *
*                                                                    *
********************************************************************** 
      voptlp=0.50*(stlp(ity1)-aval(ity1))
      diffvlph=dfvl*(voptlp-vlptemp(i1))
********************************************************************** 
*                                                                    *
*     Determine coordination neighboring atoms                       *
*                                                                    *
********************************************************************** 
      sumov=0.0
      sumov2=0.0
      do i3=1,ia(i1,2)
      iat2=ia(i1,2+i3)
      ity2=ia(iat2,1)
      ncubo=nubon2(i1,i3)
      ibt=ib(ncubo,1)
      voptlp2=0.50*(stlp(ity2)-aval(ity2))
      diffvlp2=dfvl*(voptlp2-vlptemp(iat2))
      sumov=sumov+(bopi(ncubo)+bopi2(ncubo))*
     $(abo(iat2)-aval(ity2)-diffvlp2)
      sumov2=sumov2+vover(ibt)*de1(ibt)*bo(ncubo)
      end do

      exphu1=exp(vpar(32)*sumov)
      vho=1.0/(1.0+vpar(33)*exphu1)
      diffvlp=diffvlph*vho
      
      vov1=abo(i1)-aval(ity1)-diffvlp
      dvov1dsumov=diffvlph*vpar(32)*vpar(33)*vho*vho*exphu1
      exphuo=exp(vovun(ity1)*vov1)
      hulpo=1.0/(1.0+exphuo)

      hulpp=(1.0/(vov1+aval(ity1)+1e-8))

      eah=sumov2*hulpp*hulpo*vov1
      deadvov1=-sumov2*hulpp*hulpp*vov1*hulpo+
     $sumov2*hulpp*hulpo-sumov2*hulpp*vov1*vovun(ity1)*
     $hulpo*hulpo*exphuo
      ea=ea+eah

********************************************************************** 
*                                                                    *
*     Calculate first derivative of overcoordination energy to       *
*     cartesian coordinates                                          *
*                                                                    *
********************************************************************** 
      if (icpres.eq.0) then

      do i3=1,ia(i1,2)
      iob=ia(i1,2+i3)
      ncubo=nubon2(i1,i3)
      ibt=ib(ncubo,1)
      deadbo=vover(ibt)*de1(ibt)*hulpp*hulpo*vov1
      do i4=1,idbo1(ncubo)
      ihu=idbo(ncubo,i4)
      do k1=1,3
      d(k1,ihu)=d(k1,ihu)+deadvov1*(1.0+dfvl*vho*dvlpdsbo(i1))*
     $dbondc(ncubo,k1,i4)+deadbo*dbondc(ncubo,k1,i4)
      end do
      end do
      end do
 
      do i2=1,ia(i1,2)
 
      iat2=ia(i1,2+i2)
      ity2=ia(iat2,1)
      nbosa=nubon2(i1,i2)
      deadvov2=deadvov1*dvov1dsumov*(bopi(nbosa)+bopi2(nbosa))
 
      voptlp2=0.50*(stlp(ity2)-aval(ity2))
      diffvlp2=dfvl*(voptlp2-vlptemp(iat2))
      deadpibo=deadvov1*dvov1dsumov*(abo(iat2)-aval(ity2)-diffvlp2)
 
      do i4=1,idbo1(nbosa)
      ihu=idbo(nbosa,i4)
      do k1=1,3
      d(k1,ihu)=d(k1,ihu)+deadpibo*(dbopindc(nbosa,k1,i4)+
     $dbopi2ndc(nbosa,k1,i4))
      end do
      end do
 
      do i3=1,ia(iat2,2)
      iob=ia(iat2,2+i3)
      ncubo=nubon2(iat2,i3)
      do i4=1,idbo1(ncubo)
      ihu=idbo(ncubo,i4)
      do k1=1,3
      d(k1,ihu)=d(k1,ihu)+deadvov2*(1.0+dfvl*dvlpdsbo(iat2))*
     $dbondc(ncubo,k1,i4)
      end do
      end do
      end do
 
      end do

      else

      do i3=1,ia(i1,2)
      iob=ia(i1,2+i3)
      ncubo=nubon2(i1,i3)
      ibt=ib(ncubo,1)
      deadbo=vover(ibt)*de1(ibt)*hulpp*hulpo*vov1
      do i4=1,idbo1(ncubo)
      ihu=idbo(ncubo,i4)
      ix=nmpx(i1,ihu)
      iy=nmpy(i1,ihu)
      iz=nmpz(i1,ihu)
      kcell=14+ix+3*iy+9*iz
      do k1=1,3
      dcell(k1,ihu,kcell)=dcell(k1,ihu,kcell)+deadvov1*
     $(1.0+dfvl*vho*dvlpdsbo(i1))*
     $dbondc(ncubo,k1,i4)+deadbo*dbondc(ncubo,k1,i4)
      end do
      end do
      end do

      do i2=1,ia(i1,2)

      iat2=ia(i1,2+i2)
      ity2=ia(iat2,1)
      nbosa=nubon2(i1,i2)
      deadvov2=deadvov1*dvov1dsumov*(bopi(nbosa)+bopi2(nbosa))

      voptlp2=0.50*(stlp(ity2)-aval(ity2))
      diffvlp2=dfvl*(voptlp2-vlptemp(iat2))
      deadpibo=deadvov1*dvov1dsumov*(abo(iat2)-aval(ity2)-diffvlp2)

      do i4=1,idbo1(nbosa)
      ihu=idbo(nbosa,i4)
      ix=nmpx(i1,ihu)
      iy=nmpy(i1,ihu)
      iz=nmpz(i1,ihu)
      kcell=14+ix+3*iy+9*iz
      do k1=1,3
      dcell(k1,ihu,kcell)=dcell(k1,ihu,kcell)+deadpibo*
     $(dbopindc(nbosa,k1,i4)+dbopi2ndc(nbosa,k1,i4))
      end do
      end do

      do i3=1,ia(iat2,2)
      iob=ia(iat2,2+i3)
      ncubo=nubon2(iat2,i3)
      do i4=1,idbo1(ncubo)
      ihu=idbo(ncubo,i4)
      ix=nmpx(i1,ihu)
      iy=nmpy(i1,ihu)
      iz=nmpz(i1,ihu)
      kcell=14+ix+3*iy+9*iz
      do k1=1,3
      dcell(k1,ihu,kcell)=dcell(k1,ihu,kcell)+deadvov2*
     $(1.0+dfvl*dvlpdsbo(iat2))*dbondc(ncubo,k1,i4)
      end do
      end do
      end do

      end do
      end if

********************************************************************** 
*                                                                    *
*     Calculate undercoordination energy                             *
*                                                                    *
********************************************************************** 
      if (valp1(ity1).lt.zero) goto 30  !skip undercoordination
      exphu2=exp(vpar(10)*sumov)
      vuhu1=1.0+vpar(9)*exphu2
      hulpu2=1.0/vuhu1

      exphu3=-exp(vpar(7)*vov1)
      hulpu3=-(1.0+exphu3)

      dise2=valp1(ity1)
      exphuu=exp(-vovun(ity1)*vov1)
      hulpu=1.0/(1.0+exphuu)
      eahu=dise2*hulpu*hulpu2*hulpu3
      deaudvov1=dise2*hulpu2*vovun(ity1)*hulpu*hulpu*exphuu*hulpu3-
     $dise2*hulpu*hulpu2*vpar(7)*exphu3
      ea=ea+eahu
      deaudsumov=-dise2*hulpu*vpar(9)*vpar(10)*hulpu3*exphu2*
     $hulpu2*hulpu2

********************************************************************** 
*                                                                    *
*     Calculate first derivative of atom energy to cartesian         *
*     coordinates                                                    *
*                                                                    *
********************************************************************** 
      if (icpres.eq.0) then

      do i3=1,ia(i1,2)
      iob=ia(i1,2+i3)
      ncubo=nubon2(i1,i3)
      do i4=1,idbo1(ncubo)
      ihu=idbo(ncubo,i4)
      do k1=1,3
      d(k1,ihu)=d(k1,ihu)+deaudvov1*(1.0+dfvl*vho*dvlpdsbo(i1))*
     $dbondc(ncubo,k1,i4)
      end do
      end do
      end do
 
      do i2=1,ia(i1,2)
 
      iat2=ia(i1,2+i2)
      ity2=ia(iat2,1)
      nbosa=nubon2(i1,i2)
      deadvov2=(deaudsumov+dvov1dsumov*deaudvov1)*
     $(bopi(nbosa)+bopi2(nbosa))
 
      voptlp2=0.50*(stlp(ity2)-aval(ity2))
      diffvlp2=dfvl*(voptlp2-vlptemp(iat2))
      deadpibo1=(dvov1dsumov*deaudvov1+deaudsumov)*
     $(abo(iat2)-aval(ity2)-diffvlp2)
 
      do i4=1,idbo1(nbosa)
      ihu=idbo(nbosa,i4)
      do k1=1,3
      d(k1,ihu)=d(k1,ihu)+deadpibo1*
     $(dbopindc(nbosa,k1,i4)+dbopi2ndc(nbosa,k1,i4))
      end do
      end do
 
      do i3=1,ia(iat2,2)
      iob=ia(iat2,2+i3)
      ncubo=nubon2(iat2,i3)
      do i4=1,idbo1(ncubo)
      ihu=idbo(ncubo,i4)
      do k1=1,3
      d(k1,ihu)=d(k1,ihu)+deadvov2*(1.0+dfvl*dvlpdsbo(iat2))*
     $dbondc(ncubo,k1,i4)
      end do
      end do
      end do
 
      end do

      else

      do i3=1,ia(i1,2)
      iob=ia(i1,2+i3)
      ncubo=nubon2(i1,i3)
      do i4=1,idbo1(ncubo)
      ihu=idbo(ncubo,i4)
      ix=nmpx(i1,ihu)
      iy=nmpy(i1,ihu)
      iz=nmpz(i1,ihu)
      kcell=14+ix+3*iy+9*iz
      do k1=1,3
      dcell(k1,ihu,kcell)=dcell(k1,ihu,kcell)+deaudvov1*
     $(1.0+dfvl*vho*dvlpdsbo(i1))*dbondc(ncubo,k1,i4)
      end do
      end do
      end do

      do i2=1,ia(i1,2)

      iat2=ia(i1,2+i2)
      ity2=ia(iat2,1)
      nbosa=nubon2(i1,i2)
      deadvov2=(deaudsumov+dvov1dsumov*deaudvov1)*
     $(bopi(nbosa)+bopi2(nbosa))

      voptlp2=0.50*(stlp(ity2)-aval(ity2))
      diffvlp2=dfvl*(voptlp2-vlptemp(iat2))
      deadpibo1=(dvov1dsumov*deaudvov1+deaudsumov)*
     $(abo(iat2)-aval(ity2)-diffvlp2)

      do i4=1,idbo1(nbosa)
      ihu=idbo(nbosa,i4)
      ix=nmpx(i1,ihu)
      iy=nmpy(i1,ihu)
      iz=nmpz(i1,ihu)
      kcell=14+ix+3*iy+9*iz
      do k1=1,3
      dcell(k1,ihu,kcell)=dcell(k1,ihu,kcell)+deadpibo1*
     $(dbopindc(nbosa,k1,i4)+dbopi2ndc(nbosa,k1,i4))
      end do
      end do

      do i3=1,ia(iat2,2)
      iob=ia(iat2,2+i3)
      ncubo=nubon2(iat2,i3)
      do i4=1,idbo1(ncubo)
      ihu=idbo(ncubo,i4)
      ix=nmpx(i1,ihu)
      iy=nmpy(i1,ihu)
      iz=nmpz(i1,ihu)
      kcell=14+ix+3*iy+9*iz
      do k1=1,3
      dcell(k1,ihu,kcell)=dcell(k1,ihu,kcell)+deadvov2*
     $(1.0+dfvl*dvlpdsbo(iat2))*dbondc(ncubo,k1,i4)
      end do
      end do
      end do

      end do

      end if

   30 continue
 
**********************************************************************
*                                                                    *
*     Calculate correction for MgH                                   *
*                                                                    *
**********************************************************************
*     elp=zero
*     do 39 i1=1,na
*     ity1=ia(i1,1)
*     vov4=abo(i1)-aval(ity1)
*
*     do i2=1,ia(i1,2)
*     iat2=ia(i1,2+i2)
*     nbohu=nubon2(i1,i2)
*
*     ibt=ib(nbohu,1)
*     vc2=vuncor(ibt)
*     elph=zero
*     deahu2dbo=zero
*     deahu2dsbo=zero
*     vov3=bo(nbohu)-vov4-vpar(14)*(vov4**4)
*     if (vov3.gt.1.0) then
*     elph=vc2*(vov3-1.0)*(vov3-1.0)
*     deahu2dbo=2.0*vc2*(vov3-1.0)
*     deahu2dsbo=2.0*vc2*(vov3-1.0)*(-1.0-
*    $4.0*vpar(14)*(vov4**3))
*     end if
*
*     elp=elp+elph
*
*     do i3=1,idbo1(nbohu)
*     ihu=idbo(nbohu,i3)
*     do k1=1,3
*     d(k1,ihu)=d(k1,ihu)+deahu2dbo*dbondc(nbohu,k1,i3)
*     end do
*     end do
*
*     do i3=1,ia(i1,2)
*     iob=ia(i1,2+i3)
*     ncubo=nubon2(i1,i3)
*     do i4=1,idbo1(ncubo)
*     ihu=idbo(ncubo,i4)
*     do k1=1,3
*     d(k1,ihu)=d(k1,ihu)+deahu2dsbo*dbondc(ncubo,k1,i4)
*     end do
*     end do
*     end do
*
*     end do
*
*  39 continue
**********************************************************************
*                                                                    *
*     Calculate correction for C2                                    *
*                                                                    *
**********************************************************************
      if (abs(vpar(6)).gt.0.001) then
      do 40 i1=1,na
      ity1=ia(i1,1)
      vov4=abo(i1)-aval(ity1)
 
      do i2=1,ia(i1,2)
      iat2=ia(i1,2+i2)
      nbohu=nubon2(i1,i2)
 
      ibt=ib(nbohu,1)
      elph=zero
      deahu2dbo=zero
      deahu2dsbo=zero
      vov3=bo(nbohu)-vov4-0.040*(vov4**4)
      if (vov3.gt.3.0) then
      elph=vpar(6)*(vov3-3.0)*(vov3-3.0)
      deahu2dbo=2.0*vpar(6)*(vov3-3.0)
      deahu2dsbo=2.0*vpar(6)*(vov3-3.0)*(-1.0-
     $0.16*(vov4**3))
      end if
 
      elp=elp+elph
 
      if (icpres.eq.0) then
      do i3=1,idbo1(nbohu)
      ihu=idbo(nbohu,i3)
      do k1=1,3
      d(k1,ihu)=d(k1,ihu)+deahu2dbo*dbondc(nbohu,k1,i3)
      end do
      end do
 
      do i3=1,ia(i1,2)
      iob=ia(i1,2+i3)
      ncubo=nubon2(i1,i3)
      do i4=1,idbo1(ncubo)
      ihu=idbo(ncubo,i4)
      do k1=1,3
      d(k1,ihu)=d(k1,ihu)+deahu2dsbo*dbondc(ncubo,k1,i4)
      end do
      end do
      end do

      else

      do i3=1,idbo1(nbohu)
      ihu=idbo(nbohu,i3)
      ix=nmpx(i1,ihu)
      iy=nmpy(i1,ihu)
      iz=nmpz(i1,ihu)
      kcell=14+ix+3*iy+9*iz
      do k1=1,3
      dcell(k1,ihu,kcell)=dcell(k1,ihu,kcell)+
     $deahu2dbo*dbondc(nbohu,k1,i3)
      end do
      end do
 
      do i3=1,ia(i1,2)
      iob=ia(i1,2+i3)
      ncubo=nubon2(i1,i3)
      do i4=1,idbo1(ncubo)
      ihu=idbo(ncubo,i4)
      ix=nmpx(i1,ihu)
      iy=nmpy(i1,ihu)
      iz=nmpz(i1,ihu)
      kcell=14+ix+3*iy+9*iz
      do k1=1,3
      dcell(k1,ihu,kcell)=dcell(k1,ihu,kcell)+
     $deahu2dsbo*dbondc(ncubo,k1,i4)
      end do
      end do
      end do

      end if
 
      end do
 
   40 continue
      end if

      return
      end
**********************************************************************
********************************************************************** 

      subroutine molen

********************************************************************** 
      include 'cbka.blk'
      include 'cbkbo.blk'
      include 'cbkconst.blk'
      include 'cbkd.blk'
      include 'cbkenergies.blk'
      include 'cbkff.blk'
      include 'cbkia.blk'
      include 'cbkidbo.blk'
      include 'cbknmolat.blk'
      include 'cbknubon2.blk'
      include 'control.blk'
      include 'small.blk'

********************************************************************** 
*                                                                    *
*     Calculate molecular energy and first derivatives               *
*     Only used to prevent creating virtual electrons                *
*                                                                    *
********************************************************************** 
      if (ndebug.eq.1) then
      open (65,file='fort.65',status='unknown',access='append')
      write (65,*) 'In molen'
      call timer(65)
      close (65)
      end if
      emol=zero
      return
      do i1=1,nmolo

      enelm=0.0
      do i2=1,na
      if (ia(i2,3+mbond).eq.i1) then
      it1=ia(i2,1)
      enelm=enelm+aval(it1)
      end if
      end do

      na1m=nmolat(i1,1)

      enelm=2*int(enelm*0.50)
*     enelm=elmol(i1)
      bomsum=zero
      do i2=1,na1m
      ihu=nmolat(i1,i2+1)
      do i3=1,ia(ihu,2)
      ihu2=nubon2(ihu,i3)
      bomsum=bomsum+bo(ihu2)
      end do
      end do
      diff=(bomsum-enelm)
      exphu=exp(-vpar(37)*diff)
      exphu2=1.0/(1.0+15.0*exphu)
      emolh=zero
      demoldsbo=zero
      emolh=vpar(38)*exphu2
      emol=emol+emolh
      demoldsbo=vpar(38)*vpar(37)*15.0*exphu2*exphu2*exphu

      do i2=1,na1m
      ihu1=nmolat(i1,i2+1)
      do i3=1,ia(ihu1,2)
      iob=ia(ihu1,2+i3)
      ncubo=nubon2(ihu1,i3)
      do i4=1,idbo1(ncubo)
      ihu=idbo(ncubo,i4)
      do k1=1,3
      d(k1,ihu)=d(k1,ihu)+demoldsbo*dbondc(ncubo,k1,i4)
      end do
      end do
      end do
      end do


      end do


      return
      end
********************************************************************** 
********************************************************************** 

      subroutine valang

********************************************************************** 
      include 'cbka.blk'
      include 'cbkabo.blk'
      include 'cbkbo.blk'
      include 'cbkbopi.blk'
      include 'cbkbopi2.blk'
      include 'cbkconst.blk'
      include 'cbkd.blk'
      include 'cbkdbopi2ndc.blk'
      include 'cbkdbopindc.blk'
      include 'cbkdcell.blk'
      include 'cbkdhdc.blk'
      include 'cbkenergies.blk'
      include 'cbkff.blk'
      include 'cbkh.blk'
      include 'cbkia.blk'
      include 'cbkidbo.blk'
      include 'cbknmp.blk'
      include 'cbknubon2.blk'
      include 'cbkvalence.blk'
      include 'control.blk'
      include 'valang.blk'
      dimension j(3)
********************************************************************** 
*                                                                    *
*     Calculate valency angle energies and first derivatives         *
*                                                                    *
********************************************************************** 
      if (ndebug.eq.1) then
      open (65,file='fort.65',status='unknown',access='append')
      write (65,*) 'In valang'
      call timer(65)
      close (65)
      end if
*     eco=0.0
      ev=0.0
      ecoa=0.0
      if (nval.eq.0) return

      do 10 i1=1,nval
      ity=iv(i1,1)
      j(1)=iv(i1,2)
      j(2)=iv(i1,3)
      j(3)=iv(i1,4)

      la=iv(i1,5)
      lb=iv(i1,6)
      boa=bo(la)-cutof2
      bob=bo(lb)-cutof2
      if (boa.lt.zero.or.bob.lt.zero) goto 10

      hl=h(i1)     ! Calculated earlier in routine calval
********************************************************************** 
*                                                                    *
*     Calculate valency angle energy                                 *
*                                                                    *
********************************************************************** 
      nbocen=ia(j(2),2)
      sbo2=0.0
      vmbo=1.0
     
      do i2=1,nbocen
      ibv=nubon2(j(2),i2)
      vmbo=vmbo*exp(-bo(ibv)**8)
      sbo2=sbo2+bopi(ibv)+bopi2(ibv)
      end do

      ity2=ia(j(2),1)
*     exbo=abo(j(2))-stlp(ia(j(2),1))
      exbo=abo(j(2))-valf(ity2)
*     if (exbo.gt.zero) exbo=zero
*     expov=exp(vka8(ity)*exbo)
*     expov2=exp(-vpar(13)*exbo)
*     htov1=2.0+expov2
*     htov2=1.0+expov+expov2
*     evboadj=htov1/htov2
      evboadj=1.0
      expun=exp(-vkac(ity)*exbo)
      expun2=exp(vpar(15)*exbo)
      htun1=2.0+expun2
      htun2=1.0+expun+expun2
      evboadj2=vval4(ity2)-(vval4(ity2)-1.0)*htun1/htun2
********************************************************************** 
*                                                                    *
*     Calculate number of lone pairs                                 *
*                                                                    *
********************************************************************** 
      dsbo2dvlp=(1.0-vmbo)
      vlpadj=zero
      exlp1=abo(j(2))-stlp(ia(j(2),1))
      exlp2=2.0*int(exlp1/2.0)
      exlp=exlp1-exlp2
      if (exlp.lt.zero) then
      expvlp=exp(-vpar(16)*(2.0+exlp)*(2.0+exlp))
      vlpadj=expvlp-int(exlp1/2.0)
      dsbo2dvlp=(1.0-vmbo)*(1.0-vpar(34)*2.0*
     $(2.0+exlp)*vpar(16)*expvlp)
      end if

      sbo2=sbo2+(1.0-vmbo)*(-exbo-vpar(34)*vlpadj)
      dsbo2dvmbo=exbo+vpar(34)*vlpadj
*     sbo2=sbo2-exbo-vpar(34)*vlpadj

      sbo2h=sbo2
      powv=vpar(17)
      if (sbo2.le.0.0) sbo2h=0.0
      if (sbo2.gt.0.0.and.sbo2.le.1.0) sbo2h=sbo2**powv
      if (sbo2.gt.1.0.and.sbo2.lt.2.0) sbo2h=2.0-(2.0-sbo2)**powv
      if (sbo2.gt.2.0) sbo2h=2.0
      thba=th0(ity)
      expsbo=exp(-vpar(18)*(2.0-sbo2h))
      thetao=180.0-thba*(1.0-expsbo)

      thetao=thetao*dgrrdn
      thdif=(thetao-hl)
      thdi2=thdif*thdif
      dthsbo=dgrrdn*thba*vpar(18)*expsbo
      if (sbo2.lt.0.0) dthsbo=zero
      if (sbo2.gt.0.0.and.sbo2.le.1.0) 
     $dthsbo=powv*(sbo2**(powv-1.0))*dgrrdn*thba*vpar(18)*expsbo
      if (sbo2.gt.1.0.and.sbo2.lt.2.0) 
     $dthsbo=powv*((2.0-sbo2)**(powv-1.0))*dgrrdn*thba*vpar(18)*expsbo
      if (sbo2.gt.2.0) dthsbo=zero

      exphu=vka(ity)*exp(-vka3(ity)*thdi2)
      exphu2=vka(ity)-exphu
      boap=boa**vval2(ity)
      boap2=boa**(vval2(ity)-1.0)
      bobp=bob**vval2(ity)
      bobp2=bob**(vval2(ity)-1.0)
      exa=exp(-vval1(ity2)*boap)
      exb=exp(-vval1(ity2)*bobp)
      dexadboa=vval2(ity)*vval1(ity2)*exa*boap2
      dexbdbob=vval2(ity)*vval1(ity2)*exb*bobp2
      exa2=(1.0-exa)
      exb2=(1.0-exb)

      evh=evboadj2*evboadj*exa2*exb2*exphu2
      devdlb=evboadj2*evboadj*dexbdbob*exa2*exphu2
      devdla=evboadj2*evboadj*dexadboa*exb2*exphu2
      devdsbo=2.0*evboadj2*evboadj*dthsbo*exa2*exb2*
     $vka3(ity)*thdif*exphu
      devdh=-2.0*evboadj2*evboadj*exa2*exb2*vka3(ity)*thdif*exphu

      devdsbo2=
     $evboadj*exa2*exb2*exphu2*(vval4(ity2)-1.0)*(-vpar(15)*expun2/htun2
     $+htun1*(vpar(15)*expun2-vkac(ity)*expun)/(htun2*htun2))

*     devdsbo2=-evboadj2*exa2*exb2*exphu2*(vpar(13)*expov2/htov2+
*    $htov1*(vka8(ity)*expov-vpar(13)*expov2)/(htov2*htov2))+
*    $evboadj*exa2*exb2*exphu2*(vpar(14)-1.0)*(-vpar(15)*expun2/htun2
*    $+htun1*(vpar(15)*expun2-vkac(ity)*expun)/(htun2*htun2))



      ev=ev+evh
*     write (64,'(4i8,18f8.2)')mdstep,j(1),j(2),j(3),sbo2,sbo2h,
*    $thetao*rdndgr,hl*rdndgr,bo(la),bo(lb),bopi(la),
*    $vlp(j(2)),exbo,vlpadj,vmbo,evh,ev
********************************************************************** 
*                                                                    *
*     Calculate penalty for two double bonds in valency angle        *
*                                                                    *
********************************************************************** 
      exbo=abo(j(2))-aval(ia(j(2),1))
      expov=exp(vpar(22)*exbo)
      expov2=exp(-vpar(21)*exbo)
      htov1=2.0+expov2
      htov2=1.0+expov+expov2
      ecsboadj=htov1/htov2
      exphu1=exp(-vpar(20)*(boa-2.0)*(boa-2.0))
      exphu2=exp(-vpar(20)*(bob-2.0)*(bob-2.0))
      ecoah=vkap(ity)*ecsboadj*exphu1*exphu2
      ecoa=ecoa+ecoah
      decoadboa=-2.0*vpar(20)*ecoah*(boa-2.0)
      decoadbob=-2.0*vpar(20)*ecoah*(bob-2.0)
      decdsbo2=-vkap(ity)*exphu1*exphu2*(vpar(21)*expov2/htov2+htov1*
     $(vpar(22)*expov-vpar(21)*expov2)/(htov2*htov2))
**********************************************************************
*                                                                    *
*     Calculate valency angle conjugation energy                     *
*                                                                    *
**********************************************************************
      unda=abo(j(1))-boa
      ovb=abo(j(2))-valf(ia(j(2),1))
      undc=abo(j(3))-bob
      ba=(boa-1.50)*(boa-1.50)
      bb=(bob-1.50)*(bob-1.50)
      exphua=exp(-vpar(31)*ba)
      exphub=exp(-vpar(31)*bb)
      exphuua=exp(-vpar(39)*unda*unda)
      exphuob=exp(vpar(3)*ovb)
      exphuuc=exp(-vpar(39)*undc*undc)
      hulpob=1.0/(1.0+exphuob)
      ecoah=vka8(ity)*exphua*exphub*exphuua*exphuuc*hulpob
      decodbola=-2.0*vka8(ity)*(boa-1.50)*vpar(31)*exphua*exphub
     $*exphuua*exphuuc*hulpob+vpar(39)*vka8(ity)*exphua*exphub*
     $exphuua*exphuuc*hulpob*2.0*unda
      decodbolb=-2.0*vka8(ity)*(bob-1.50)*vpar(31)*exphua*exphub
     $*exphuua*exphuuc*hulpob+vpar(39)*vka8(ity)*exphua*exphub*
     $exphuua*exphuuc*hulpob*2.0*undc
      decodboua=-2.0*unda*vka8(ity)*vpar(39)*exphua*exphub
     $*exphuua*exphuuc*hulpob
      decodbouc=-2.0*undc*vka8(ity)*vpar(39)*exphua*exphub
     $*exphuua*exphuuc*hulpob
      decodboob=-vka8(ity)*exphua*exphub*exphuua*exphuuc*hulpob*
     $hulpob*vpar(3)*exphuob
*     decodboob=zero
*     decodboua=zero
*     decodbouc=zero
      ecoa=ecoa+ecoah
********************************************************************** 
*                                                                    *
*     Calculate derivative valency energy to cartesian coordinates   *
*                                                                    *
********************************************************************** 
      if (icpres.eq.0) then

      do k1=1,3
      do k2=1,3
      d(k1,j(k2))=d(k1,j(k2))+devdh*dhdc(i1,k1,k2)
      end do
      end do
 
      do i2=1,idbo1(la)
      ihu=idbo(la,i2)
      do k1=1,3
      d(k1,ihu)=d(k1,ihu)+(devdla+decoadboa+decodbola)*
     $dbondc(la,k1,i2)
      end do
      end do
 
      do i2=1,idbo1(lb)
      ihu=idbo(lb,i2)
      do k1=1,3
      d(k1,ihu)=d(k1,ihu)+(devdlb+decoadbob+decodbolb)*
     $dbondc(lb,k1,i2)
      end do
      end do
 
      do i2=1,nbocen
      j5=ia(j(2),2+i2)
      ibv=nubon2(j(2),i2)
      dvmbodbo=-vmbo*8.0*bo(ibv)**7
      do i3=1,idbo1(ibv)
      ihu=idbo(ibv,i3)
      do k1=1,3
      d(k1,ihu)=d(k1,ihu)+(-dsbo2dvlp*devdsbo+devdsbo2+decdsbo2
     $+dvmbodbo*dsbo2dvmbo*devdsbo)*
     $dbondc(ibv,k1,i3)+devdsbo*(dbopindc(ibv,k1,i3)+
     $dbopi2ndc(ibv,k1,i3))
      end do
      end do
      end do
 
      do i2=1,ia(j(1),2)
      j5=ia(j(1),2+i2)
      ibv=nubon2(j(1),i2)
      do i3=1,idbo1(ibv)
      ihu=idbo(ibv,i3)
      do k1=1,3
      d(k1,ihu)=d(k1,ihu)+decodboua*dbondc(ibv,k1,i3)
      end do
      end do
      end do
 
      do i2=1,ia(j(2),2)
      j5=ia(j(2),2+i2)
      ibv=nubon2(j(2),i2)
      do i3=1,idbo1(ibv)
      ihu=idbo(ibv,i3)
      do k1=1,3
      d(k1,ihu)=d(k1,ihu)+decodboob*dbondc(ibv,k1,i3)
      end do
      end do
      end do

      do i2=1,ia(j(3),2)
      j5=ia(j(3),2+i2)
      ibv=nubon2(j(3),i2)
      do i3=1,idbo1(ibv)
      ihu=idbo(ibv,i3)
      do k1=1,3
      d(k1,ihu)=d(k1,ihu)+decodbouc*dbondc(ibv,k1,i3)
      end do
      end do
      end do

      else

      do k1=1,3
      do k2=1,3
      ix=nmpx(j(2),j(k2))
      iy=nmpy(j(2),j(k2))
      iz=nmpz(j(2),j(k2))
      kcell=14+ix+3*iy+9*iz
      dcell(k1,j(k2),kcell)=dcell(k1,j(k2),kcell)+devdh*dhdc(i1,k1,k2)
      end do
      end do

      do i2=1,idbo1(la)
      ihu=idbo(la,i2)
      ix=nmpx(j(2),ihu)
      iy=nmpy(j(2),ihu)
      iz=nmpz(j(2),ihu)
      kcell=14+ix+3*iy+9*iz
      do k1=1,3
      dcell(k1,ihu,kcell)=dcell(k1,ihu,kcell)+
     $(devdla+decoadboa+decodbola)*dbondc(la,k1,i2)
      end do
      end do

      do i2=1,idbo1(lb)
      ihu=idbo(lb,i2)
      ix=nmpx(j(2),ihu)
      iy=nmpy(j(2),ihu)
      iz=nmpz(j(2),ihu)
      kcell=14+ix+3*iy+9*iz
      do k1=1,3
      dcell(k1,ihu,kcell)=dcell(k1,ihu,kcell)+
     $(devdlb+decoadbob+decodbolb)*dbondc(lb,k1,i2)
      end do
      end do

      do i2=1,nbocen
      j5=ia(j(2),2+i2)
      ibv=nubon2(j(2),i2)
      dvmbodbo=-vmbo*8.0*bo(ibv)**7
      do i3=1,idbo1(ibv)
      ihu=idbo(ibv,i3)
      ix=nmpx(j(2),ihu)
      iy=nmpy(j(2),ihu)
      iz=nmpz(j(2),ihu)
      kcell=14+ix+3*iy+9*iz
      do k1=1,3
      dcell(k1,ihu,kcell)=dcell(k1,ihu,kcell)+
     $(-dsbo2dvlp*devdsbo+devdsbo2+decdsbo2+
     $dvmbodbo*dsbo2dvmbo*devdsbo)*
     $dbondc(ibv,k1,i3)+devdsbo*(dbopindc(ibv,k1,i3)+
     $dbopi2ndc(ibv,k1,i3))
      end do
      end do
      end do

      do i2=1,ia(j(1),2)
      j5=ia(j(1),2+i2)
      ibv=nubon2(j(1),i2)
      do i3=1,idbo1(ibv)
      ihu=idbo(ibv,i3)
      ix=nmpx(j(2),ihu)
      iy=nmpy(j(2),ihu)
      iz=nmpz(j(2),ihu)
      kcell=14+ix+3*iy+9*iz
      do k1=1,3
      dcell(k1,ihu,kcell)=dcell(k1,ihu,kcell)+
     $decodboua*dbondc(ibv,k1,i3)
      end do
      end do
      end do

      do i2=1,ia(j(2),2)
      j5=ia(j(2),2+i2)
      ibv=nubon2(j(2),i2)
      do i3=1,idbo1(ibv)
      ihu=idbo(ibv,i3)
      ix=nmpx(j(2),ihu)
      iy=nmpy(j(2),ihu)
      iz=nmpz(j(2),ihu)
      kcell=14+ix+3*iy+9*iz
      do k1=1,3
      dcell(k1,ihu,kcell)=dcell(k1,ihu,kcell)+
     $decodboob*dbondc(ibv,k1,i3)
      end do
      end do
      end do

      do i2=1,ia(j(3),2)
      j5=ia(j(3),2+i2)
      ibv=nubon2(j(3),i2)
      do i3=1,idbo1(ibv)
      ihu=idbo(ibv,i3)
      ix=nmpx(j(2),ihu)
      iy=nmpy(j(2),ihu)
      iz=nmpz(j(2),ihu)
      kcell=14+ix+3*iy+9*iz
      do k1=1,3
      dcell(k1,ihu,kcell)=dcell(k1,ihu,kcell)+
     $decodbouc*dbondc(ibv,k1,i3)
      end do
      end do
      end do

      end if

   10 continue

      return
      end
********************************************************************** 
********************************************************************** 

      subroutine hbond

********************************************************************** 
      include 'cbka.blk'
      include 'cbkbo.blk'
      include 'cbkconst.blk'
      include 'cbkd.blk'
      include 'cbkdcell.blk'
      include 'cbkenergies.blk'
      include 'cbkidbo.blk'
      include 'cbknmp.blk'
      include 'cbksrthb.blk'
      include 'control.blk'
      include 'cbkhbond.blk'
      dimension drda(3),j(3),dvdc(3,3),dargdc(3,3)
      virial=zero
      virx=zero
      viry=zero
      virz=zero
********************************************************************** 
*                                                                    *
*     Calculate hydrogen bond energies and first derivatives         *
*                                                                    *
********************************************************************** 
      if (ndebug.eq.1) then
      open (65,file='fort.65',status='unknown',access='append')
      write (65,*) 'In hbond'
      call timer(65)
      close (65)
      end if
      ehb=zero
      do 10 i1=1,nhb
      ityhb=ihb(i1,1)
      j(1)=ihb(i1,2)
      j(2)=ihb(i1,3)
      j(3)=ihb(i1,4)
      la=ihb(i1,5)
      boa=bo(la)
      call dista2(j(2),j(3),rda,dxm,dym,dzm)
      drda(1)=dxm/rda
      drda(2)=dym/rda
      drda(3)=dzm/rda
      call calvalres (j(1),j(2),j(3),arg,hhb(i1),dvdc,dargdc)
      rhu1=rhb(ityhb)/rda
      rhu2=rda/rhb(ityhb)
      sinhu=sin(hhb(i1)/2.0)
      sin2=sinhu*sinhu
      exphu1=exp(-vhb1(ityhb)*boa)
      exphu2=exp(-vhb2(ityhb)*(rhu1+rhu2-2.0))
      ehbh=(1.0-exphu1)*dehb(ityhb)*exphu2*sin2*sin2*sin2*sin2
      ehb=ehb+ehbh
*     write (65,'(6i4,10f12.4)')i1,ityhb,j(1),j(2),j(3),la,boa,rda,
*    $rdndgr*hhb(i1),1.0-exphu1,exphu2,sin2*sin2,
*    $ehbh,ehb
********************************************************************** 
*                                                                    *
*     Calculate first derivatives                                    *
*                                                                    *
********************************************************************** 
      dehbdbo=vhb1(ityhb)*exphu1*dehb(ityhb)*exphu2*sin2*sin2*
     $sin2*sin2
      dehbdv=(1.0-exphu1)*dehb(ityhb)*exphu2*
     $4.0*sin2*sin2*sin2*sinhu*cos(hhb(i1)/2.0)
      dehbdrda=(1.0-exphu1)*dehb(ityhb)*sin2*sin2*sin2*sin2*
     $vhb2(ityhb)*(rhb(ityhb)/(rda*rda)-1.0/rhb(ityhb))*exphu2

      if (icpres.eq.0) then

      do k1=1,3
      d(k1,j(2))=d(k1,j(2))+dehbdrda*drda(k1)
      d(k1,j(3))=d(k1,j(3))-dehbdrda*drda(k1)
      end do
 
      do k1=1,3
      do k2=1,3
      d(k1,j(k2))=d(k1,j(k2))+dehbdv*dvdc(k1,k2)
      end do
      end do
 
      do i2=1,idbo1(la)
      ihu=idbo(la,i2)
      do k1=1,3
      d(k1,ihu)=d(k1,ihu)+dehbdbo*dbondc(la,k1,i2)
      end do
      end do

      else

      ix=nmpx(j(2),j(3))
      iy=nmpy(j(2),j(3))
      iz=nmpz(j(2),j(3))
      kcell=14+ix+3*iy+9*iz
      do k1=1,3
      dcell(k1,j(2),kcell)=dcell(k1,j(2),kcell)+dehbdrda*drda(k1)
      dcell(k1,j(3),kcell)=dcell(k1,j(3),kcell)-dehbdrda*drda(k1)
      end do
     
      do k1=1,3
      do k2=1,3
      ix=nmpx(j(2),j(k2))
      iy=nmpy(j(2),j(k2))
      iz=nmpz(j(2),j(k2))
      kcell=14+ix+3*iy+9*iz
      dcell(k1,j(k2),kcell)=dcell(k1,j(k2),kcell)+dehbdv*dvdc(k1,k2)
      end do
      end do
  
      do i2=1,idbo1(la)
      ihu=idbo(la,i2)
      ix=nmpx(j(2),ihu)
      iy=nmpy(j(2),ihu)
      iz=nmpz(j(2),ihu)
      kcell=14+ix+3*iy+9*iz
      do k1=1,3
      dcell(k1,ihu,kcell)=dcell(k1,ihu,kcell)+
     $dehbdbo*dbondc(la,k1,i2)
      end do
      end do

      end if

   
   10 continue
      return
      end 

********************************************************************** 
********************************************************************** 

      subroutine torang

********************************************************************** 
      include 'cbka.blk'
      include 'cbkabo.blk'
      include 'cbkbo.blk'
      include 'cbkbopi.blk'
      include 'cbkc.blk'
      include 'cbkconst.blk'
      include 'cbkd.blk'
      include 'cbkdbopindc.blk'
      include 'cbkdcell.blk'
      include 'cbkdhdc.blk'
      include 'cbkdrdc.blk'
      include 'cbkenergies.blk'
      include 'cbkff.blk'
      include 'cbkfftorang.blk'
      include 'cbkh.blk'
      include 'cbkia.blk'
      include 'cbkidbo.blk'
      include 'cbkinit.blk'
      include 'cbknmp.blk'
      include 'cbknubon2.blk'
      include 'cbknvl.blk'
      include 'cbkrbo.blk'
      include 'cbktorang.blk'
      include 'cbktorsion.blk'
      include 'cbktregime.blk'
      include 'cbkvalence.blk'
      include 'cellcoord.blk'
      include 'control.blk'

      DIMENSION  A(3),DRDA(3),DADC(4),DRADC(3,4),DRBDC(3,4),
     $DRCDC(3,4),DHDDC(3,4),DHEDC(3,4),DRVDC(3,4),DTDC(3,4),
     $DNDC(3,4)
      dimension j(4)
********************************************************************** 
*                                                                    *
*     Calculate torsion angle energies and first derivatives         *
*                                                                    *
********************************************************************** 
      if (ndebug.eq.1) then
      open (65,file='fort.65',status='unknown',access='append')
      write (65,*) 'In torang'
      call timer(65)
      close (65)
      end if
      do k1=1,3
      do k2=1,4
      dhddc(k1,k2)=0.0
      dhedc(k1,k2)=0.0
      dradc(k1,k2)=0.0
      drbdc(k1,k2)=0.0
      drcdc(k1,k2)=0.0
      end do
      end do
      et=0.0
      eth12=0.0
      eco=0.0
      dadc(1)=1.0
      dadc(2)=0.0
      dadc(3)=0.0
      dadc(4)=-1.0
      if (ntor.eq.0) return

      do 10 i1=1,ntor
      j(1)=it(i1,2)
      j(2)=it(i1,3)
      j(3)=it(i1,4)
      j(4)=it(i1,5)
      ity=it(i1,1)  
      la=it(i1,6)
      lb=it(i1,7)
      lc=it(i1,8)
      ld=it(i1,9)
      le=it(i1,10)
      boa=bo(la)-cutof2
      bob=bo(lb)-cutof2
      boc=bo(lc)-cutof2
      if (boa.lt.zero.or.bob.lt.zero.or.boc.lt.zero) 
     $goto 10
      r42=0.0
      ivl1=ibsym(la)
      ivl2=ibsym(lb)
      ivl3=ibsym(lc)
      isign1=1
      isign2=1
      isign3=1
      if (j(2).lt.j(1)) isign1=-1
      if (j(3).lt.j(2)) isign2=-1
      if (j(4).lt.j(3)) isign3=-1
      rla=rbo(la)
      rlb=rbo(lb)
      ix1=isign1*nvlx(ivl1)+isign2*nvlx(ivl2)+isign3*nvlx(ivl3)
      iy1=isign1*nvly(ivl1)+isign2*nvly(ivl2)+isign3*nvly(ivl3)
      iz1=isign1*nvlz(ivl1)+isign2*nvlz(ivl2)+isign3*nvlz(ivl3)
 
      a(1)=c(j(1),1)-c(j(4),1)+ix1*tm11
      a(2)=c(j(1),2)-c(j(4),2)+ix1*tm21+iy1*tm22
      a(3)=c(j(1),3)-c(j(4),3)+ix1*tm31+iy1*tm32+iz1*tm33
      r4=sqrt(a(1)*a(1)+a(2)*a(2)+a(3)*a(3))
*     call dista2(j(1),j(4),r4h,a1h,a2h,a3h)
*     if (abs(r4h-r4).gt.0.01) then
*     write (64,'(5i4,10f12.4)')j(1),j(4),
*    $ix1,iy1,iz1,r4,a(1),a(2),a(3),r4h,a1h,a2h,a3h
*     write (64,'(6f12.4)')c(j(1),1),c(j(1),2),c(j(1),3)
*     write (64,'(6f12.4)')c(j(2),1),c(j(2),2),c(j(2),3)
*     write (64,'(6f12.4)')c(j(3),1),c(j(3),2),c(j(3),3)
*     write (64,'(6f12.4)')c(j(4),1),c(j(4),2),c(j(4),3)
*     write (64,'(4i4)')nvlx(ivl1),nvly(ivl1),nvlz(ivl1),isign1
*     write (64,'(4i4)')nvlx(ivl2),nvly(ivl2),nvlz(ivl2),isign2
*     write (64,'(4i4)')nvlx(ivl3),nvly(ivl3),nvlz(ivl3),isign3
*     end if
********************************************************************** 
*                                                                    *
*     Determine torsion angle                                        *
*                                                                    *
********************************************************************** 
      d142=r4*r4
      rla=rbo(la)
      rlb=rbo(lb)
      rlc=rbo(lc)
      coshd=cos(h(ld))
      coshe=cos(h(le))
      sinhd=sin(h(ld))
      sinhe=sin(h(le))
      poem=2.0*rla*rlc*sinhd*sinhe
      poem2=poem*poem
      tel=rla*rla+rlb*rlb+rlc*rlc-d142-2.0*(rla*rlb*coshd-rla*rlc*
     $coshd*coshe+rlb*rlc*coshe)
*     if (poem.lt.1e-20) poem=1e-20
      arg=tel/poem
      if (arg.gt.1.0) arg=1.0
      if (arg.lt.-1.0) arg=-1.0
      arg2=arg*arg
      thg(i1)=acos(arg)*rdndgr
      k1=j(1)
      k2=j(2)
      k3=j(3)
      k4=j(4)
      call dista2(k3,k2,dis,x3,y3,z3)
      y32z32=y3*y3+z3*z3
      wort1=sqrt(y32z32)+1e-6
      wort2=sqrt(y32z32+x3*x3)+1e-6
*     if (wort1.lt.1e-6) wort1=1e-6
*     if (wort2.lt.1e-6) wort2=1e-6
      sinalf=y3/wort1
      cosalf=z3/wort1
      sinbet=x3/wort2
      cosbet=wort1/wort2
      call dista2(k1,k2,dis,x1,y1,z1)
      x1=x1*cosbet-y1*sinalf*sinbet-z1*cosalf*sinbet
      y1=y1*cosalf-z1*sinalf
      wort3=sqrt(x1*x1+y1*y1)+1e-6
*     if (wort3.lt.1e-6) wort3=1e-6
      singam=y1/wort3
      cosgam=x1/wort3
      call dista2(k4,k2,dis,x4,y4,z4)
      x4=x4*cosbet-y4*sinalf*sinbet-z4*cosalf*sinbet
      y4=y4*cosalf-z4*sinalf
      y4=x4*singam-y4*cosgam
      if (y4.gt.0.0) thg(i1)=-thg(i1)
      if (thg(i1).lt.-179.999999d0) thg(i1)=-179.999999d0
      if (thg(i1).gt.179.999999d0) thg(i1)=179.999999d0
      th2=thg(i1)*dgrrdn
********************************************************************** 
*                                                                    *
*     Calculate torsion angle energy                                 *
*                                                                    *
********************************************************************** 
*     exbo1=abo(j(2))-aval(ia(j(2),1))
*     exbo2=abo(j(3))-aval(ia(j(3),1))
      exbo1=abo(j(2))-valf(ia(j(2),1))
      exbo2=abo(j(3))-valf(ia(j(3),1))
      htovt=exbo1+exbo2
      expov=exp(vpar(26)*htovt)
      expov2=exp(-vpar(25)*(htovt))
      htov1=2.0+expov2
      htov2=1.0+expov+expov2
      etboadj=htov1/htov2

      bta=boa
      btb=bob
*     btb2=bob-1.0+etboadj
      btb2=bopi(lb)-1.0+etboadj
      btc=boc
*     bo2t=2.0-btb2
      bo2t=1.0-btb2
      bo2p=bo2t*bo2t
*     bo12=(2.0-bta)*(2.0-bta)
*     bo32=(2.0-btc)*(2.0-btc)
      bocor2=exp(v4(ity)*bo2p)
*     bocort=bocor1+bocor2+bocor3

      hsin=sinhd*sinhe
      ethhulp=0.50*v1(ity)*(1.0+arg)+v2(ity)*bocor2*(1.0-arg2)+
     $v3(ity)*(0.50+2.0*arg2*arg-1.50*arg)

      exphua=exp(-vpar(24)*bta)
      exphub=exp(-vpar(24)*btb)
      exphuc=exp(-vpar(24)*btc)
      bocor4=(1.0-exphua)*(1.0-exphub)*(1.0-exphuc)
      eth=hsin*ethhulp*bocor4

      detdar=hsin*bocor4*(0.50*v1(ity)-2.0*v2(ity)*bocor2*arg+
     $v3(ity)*(6.0*arg2-1.5d0))
      detdhd=coshd*sinhe*bocor4*ethhulp
      detdhe=sinhd*coshe*bocor4*ethhulp

      detdboa=vpar(24)*exphua*(1.0-exphub)*
     $(1.0-exphuc)*ethhulp*hsin
*    $-bocor4*2.0*(2.0-bta)*v2(ity)*v4(ity)*bocor1*(1.0-arg2)*hsin
      detdbopib=-bocor4*2.0*v4(ity)*v2(ity)*
     $bo2t*bocor2*(1.0-arg2)*hsin
      detdbob=vpar(24)*exphub*(1.0-exphua)*
     $(1.0-exphuc)*ethhulp*hsin
*     detdbob=detdbob1+detdbob2
      detdboc=vpar(24)*exphuc*(1.0-exphua)*
     $(1.0-exphub)*ethhulp*hsin
*    $-bocor4*2.0*(2.0-btc)*v2(ity)*v4(ity)*bocor3*(1.0-arg2)*hsin

      detdsbo1=-(detdbopib)*
     $(vpar(25)*expov2/htov2+htov1*
     $(vpar(26)*expov-vpar(25)*expov2)/(htov2*htov2))

      et=et+eth
*     if ((j(2).eq.1.and.j(3).eq.2).or.(j(2).eq.2.and.j(3).eq.1)) then
*     eth12=eth12+eth
*     write (64,'(4i4,20f12.4)')j(1),j(2),j(3),j(4),eth12,eth,et,
*    $thg(i1)
*     end if
********************************************************************** 
*                                                                    *
*     Calculate conjugation energy                                   *
*                                                                    *
********************************************************************** 
      ba=(boa-1.50)*(boa-1.50)
      bb=(bob-1.50)*(bob-1.50)
      bc=(boc-1.50)*(boc-1.50)
      exphua1=exp(-vpar(28)*ba)
      exphub1=exp(-vpar(28)*bb)
      exphuc1=exp(-vpar(28)*bc)
      sbo=exphua1*exphub1*exphuc1
      dbohua=-2.0*(boa-1.50)*vpar(28)*exphua1*exphub1*exphuc1
      dbohub=-2.0*(bob-1.50)*vpar(28)*exphua1*exphub1*exphuc1
      dbohuc=-2.0*(boc-1.50)*vpar(28)*exphua1*exphub1*exphuc1
      arghu0=(arg2-1.0)*sinhd*sinhe
      ehulp=vconj(ity)*(arghu0+1.0)
      ecoh=ehulp*sbo
      decodar=sbo*vconj(ity)*2.0*arg*sinhd*sinhe
      decodbola=dbohua*ehulp
      decodbolb=dbohub*ehulp
      decodbolc=dbohuc*ehulp
      decodhd=coshd*sinhe*vconj(ity)*sbo*(arg2-1.0)
      decodhe=coshe*sinhd*vconj(ity)*sbo*(arg2-1.0)
      eco=eco+ecoh
    1 continue
********************************************************************** 
*                                                                    *
*     Calculate derivative torsion angle and conjugation energy      *
*     to cartesian coordinates                                       *
*                                                                    *
********************************************************************** 
      SINTH=SIN(THG(i1)*DGRRDN)
      IF (SINTH.GE.0.0.AND.SINTH.LT.1.0D-10) SINTH=1.0D-10
      IF (SINTH.LT.0.0.AND.SINTH.GT.-1.0D-10) SINTH=-1.0D-10
      IF (j(1).EQ.IB(LA,2)) THEN
      DO  K1=1,3
      DRADC(K1,1)=DRDC(LA,K1,1)
      DRADC(K1,2)=DRDC(LA,K1,2)
      end do
      ELSE
      DO  K1=1,3
      DRADC(K1,1)=DRDC(LA,K1,2)
      DRADC(K1,2)=DRDC(LA,K1,1)
      end do
      ENDIF
      IF (j(2).EQ.IB(LB,2)) THEN
      DO  K1=1,3
      DRBDC(K1,2)=DRDC(LB,K1,1)
      DRBDC(K1,3)=DRDC(LB,K1,2)
      end do
      ELSE
      DO K1=1,3
      DRBDC(K1,2)=DRDC(LB,K1,2)
      DRBDC(K1,3)=DRDC(LB,K1,1)
      end do
      ENDIF
      IF (j(3).EQ.IB(LC,2)) THEN
      DO K1=1,3
      DRCDC(K1,3)=DRDC(LC,K1,1)
      DRCDC(K1,4)=DRDC(LC,K1,2)
      end do
      ELSE
      DO K1=1,3
      DRCDC(K1,3)=DRDC(LC,K1,2)
      DRCDC(K1,4)=DRDC(LC,K1,1)
      end do
      ENDIF
      DO K1=1,3
      DHDDC(K1,2)=DHDC(LD,K1,2)
      DHEDC(K1,3)=DHDC(LE,K1,2)
      end do
      IF (j(1).EQ.IV(LD,2)) THEN
      DO K1=1,3
      DHDDC(K1,1)=DHDC(LD,K1,1)
      DHDDC(K1,3)=DHDC(LD,K1,3)
      end do
      ELSE
      DO K1=1,3
      DHDDC(K1,1)=DHDC(LD,K1,3)
      DHDDC(K1,3)=DHDC(LD,K1,1)
      end do
      ENDIF
      IF (j(2).EQ.IV(LE,2)) THEN
      DO K1=1,3
      DHEDC(K1,2)=DHDC(LE,K1,1)
      DHEDC(K1,4)=DHDC(LE,K1,3)
      end do
      ELSE
      DO K1=1,3
      DHEDC(K1,2)=DHDC(LE,K1,3)
      DHEDC(K1,4)=DHDC(LE,K1,1)
      end do
      ENDIF
      HTRA=RLA+COSHD*(RLC*COSHE-RLB)
      HTRB=RLB-RLA*COSHD-RLC*COSHE
      HTRC=RLC+COSHE*(RLA*COSHD-RLB)
      HTHD=RLA*SINHD*(RLB-RLC*COSHE)
      HTHE=RLC*SINHE*(RLB-RLA*COSHD)
      HNRA=RLC*SINHD*SINHE
      HNRC=RLA*SINHD*SINHE
      HNHD=RLA*RLC*COSHD*SINHE
      HNHE=RLA*RLC*SINHD*COSHE

      if (icpres.eq.0) then

      DO  K1=1,3
      DRDA(K1)=A(K1)/R4
      DO  K2=1,4
      DRVDC(K1,K2)=DRDA(K1)*DADC(K2)
      DTDC(K1,K2)=2.0*(DRADC(K1,K2)*HTRA+DRBDC(K1,K2)*HTRB+DRCDC(K1,K2
     $)*HTRC-DRVDC(K1,K2)*R4+DHDDC(K1,K2)*HTHD+DHEDC(K1,K2)*HTHE)
      DNDC(K1,K2)=2.0*(DRADC(K1,K2)*HNRA+DRCDC(K1,K2)*HNRC+DHDDC(K1,K2
     $)*HNHD+DHEDC(K1,K2)*HNHE)
      DARGTDC(i1,K1,K2)=(DTDC(K1,K2)-ARG*DNDC(K1,K2))/POEM
 
      D(K1,J(K2))=D(K1,J(K2))+DARGTDC(i1,K1,K2)*detdar+
     $dargtdc(i1,k1,k2)*decodar+(detdhd+decodhd)*dhddc(k1,k2)+
     $(detdhe+decodhe)*dhedc(k1,k2)
      end do
      end do
 
      do i2=1,idbo1(la)
      ihu=idbo(la,i2)
      do k1=1,3
      d(k1,ihu)=d(k1,ihu)+dbondc(la,k1,i2)*(detdboa+decodbola)
      end do
      end do
 
      do i2=1,idbo1(lb)
      ihu=idbo(lb,i2)
      do k1=1,3
      d(k1,ihu)=d(k1,ihu)+dbondc(lb,k1,i2)*(detdbob+decodbolb)
      d(k1,ihu)=d(k1,ihu)+dbopindc(lb,k1,i2)*detdbopib
      end do
      end do
 
      do i2=1,idbo1(lc)
      ihu=idbo(lc,i2)
      do k1=1,3
      d(k1,ihu)=d(k1,ihu)+dbondc(lc,k1,i2)*(detdboc+decodbolc)
      end do
      end do
 
      do i2=1,ia(j(2),2)
      iob=ia(j(2),2+i2)
      ncubo=nubon2(j(2),i2)
      do i3=1,idbo1(ncubo)
      ihu=idbo(ncubo,i3)
      do k1=1,3
      d(k1,ihu)=d(k1,ihu)+detdsbo1*dbondc(ncubo,k1,i3)
      end do
      end do
      end do

      do i2=1,ia(j(3),2)
      iob=ia(j(3),2+i2)
      ncubo=nubon2(j(3),i2)
      do i3=1,idbo1(ncubo)
      ihu=idbo(ncubo,i3)
      do k1=1,3
      d(k1,ihu)=d(k1,ihu)+detdsbo1*dbondc(ncubo,k1,i3)
      end do
      end do
      end do

      else

      DO  K1=1,3
      DRDA(K1)=A(K1)/R4
      DO  K2=1,4
      DRVDC(K1,K2)=DRDA(K1)*DADC(K2)
      DTDC(K1,K2)=2.0*(DRADC(K1,K2)*HTRA+DRBDC(K1,K2)*HTRB+DRCDC(K1,K2
     $)*HTRC-DRVDC(K1,K2)*R4+DHDDC(K1,K2)*HTHD+DHEDC(K1,K2)*HTHE)
      DNDC(K1,K2)=2.0*(DRADC(K1,K2)*HNRA+DRCDC(K1,K2)*HNRC+DHDDC(K1,K2
     $)*HNHD+DHEDC(K1,K2)*HNHE)
      DARGTDC(i1,K1,K2)=(DTDC(K1,K2)-ARG*DNDC(K1,K2))/POEM
      ix=nmpx(j(2),j(k2))
      iy=nmpy(j(2),j(k2))
      iz=nmpz(j(2),j(k2))
      kcell=14+ix+3*iy+9*iz
      dcell(k1,j(k2),kcell)=dcell(k1,j(k2),kcell)
     $+dargtdc(i1,K1,K2)*detdar+
     $dargtdc(i1,k1,k2)*decodar+(detdhd+decodhd)*dhddc(k1,k2)+
     $(detdhe+decodhe)*dhedc(k1,k2)
      end do
      end do

      do i2=1,idbo1(la)  
      ihu=idbo(la,i2)
      ix=nmpx(j(2),ihu)
      iy=nmpy(j(2),ihu)
      iz=nmpz(j(2),ihu)
      kcell=14+ix+3*iy+9*iz
      do k1=1,3
      dcell(k1,ihu,kcell)=dcell(k1,ihu,kcell)+
     $dbondc(la,k1,i2)*(detdboa+decodbola)
      end do
      end do

      do i2=1,idbo1(lb)  
      ihu=idbo(lb,i2)
      ix=nmpx(j(2),ihu)
      iy=nmpy(j(2),ihu)
      iz=nmpz(j(2),ihu)
      kcell=14+ix+3*iy+9*iz
      do k1=1,3
      dcell(k1,ihu,kcell)=dcell(k1,ihu,kcell)+
     $dbondc(lb,k1,i2)*(detdbob+decodbolb)
      dcell(k1,ihu,kcell)=dcell(k1,ihu,kcell)+
     $dbopindc(lb,k1,i2)*detdbopib
      end do
      end do

      do i2=1,idbo1(lc)  
      ihu=idbo(lc,i2)
      ix=nmpx(j(2),ihu)
      iy=nmpy(j(2),ihu)
      iz=nmpz(j(2),ihu)
      kcell=14+ix+3*iy+9*iz
      do k1=1,3
      dcell(k1,ihu,kcell)=dcell(k1,ihu,kcell)+
     $dbondc(lc,k1,i2)*(detdboc+decodbolc)
      end do
      end do

      do i2=1,ia(j(2),2)
      iob=ia(j(2),2+i2)
      ncubo=nubon2(j(2),i2)
      do i3=1,idbo1(ncubo)  
      ihu=idbo(ncubo,i3)
      ix=nmpx(j(2),ihu)
      iy=nmpy(j(2),ihu)
      iz=nmpz(j(2),ihu)
      kcell=14+ix+3*iy+9*iz
      do k1=1,3
      dcell(k1,ihu,kcell)=dcell(k1,ihu,kcell)+
     $detdsbo1*dbondc(ncubo,k1,i3)
      end do
      end do
      end do

      do i2=1,ia(j(3),2)
      iob=ia(j(3),2+i2)
      ncubo=nubon2(j(3),i2)
      do i3=1,idbo1(ncubo)  
      ihu=idbo(ncubo,i3)
      ix=nmpx(j(2),ihu)
      iy=nmpy(j(2),ihu)
      iz=nmpz(j(2),ihu)
      kcell=14+ix+3*iy+9*iz
      do k1=1,3
      dcell(k1,ihu,kcell)=dcell(k1,ihu,kcell)+
     $detdsbo1*dbondc(ncubo,k1,i3)
      end do
      end do
      end do

      end if

   10 continue 

      return
      end 
********************************************************************** 
********************************************************************** 

      subroutine nonbon

********************************************************************** 
      include 'cbka.blk'
      include 'cbkc.blk'
      include 'cbkch.blk'
      include 'cbkconst.blk'
      include 'cbkd.blk'
      include 'cbkdcell.blk'
      include 'cbkenergies.blk'
      include 'cbkff.blk'
      include 'cbkia.blk'
      include 'cbknonbon.blk'
      include 'cbknvl.blk'
      include 'cbkpairs.blk'
      include 'cellcoord.blk'
      include 'control.blk'

      dimension a(3),da(6)
********************************************************************** 
*                                                                    *
*     Calculate vdWaals and Coulomb energies and derivatives         *
*                                                                    *
********************************************************************** 
      if (ndebug.eq.1) then
      open (65,file='fort.65',status='unknown',access='append')
      write (65,*) 'In nonbon'
      call timer(65)
      end if

      ew=0.0
      ep=0.0

      c1c=332.0638
      third=one/three
      fothird=4.0/3.0
      twothird=2.0/3.0
      h15=(vpar(29)-1.0)/vpar(29)

      nptmp=0
      nstmp=0
      do 10 ivl=1,nvpair-nvlself
      i1=nvl1(ivl)
      i2=nvl2(ivl)
      ix=nvlx(ivl)
      iy=nvly(ivl)
      iz=nvlz(ivl)
      a(1)=c(i1,1)-c(i2,1)+ix*tm11
      a(2)=c(i1,2)-c(i2,2)+ix*tm21+iy*tm22
      a(3)=c(i1,3)-c(i2,3)+ix*tm31+iy*tm32+iz*tm33
**********************************************************************
*                                                                    *
*     Construct periodic images for each interaction                 *
*                                                                    *
**********************************************************************
      rr=sqrt(a(1)*a(1)+a(2)*a(2)+a(3)*a(3))
      if (rr.gt.swb.or.rr.lt.0.001) goto 10
      if (ndebug.eq.1) then
         if (i1.le.21) then
            nptmp = nptmp+1
         endif
      endif

      ity1=ia(i1,1)
      ity2=ia(i2,1)
      imol1=iag(i1,3+mbond)
      imol2=iag(i2,3+mbond)
      rr2=rr*rr

      sw=1.0
      sw1=0.0
      call taper(rr,rr2)
**********************************************************************
*                                                                    *
*     Calculate vdWaals energy                                       *
*                                                                    *
**********************************************************************
      p1=p1co(ity1,ity2)
      p2=p2co(ity1,ity2)
      p3=p3co(ity1,ity2)
      hulpw=(rr**vpar(29)+gamwco(ity1,ity2))
      rrw=hulpw**(1.0/vpar(29))
      h1=exp(p3*(1.0-rrw/p1))
      h2=exp(0.50*p3*(1.0-rrw/p1))

      ewh=p2*(h1-2.0*h2)
      rrhuw=rr**(vpar(29)-1.0)
      dewdr=(p2*p3/p1)*(h2-h1)*rrhuw*(hulpw**-h15)

**********************************************************************
*                                                                    *
*     Calculate Coulomb energy                                       *
*                                                                    *
**********************************************************************
      q1q2=ch(i1)*ch(i2)
      hulp1=(rr2*rr+gamcco(ity1,ity2))
      eph=c1c*q1q2/(hulp1**third)
      depdr=-c1c*q1q2*rr2/(hulp1**fothird)
      if (ndebug.eq.1) then
         if (i1.eq.1) then
            write(65,'("Force pair",6e15.6)') rr,
     $           q1q2,rr2,hulpw,sw,sw1
         endif
      endif
**********************************************************************
*                                                                    *
*     Taper correction                                               *
*                                                                    *
**********************************************************************
      ephtap=eph*sw
      depdrtap=depdr*sw+eph*sw1
      ewhtap=ewh*sw
      dewdrtap=dewdr*sw+ewh*sw1

*     write (64,*)i1,i2,p1,p2,p3,gamwco(ity1,ity2),vpar(29),ewh,ew
      ew=ew+ewhtap
      ep=ep+ephtap
**********************************************************************
*                                                                    *
*     Calculate derivatives vdWaals energy to cartesian              *
*     coordinates                                                    *
*                                                                    *
**********************************************************************
      if (icpres.eq.0) then

      do k4=1,3
      d(k4,i1)=d(k4,i1)+(dewdrtap+depdrtap)*(a(k4)/rr)
      d(k4,i2)=d(k4,i2)-(dewdrtap+depdrtap)*(a(k4)/rr)
      end do


      else

      kcell=14+ix+3*iy+9*iz
      do k4=1,3
      dcell(k4,i1,14)=dcell(k4,i1,14)+
     $(dewdrtap+depdrtap)*(a(k4)/rr)
      dcell(k4,i2,kcell)=dcell(k4,i2,kcell)-
     $(dewdrtap+depdrtap)*(a(k4)/rr)
      end do

      end if

   10 continue
**********************************************************************
*                                                                    *
*     Add interaction of atoms with the corresponding atom           *
*     in the surrounding periodic cells                              *
*                                                                    *
**********************************************************************
      do 20 ivl=nvpair-nvlself,nvpair
      i1=nvl1(ivl)
      ix=nvlx(ivl)
      iy=nvly(ivl)
      iz=nvlz(ivl)
      kcell=14+ix+3*iy+9*iz
      a(1)=ix*tm11
      a(2)=ix*tm21+iy*tm22
      a(3)=ix*tm31+iy*tm32+iz*tm33
      rr=sqrt(a(1)*a(1)+a(2)*a(2)+a(3)*a(3))

      if (rr.gt.swb.or.rr.lt.0.001) goto 20
      nstmp = nstmp+1
      ity1=ia(i1,1)
      rr2=rr*rr

      sw=1.0
      sw1=0.0
      call taper(rr,rr2)
**********************************************************************
*                                                                    *
*     Calculate vdWaals energy                                       *
*                                                                    *
**********************************************************************
      p1=p1co(ity1,ity1)
      p2=p2co(ity1,ity1)
      p3=p3co(ity1,ity1)

      hulpw=(rr**vpar(29)+gamwco(ity1,ity1))
      rrw=hulpw**(1.0/vpar(29))
      h1=exp(p3*(1.0-rrw/p1))
      h2=exp(0.50*p3*(1.0-rrw/p1))

      ewh=0.50*p2*(h1-2.0*h2)
      rrhuw=rr**(vpar(29)-1.0)
      dewdr=0.50*(p2*p3/p1)*(h2-h1)*rrhuw*(hulpw**-h15)
**********************************************************************
*                                                                    *
*     Calculate Coulomb energy                                       *
*                                                                    *
**********************************************************************
      q1q2=ch(i1)*ch(i1)
      hulp1=(rr*rr2+gamcco(ity1,ity1))
      eph=0.50*c1c*q1q2/(hulp1**third)
      depdr=-0.50*c1c*q1q2*rr2/(hulp1**fothird)
**********************************************************************
*                                                                    *
*     Taper correction                                               *
*                                                                    *
**********************************************************************
      ephtap=eph*sw
      depdrtap=depdr*sw+eph*sw1
      ewhtap=ewh*sw
      dewdrtap=dewdr*sw+ewh*sw1

      ew=ew+ewhtap
      ep=ep+ephtap

      if (icpres.eq.1) then
      do k4=1,3
      dcell(k4,i1,14)=dcell(k4,i1,14)+
     $(dewdrtap+depdrtap)*(a(k4)/rr)
      dcell(k4,i1,kcell)=dcell(k4,i1,kcell)-
     $(dewdrtap+depdrtap)*(a(k4)/rr)
      end do
      end if

   20 continue

      if (ndebug.eq.1) then
      write (65,*) 'nptmp = ',nptmp
      write (65,*) 'nstmp = ',nstmp
      call timer(65)
      close (65)
      end if

**********************************************************************
*                                                                    *
*     Calculate derivatives Coulomb energy to cartesian              *
*     coordinates                                                    *
*                                                                    *
**********************************************************************

*     do i1=1,na
*     do k1=1,3
*     sum=0.0
*     do 20 i2=1,na

*     do 20 i3=i2+1,na
*     if (dqdc(i3,i1,k1).le.zero.and.dqdc(i2,i1,k1).le.zero)
*    $goto 20
*     rr=rrs(i2,i3)
*     ity1=ia(i2,1)
*     ity2=ia(i3,1)
*     gamt=sqrt(gam(ity1)*gam(ity2))
*     hulp1=(rr**3+(1.0/(gamt**3)))
*     depdq1=-c1c*ch(i3)/(hulp1**third)
*     depdq2=-c1c*ch(i2)/(hulp1**third)
*     sum=sum+depdq1*dqdc(i2,i1,k1)+depdq2*dqdc(i3,i1,k1)
*  20 continue
*     d(i1,k1)=d(i1,k1)+sum

*     end do
*     end do

      return
      end

********************************************************************** 
**********************************************************************
 
      subroutine efield
 
**********************************************************************
      include 'cbka.blk'
      include 'cbkc.blk'
      include 'cbkch.blk'
      include 'cbkcha.blk'
      include 'cbkd.blk'
      include 'cbkefield.blk'
      include 'cbkenergies.blk'
      include 'cbktregime.blk'
      include 'control.blk'
      include 'small.blk'
      if (ndebug.eq.1) then
      open (65,file='fort.65',status='unknown',access='append')
      write (65,*) 'In efield'
      call timer(65)
      close (65)
      end if
**********************************************************************
*                                                                    *
*     Electric field                                                 *
*                                                                    *
**********************************************************************
      efi=0.0
      efix=0.0
      efiy=0.0
      efiz=0.0
      c1=23.02           !conversion from kcal to eV
      c1c=332.0638       !Coulomb energy conversion
 
      if (ifieldx.eq.1) then
      do i1=1,na
      efih=vfieldx*c1*c1c*ch(i1)*c(i1,1)
      efix=efix+efih
      defidc=c1*c1c*vfieldx*ch(i1)
      d(1,i1)=d(1,i1)+defidc
      end do
      end if
 
      if (ifieldy.eq.1) then
      do i1=1,na
      efih=vfieldy*c1*c1c*ch(i1)*c(i1,2)
      efiy=efiy+efih
      defidc=c1*c1c*vfieldy*ch(i1)
      d(2,i1)=d(2,i1)+defidc
      end do
      end if
 
      if (ifieldz.eq.1) then
      do i1=1,na
      efih=vfieldz*c1*c1c*ch(i1)*c(i1,3)
      efiz=efiz+efih
      defidc=c1*c1c*vfieldz*ch(i1)
      d(3,i1)=d(3,i1)+defidc
      end do
      end if
 
      efi=efix+efiy+efiz
      return
      end
**********************************************************************
********************************************************************** 

      subroutine radbo

********************************************************************** 
      include 'cbka.blk'
      include 'control.blk'
      dimension a1(3)
********************************************************************** 
*                                                                    *
*     Calculate radical/double bond energy (to increase reaction     *
*     rates)                                                         *
*                                                                    *
********************************************************************** 
      if (ndebug.eq.1) then
      open (65,file='fort.65',status='unknown',access='append')
      write (65,*) 'In radbo'
      call timer(65)
      close (65)
      end if
*     eradbo=zero
*     do i1=1,na
*     if (xmasat(i1).gt.2.0) qa(i1)='C '
*     end do
*     nradcount=nradcount+1
*     if (nradcount.lt.nrddf) return
*     if (nradcount.gt.2*nrddf) nradcount=0

*     do i1=1,nmolo5
*     if (elmol(i1).gt.2*int(elmol(i1)*0.50)) then
*     vlpmax=0.0
*     do i2=1,nmolat2(i1,1)
*     eradmin=50.0
*     ihu=nmolat2(i1,i2+1)
*     if (xmasat(ihu).gt.2.0.and.vlp(ihu).gt.zero) then !no H-atoms
*     vlps=vlp(ihu)

*     do 10 i3=1,na
*     if (xmasat(i3).lt.2.0) goto 10       !no H-atoms
*     imol2=iag(i3,3+mbond)
*     if (i1.eq.imol2) goto 10            !no intermolecular reactions
*     bopisum=zero
*     do i4=1,ia(i3,2)
*     ihu2=nubon2(i3,i4)
*     bopisum=bopisum+bopi(ihu2)
*     end do
*     if (bopisum.lt.0.25) goto 10        !only atoms in double bonds
*     dirb1=dista(ihu,i3)
*     hu1=vpar(22)-dirb1
*     expvl=exp(-5.0*vlps)
*     hexp=1.0-expvl
*     if (hu1.ge.zero) then
*     exphu1=exp(-vpar(25)*hu1*hu1)
*     eradboh1=hexp*vpar(24)*exphu1
*     else
*     exphu1=exp(-vpar(26)*hu1*hu1)
*     eradboh1=hexp*vpar(24)*exphu1
*     end if
*     
*     if (eradboh1.lt.eradmin) then
*     i3s=i3
*     disrmin=dirb1
*     eradmin=eradboh1
*     end if

*  10 continue     

*     qa(ihu)='S '
*     qa(i3s)='N '
*     hu1=vpar(22)-disrmin
*     eradboh1=zero
*     expvl=exp(-5.0*vlps)
*     hexp=1.0-expvl
*     if (hu1.ge.zero) then
*     exphu1=exp(-vpar(25)*hu1*hu1)
*     eradboh1=hexp*vpar(24)*exphu1
*     deradbodr1=hexp*vpar(24)*vpar(25)*2.0*hu1*exphu1
*     else
*     exphu1=exp(-vpar(26)*hu1*hu1)
*     eradboh1=hexp*vpar(24)*exphu1
*     deradbodr1=hexp*vpar(24)*vpar(26)*2.0*hu1*exphu1
*     end if
*     eradbo=eradbo+eradboh1

*     a1(1)=dxm(ihu,i3s)
*     a1(2)=dym(ihu,i3s)
*     a1(3)=dzm(ihu,i3s)

*     do k1=1,3
*     d(k1,ihu)=d(k1,ihu)+deradbodr1*(a1(k1)/disrmin)
*     d(k1,i3s)=d(k1,i3s)-deradbodr1*(a1(k1)/disrmin)
*     end do

*     end if
*     end do

*     end if
*     end do


      return
      end
********************************************************************** 
********************************************************************** 

      subroutine restraint

********************************************************************** 
      include 'cbka.blk'
      include 'cbkatomcoord.blk'
      include 'cbkc.blk'
      include 'cbkconst.blk'
      include 'cbkd.blk'
      include 'cbkenergies.blk'
      include 'cbkrestr.blk'
      include 'cbktorang.blk'
      include 'cbktorsion.blk'
      include 'cbktregime.blk'
      include 'control.blk'
      include 'small.blk'
      include 'cbkinit.blk'
      dimension drda(3),j(4),dhrdc(3,3),dargdc(3,3)
********************************************************************** 
*                                                                    *
*     Calculate distance restraint energy                            *
*                                                                    *
********************************************************************** 
      if (ndebug.eq.1) then
      open (65,file='fort.65',status='unknown',access='append')
      write (65,*) 'In restraint'
      call timer(65)
      close (65)
      end if
      do i1=1,nrestra
      ih1=irstra(i1,1)
      ih2=irstra(i1,2)
      if (itend(i1).eq.0.or.(mdstep.gt.itstart(i1).and.mdstep.lt.
     $itend(i1))) then
      call dista2(ih1,ih2,rr,dx,dy,dz)
      diffr=rr-rrstra(i1)
*     diffr=rrstra(i1)
      exphu=exp(-vkrst2(i1)*(diffr*diffr))
      erh=vkrstr(i1)*(1.0-exphu)
      deresdr=2.0*vkrst2(i1)*diffr*vkrstr(i1)*exphu
*     deresdr=-2.0*vkrst2(i1)*diffr*vkrstr(i1)*exphu
      eres=eres+erh
      drda(1)=dx/rr
      drda(2)=dy/rr
      drda(3)=dz/rr
      do k1=1,3
      d(k1,ih1)=d(k1,ih1)+deresdr*drda(k1)
      d(k1,ih2)=d(k1,ih2)-deresdr*drda(k1)
      end do
      end if
      end do
      
**********************************************************************
*                                                                    *
*     Calculate angle restraint energy                               *
*                                                                    *
**********************************************************************
      do i1=1,nrestrav
      j(1)=irstrav(i1,1)
      j(2)=irstrav(i1,2)
      j(3)=irstrav(i1,3)
      ittr=0
*     do i2=1,nval
*     if (j(1).eq.iv(i2,2).and.j(2).eq.iv(i2,3).and.j(3).eq.iv(i2,4))
*    $ittr=i2
*     end do
*     if (ittr.eq.0) stop 'Wrong valence angle restraint'
      call calvalres(j(1),j(2),j(3),arg,hr,dhrdc,dargdc)
      vaval=hr*rdndgr
      diffv=-(vaval-vrstra(i1))*dgrrdn
      exphu=exp(-vkr2v(i1)*(diffv*diffv))
      erh=vkrv(i1)*(1.0-exphu)
      deresdv=-2.0*vkr2v(i1)*diffv*vkrv(i1)*exphu
      eres=eres+erh
      do k1=1,3
      do k2=1,3
      d(k1,j(k2))=d(k1,j(k2))+deresdv*dhrdc(k1,k2)
      end do
      end do

      end do

********************************************************************** 
*                                                                    *
*     Calculate torsion restraint energy                             *
*                                                                    *
********************************************************************** 
      do i1=1,nrestrat
      j(1)=irstrat(i1,1)
      j(2)=irstrat(i1,2)
      j(3)=irstrat(i1,3)
      j(4)=irstrat(i1,4)
      ittr=0
      do i2=1,ntor
      if (j(1).eq.it(i2,2).and.j(2).eq.it(i2,3).and.j(3).eq.it(i2,4)
     $.and.j(4).eq.it(i2,5)) ittr=i2
      if (j(4).eq.it(i2,2).and.j(3).eq.it(i2,3).and.j(2).eq.it(i2,4)
     $.and.j(1).eq.it(i2,5)) ittr=i2
      end do
      if (ittr.eq.0) then
      write (*,*)'Wrong torsion restraint'
      write (*,*)i1,j(1),j(2),j(3),j(4)
      stop 'Wrong torsion restraint'
      end if
      vtor=thg(ittr)
      difft=-(vtor-trstra(i1))*dgrrdn
      exphu=exp(-vkr2t(i1)*(difft*difft))
      erh=vkrt(i1)*(1.0-exphu)
      deresdt=2.0*vkr2t(i1)*difft*vkrt(i1)*exphu
      if (vtor.lt.zero) deresdt=-deresdt
      eres=eres+erh
      do k1=1,3
      do k2=1,4
      d(k1,j(k2))=d(k1,j(k2))+deresdt*dargtdc(ittr,k1,k2)
      end do
      end do

      end do
********************************************************************** 
*                                                                    *
*     Calculate mass centre restraint energy                         *
*                                                                    *
********************************************************************** 
      do i1=1,nrestram
      j1=irstram(i1,2)
      j2=irstram(i1,3)
      j3=irstram(i1,4)
      j4=irstram(i1,5)
      kdir=irstram(i1,1)
      cmx1=0.0 
      cmy1=0.0 
      cmz1=0.0 
      cmx2=0.0 
      cmy2=0.0 
      cmz2=0.0 
      summas1=0.0
      summas2=0.0
      do i2=j1,j2
      cmx1=cmx1+c(i2,1)*xmasat(i2)
      cmy1=cmy1+c(i2,2)*xmasat(i2)
      cmz1=cmz1+c(i2,3)*xmasat(i2)
      summas1=summas1+xmasat(i2)
      end do
      cmx1=cmx1/summas1
      cmy1=cmy1/summas1
      cmz1=cmz1/summas1
      if (mdstep.lt.2) then
      rmstrax(i1)=cmx1
      rmstray(i1)=cmy1
      rmstraz(i1)=cmz1
      end if
      if (kdir.le.3) then
      do i2=j3,j4
      cmx2=cmx2+c(i2,1)*xmasat(i2)
      cmy2=cmy2+c(i2,2)*xmasat(i2)
      cmz2=cmz2+c(i2,3)*xmasat(i2)
      summas2=summas2+xmasat(i2)
      end do
      cmx2=cmx2/summas2
      cmy2=cmy2/summas2
      cmz2=cmz2/summas2
      end if
      if (kdir.eq.1) dist=cmx1-cmx2
      if (kdir.eq.2) dist=cmy1-cmy2
      if (kdir.eq.3) dist=cmz1-cmz2
      if (kdir.eq.4) then
      distx=cmx1-rmstrax(i1)
      disty=cmy1-rmstray(i1)
      distz=cmz1-rmstraz(i1)
      dist=sqrt(distx*distx+disty*disty+distz*distz)
      end if
      dismacen(i1)=dist
      dist=dist-rmstra1(i1)
      erh=rmstra2(i1)*dist*dist
      deresdr=2.0*dist*rmstra2(i1)
*     exphu=exp(-rmstra3(i1)*(dist*dist))
*     erh=rmstra2(i1)*(1.0-exphu)
*     deresdr=2.0*rmstra3(i1)*dist*rmstra2(i1)*exphu
      eres=eres+erh
      if (kdir.le.3) then
      do i2=j1,j2
      d(kdir,i2)=d(kdir,i2)+deresdr*xmasat(i2)/summas1
      end do
      do i2=j3,j4
      d(kdir,i2)=d(kdir,i2)-deresdr*xmasat(i2)/summas2
      end do
      end if
      if (kdir.eq.4.and.mdstep.gt.5) then
      do i2=j1,j2
      d(1,i2)=d(1,i2)+deresdr*(distx/dist)*(xmasat(i2)/summas1)
      d(2,i2)=d(2,i2)+deresdr*(disty/dist)*(xmasat(i2)/summas1)
      d(3,i2)=d(3,i2)+deresdr*(distz/dist)*(xmasat(i2)/summas1)
      end do
      end if
      end do
********************************************************************** 
*                                                                    *
*     Calculate morphing energy                                      *
*                                                                    *
********************************************************************** 
      if (imorph.eq.1) then
      distot=zero
      do i1=1,na
      dmx=c(i1,1)-cmo(i1,1)
      dmy=c(i1,2)-cmo(i1,2)
      dmz=c(i1,3)-cmo(i1,3)
      dism=sqrt(dmx*dmx+dmy*dmy+dmz*dmz)
      distot=distot+dism
*     exphu=exp(-vmo2(i1)*(dism*dism))
*     erh=vmo1(i1)*(1.0-exphu)
      erh=vmo1(i1)*dism
      eres=eres+erh
*     deresddis=2.0*vmo2(i1)*dism*vmo1(i1)*exphu
      deresddis=vmo1(i1)
      drda1=dmx/dism
      drda2=dmy/dism
      drda3=dmz/dism
      d(1,i1)=d(1,i1)+deresddis*drda1
      d(2,i1)=d(2,i1)+deresddis*drda2
      d(3,i1)=d(3,i1)+deresddis*drda3
      end do
      write (65,'(i6,6f12.4)')mdstep,distot,eres
  
      end if
      
      
      return
      end
********************************************************************** 
******************************************************************** 

      subroutine calvalres (ja1,ja2,ja3,arg,hr,dhrdc,dargdc)

********************************************************************** 
      include 'cbka.blk'
      dimension a(3),b(3),j(3),dradc(3,3),drbdc(3,3),dtdc(3,3),
     $dargdc(3,3),dndc(3,3),dadc(3),dbdc(3),dhrdc(3,3)
********************************************************************** 
*                                                                    *
*     Calculate valency angles and their derivatives to cartesian    *
*     coordinates  for restraint calculations                        *
*                                                                    *
********************************************************************** 
*     if (ndebug.eq.1) then
*     open (65,file='fort.65',status='unknown',access='append')
*     write (65,*) 'In calvalres'
*     call timer(65)
*     close (65)
*     end if

      dadc(1)=-1.0
      dadc(2)=1.0
      dadc(3)=0.0
      dbdc(1)=0.0
      dbdc(2)=1.0
      dbdc(3)=-1.0
      do k1=1,3
      do k2=1,3
      dradc(k1,k2)=0.0
      drbdc(k1,k2)=0.0
      end do
      end do
**********************************************************************
*                                                                    *
*     Determine valency angle                                        *
*                                                                    *
**********************************************************************
      call dista2(ja1,ja2,rla,dx1,dy1,dz1)
      call dista2(ja2,ja3,rlb,dx2,dy2,dz2)
 
      a(1)=-dx1
      a(2)=-dy1
      a(3)=-dz1
      b(1)=dx2
      b(2)=dy2
      b(3)=dz2
      poem=rla*rlb
      tel=a(1)*b(1)+a(2)*b(2)+a(3)*b(3)
      arg=tel/poem
      arg2=arg*arg
      s1ma22=1.0-arg2
      if (s1ma22.lt.1.0d-10) s1ma22=1.0d-10
      s1ma2=sqrt(s1ma22)
      if (arg.gt.1.0) arg=1.0
      if (arg.lt.-1.0) arg=-1.0
      hr=acos(arg)
**********************************************************************
*                                                                    *
*     Calculate derivative valency angle to cartesian coordinates    *
*                                                                    *
**********************************************************************
      do k1=1,3
      dradc(k1,1)=-a(k1)/rla
      dradc(k1,2)=a(k1)/rla
      end do

      do k1=1,3
      drbdc(k1,2)=b(k1)/rlb
      drbdc(k1,3)=-b(k1)/rlb
      end do

      do k1=1,3
      do k2=1,3
      dndc(k1,k2)=rla*drbdc(k1,k2)+rlb*dradc(k1,k2)
      dtdc(k1,k2)=a(k1)*dbdc(k2)+b(k1)*dadc(k2)
      dargdc(k1,k2)=(dtdc(k1,k2)-arg*dndc(k1,k2))/poem
      dhrdc(k1,k2)=-dargdc(k1,k2)/s1ma2
      end do
      end do
      
   10 continue

      return
      end
********************************************************************** 
********************************************************************** 

      subroutine caltor(ja1,ja2,ja3,ja4,ht)

********************************************************************** 
      include 'cbka.blk'
      include 'cbkenergies.blk'
      include 'cbktregime.blk'
      include 'control.blk'
      include 'cbkinit.blk'
      DIMENSION  A(3),DRDA(3),DADC(4),DRADC(3,4),DRBDC(3,4),
     $DRCDC(3,4),DHDDC(3,4),DHEDC(3,4),DRVDC(3,4),DTDC(3,4),
     $DNDC(3,4)
      dimension j(4),dvdc1(3,3),dargdc1(3,3),dvdc2(3,3),dargdc2(3,3)
********************************************************************** 
*                                                                    *
*     Calculate torsion angle (for internal coordinates output)      *
*                                                                    *
********************************************************************** 
      if (ndebug.eq.1) then
      open (65,file='fort.65',status='unknown',access='append')
      write (65,*) 'In caltor'
      call timer(65)
      close (65)
      end if
      do k1=1,3
      do k2=1,4
      dhddc(k1,k2)=0.0
      dhedc(k1,k2)=0.0
      dradc(k1,k2)=0.0
      drbdc(k1,k2)=0.0
      drcdc(k1,k2)=0.0
      end do
      end do
      et=0.0
      eco=0.0
      dadc(1)=1.0
      dadc(2)=0.0
      dadc(3)=0.0
      dadc(4)=-1.0
      call dista2(ja1,ja2,rla,dx1,dy1,dz1)
      call dista2(ja2,ja3,rlb,dx2,dy2,dz2)
      call dista2(ja3,ja4,rlc,dx2,dy2,dz2)
      call dista2(ja1,ja4,r4,dx2,dy2,dz2)
      call calvalres(ja1,ja2,ja3,arg1,h1,dvdc1,dargdc1)
      call calvalres(ja2,ja3,ja4,arg2,h2,dvdc2,dargdc2)
********************************************************************** 
*                                                                    *
*     Determine torsion angle                                        *
*                                                                    *
********************************************************************** 
      d142=r4*r4
      coshd=cos(h1)
      coshe=cos(h2)
      sinhd=sin(h1)
      sinhe=sin(h2)
      poem=2.0*rla*rlc*sinhd*sinhe
      poem2=poem*poem
      tel=rla*rla+rlb*rlb+rlc*rlc-d142-2.0*(rla*rlb*coshd-rla*rlc*
     $coshd*coshe+rlb*rlc*coshe)
      arg=tel/poem
      if (arg.gt.1.0) arg=1.0
      if (arg.lt.-1.0) arg=-1.0
      arg2=arg*arg
      ht=acos(arg)*rdndgr
      k1=ja1
      k2=ja2
      k3=ja3
      k4=ja4
      call dista2(k3,k2,dis,x3,y3,z3)
      y32z32=y3*y3+z3*z3
      wort1=sqrt(y32z32)+1e-6
      wort2=sqrt(y32z32+x3*x3)+1e-6
      sinalf=y3/wort1
      cosalf=z3/wort1
      sinbet=x3/wort2
      cosbet=wort1/wort2
      call dista2(k1,k2,dis,x1,y1,z1)
      x1=x1*cosbet-y1*sinalf*sinbet-z1*cosalf*sinbet
      y1=y1*cosalf-z1*sinalf
      wort3=sqrt(x1*x1+y1*y1)+1e-6
      singam=y1/wort3
      cosgam=x1/wort3
      call dista2(k4,k2,dis,x4,y4,z4)
      x4=x4*cosbet-y4*sinalf*sinbet-z4*cosalf*sinbet
      y4=y4*cosalf-z4*sinalf
      y4=x4*singam-y4*cosgam
      if (y4.gt.0.0) ht=-ht
      if (ht.lt.-179.999999d0) ht=-179.999999d0
      if (ht.gt.179.999999d0) ht=179.999999d0

      return
      end 
********************************************************************** 
********************************************************************** 
@


3.2.2.1
log
@I hope this is adds all the REAX files to the REAXFF branch
@
text
@@


3.2.2.2
log
@Completed prototype of parallel ReaxFF in GRASP, including charge equilibration
@
text
@d2693 4
a2696 2
         write(65,'("Force pair",6e15.6)') rr,
     $        q1q2,rr2,hulpw,sw,sw1
@


3.2.2.3
log
@Added REAXFF energy evaluation to Grasp
@
text
@d669 1
a669 5

      if (i1 .le. na_local) then
         elp=elp+elph
      endif

d789 1
a789 7
      if (j1 .le. na_local) then
         if (j2 .le. na_local) then
            eb=eb+ebh
         else
            eb=eb+0.5*ebh
         endif
      endif
d844 1
a844 8
      if (j1 .le. na_local) then
         if (j2 .le. na_local) then
            eb=eb+estriph
         else
            eb=eb+0.5*estriph
         endif
      endif

d1078 1
a1078 4

      if (i1 .le. na_local) then
         ea=ea+eah
      endif
d1217 1
a1217 5

      if (i1 .le. na_local) then
         ea=ea+eahu
      endif

d1417 2
a1418 4
      if (i1 .le. na_local) then
         elp=elp+elph
      endif

a1587 1
      include 'small.blk'
a1718 3
      if (j(2) .le. na_local) then
         ev=ev+evh
      endif
d1720 2
d1739 1
a1739 5

      if (j(2) .le. na_local) then
         ecoa=ecoa+ecoah
      endif

d1776 1
a1776 5

      if (j(2) .le. na_local) then
         ecoa=ecoa+ecoah
      endif

a1980 1
      include 'small.blk'
d2017 1
a2017 8
      if (j(2) .le. na_local) then
         if (j(3) .le. na_local) then
            ehb=ehb+ehbh
         else
            ehb=ehb+0.5*ehbh
         endif
      endif

a2126 1
      include 'small.blk'
d2321 1
a2321 10
      if (j(2) .le. na_local) then
         if (j(3) .le. na_local) then
            et=et+eth
         else
            et=et+0.5*eth
         endif
      else if (j(3) .le. na_local) then
         et=et+0.5*eth
      endif

d2351 1
a2351 11

      if (j(2) .le. na_local) then
         if (j(3) .le. na_local) then
            eco=eco+ecoh
         else
            eco=eco+0.5*ecoh
         endif
      else if (j(3) .le. na_local) then
         eco=eco+0.5*ecoh
      endif

a2610 1
      include 'small.blk'
d2707 2
a2708 10
      if (i1 .le. na_local) then
         if (i2 .le. na_local) then
            ew=ew+ewhtap
            ep=ep+ephtap
         else
            ew=ew+0.5*ewhtap
            ep=ep+0.5*ephtap
         endif
      endif

@


3.2.2.4
log
@Finished optimized implementation of ReaxFF.
Eliminates O(N^2) scaling of srttor and srtang.
Also blanks out the ghost bonds that are not in dihedral
with local atom.
@
text
@d27 1
d72 2
d142 2
d146 6
d155 6
a160 6
      a(1)=c(j(2),1)-c(j(1),1)
      a(2)=c(j(2),2)-c(j(1),2)
      a(3)=c(j(2),3)-c(j(1),3)
      b(1)=c(j(2),1)-c(j(3),1)
      b(2)=c(j(2),2)-c(j(3),2)
      b(3)=c(j(2),3)-c(j(3),3)
a1058 1

a1071 1
      if (bo(ncubo).gt.0.0) then
a1077 1
      endif
a1110 1
      if (bo(ncubo).gt.0.0) then
a1119 1
      endif
a1126 1
      if (bo(nbosa).gt.0.0) then
a1143 1
      if (bo(ncubo).gt.0.0) then
a1150 1
      endif
d1152 1
a1152 3

      endif

a1159 1
      if (bo(ncubo).gt.0.0) then
a1173 1
      endif
a1180 1
      if (bo(nbosa).gt.0.0) then
a1201 1
      if (bo(ncubo).gt.0.0) then
a1212 1
      endif
a1214 2
      endif

a1255 1
      if (bo(ncubo).gt.0.0) then
a1262 1
      endif
a1269 1
      if (bo(nbosa).gt.0.0) then
d1285 1
a1285 1

a1288 1
      if (bo(ncubo).gt.0.0) then
a1295 1
      endif
a1297 2
      endif

a1304 1
      if (bo(ncubo).gt.0.0) then
a1315 1
      endif
a1322 1
      if (bo(nbosa).gt.0.0) then
a1345 1
      if (bo(ncubo).gt.0.0) then
a1356 1
      endif
a1358 2
      endif

a1427 1
      if (bo(nbohu).gt.0.0) then
a1455 1
      if (bo(ncubo).gt.0.0) then
a1461 1
      endif
a1480 1
      if (bo(ncubo).gt.0.0) then
a1491 1
      endif
a1495 2
      endif

a1655 1
      if (bo(ibv).gt.0.0) then
a1657 1
      endif
a1844 1
      if (bo(ibv).gt.0.0) then
a1854 1
      endif
a1859 1
      if (bo(ibv).gt.0.0) then
a1865 1
      endif
a1870 1
      if (bo(ibv).gt.0.0) then
a1876 1
      endif
a1881 1
      if (bo(ibv).gt.0.0) then
a1887 1
      endif
a1928 1
      if (bo(ibv).gt.0.0) then
a1943 1
      endif
a1948 1
      if (bo(ibv).gt.0.0) then
a1959 1
      endif
a1964 1
      if (bo(ibv).gt.0.0) then
a1975 1
      endif
a1980 1
      if (bo(ibv).gt.0.0) then
a1991 1
      endif
d2163 1
d2229 3
d2234 7
a2240 4
 
      a(1)=c(j(1),1)-c(j(4),1)
      a(2)=c(j(1),2)-c(j(4),2)
      a(3)=c(j(1),3)-c(j(4),3)
a2537 1
      if (bo(ncubo).gt.0.0) then
a2543 1
      endif
a2548 1
      if (bo(ncubo).gt.0.0) then
a2554 1
      endif
a2619 1
      if (bo(ncubo).gt.0.0) then
a2630 1
      endif
a2635 1
      if (bo(ncubo).gt.0.0) then
a2646 1
      endif
d2671 1
d2703 6
a2708 3
      a(1)=c(i1,1)-c(i2,1)
      a(2)=c(i1,2)-c(i2,2)
      a(3)=c(i1,3)-c(i2,3)
d2809 74
a2882 74
c$$$**********************************************************************
c$$$*                                                                    *
c$$$*     Add interaction of atoms with the corresponding atom           *
c$$$*     in the surrounding periodic cells                              *
c$$$*                                                                    *
c$$$**********************************************************************
c$$$      do 20 ivl=nvpair-nvlself,nvpair
c$$$      i1=nvl1(ivl)
c$$$      ix=nvlx(ivl)
c$$$      iy=nvly(ivl)
c$$$      iz=nvlz(ivl)
c$$$      kcell=14+ix+3*iy+9*iz
c$$$      a(1)=ix*tm11
c$$$      a(2)=ix*tm21+iy*tm22
c$$$      a(3)=ix*tm31+iy*tm32+iz*tm33
c$$$      rr=sqrt(a(1)*a(1)+a(2)*a(2)+a(3)*a(3))
c$$$
c$$$      if (rr.gt.swb.or.rr.lt.0.001) goto 20
c$$$      nstmp = nstmp+1
c$$$      ity1=ia(i1,1)
c$$$      rr2=rr*rr
c$$$
c$$$      sw=1.0
c$$$      sw1=0.0
c$$$      call taper(rr,rr2)
c$$$**********************************************************************
c$$$*                                                                    *
c$$$*     Calculate vdWaals energy                                       *
c$$$*                                                                    *
c$$$**********************************************************************
c$$$      p1=p1co(ity1,ity1)
c$$$      p2=p2co(ity1,ity1)
c$$$      p3=p3co(ity1,ity1)
c$$$
c$$$      hulpw=(rr**vpar(29)+gamwco(ity1,ity1))
c$$$      rrw=hulpw**(1.0/vpar(29))
c$$$      h1=exp(p3*(1.0-rrw/p1))
c$$$      h2=exp(0.50*p3*(1.0-rrw/p1))
c$$$
c$$$      ewh=0.50*p2*(h1-2.0*h2)
c$$$      rrhuw=rr**(vpar(29)-1.0)
c$$$      dewdr=0.50*(p2*p3/p1)*(h2-h1)*rrhuw*(hulpw**-h15)
c$$$**********************************************************************
c$$$*                                                                    *
c$$$*     Calculate Coulomb energy                                       *
c$$$*                                                                    *
c$$$**********************************************************************
c$$$      q1q2=ch(i1)*ch(i1)
c$$$      hulp1=(rr*rr2+gamcco(ity1,ity1))
c$$$      eph=0.50*c1c*q1q2/(hulp1**third)
c$$$      depdr=-0.50*c1c*q1q2*rr2/(hulp1**fothird)
c$$$**********************************************************************
c$$$*                                                                    *
c$$$*     Taper correction                                               *
c$$$*                                                                    *
c$$$**********************************************************************
c$$$      ephtap=eph*sw
c$$$      depdrtap=depdr*sw+eph*sw1
c$$$      ewhtap=ewh*sw
c$$$      dewdrtap=dewdr*sw+ewh*sw1
c$$$
c$$$      ew=ew+ewhtap
c$$$      ep=ep+ephtap
c$$$
c$$$      if (icpres.eq.1) then
c$$$      do k4=1,3
c$$$      dcell(k4,i1,14)=dcell(k4,i1,14)+
c$$$     $(dewdrtap+depdrtap)*(a(k4)/rr)
c$$$      dcell(k4,i1,kcell)=dcell(k4,i1,kcell)-
c$$$     $(dewdrtap+depdrtap)*(a(k4)/rr)
c$$$      end do
c$$$      end if
c$$$
c$$$   20 continue
@


3.2.2.5
log
@Added various things to make Grasp/REAXFF run on Blue Gene
@
text
@d101 1
a101 1
C      open (65,file='fort.65',status='unknown',access='append')
d228 1
a228 1
C      open (65,file='fort.65',status='unknown',access='append')
d612 1
a612 1
C      open (65,file='fort.65',status='unknown',access='append')
d736 1
a736 1
C      open (65,file='fort.65',status='unknown',access='append')
d749 1
a749 1
C      open (65,file='fort.65',status='unknown',access='append')
d1024 1
a1024 1
C      open (65,file='fort.65',status='unknown',access='append')
d1556 1
a1556 1
C      open (65,file='fort.65',status='unknown',access='append')
d1649 1
a1649 1
C      open (65,file='fort.65',status='unknown',access='append')
d2074 1
a2074 1
C      open (65,file='fort.65',status='unknown',access='append')
d2227 1
a2227 1
C      open (65,file='fort.65',status='unknown',access='append')
d2729 1
a2729 1
C      open (65,file='fort.65',status='unknown',access='append')
d2788 1
a2788 1
      dewdr=(p2*p3/p1)*(h2-h1)*rrhuw*(hulpw**(-h15))
d2982 1
a2982 1
C      open (65,file='fort.65',status='unknown',access='append')
d3045 1
a3045 1
C      open (65,file='fort.65',status='unknown',access='append')
d3158 1
a3158 1
C      open (65,file='fort.65',status='unknown',access='append')
d3378 1
a3378 1
C*     open (65,file='fort.65',status='unknown',access='append')
d3469 1
a3469 1
C      open (65,file='fort.65',status='unknown',access='append')
@


3.2.2.6
log
@Greatly reduced memory usage.
@
text
@d607 1
d687 4
a690 5
c$$$      ix=nmpx(i1,ihu)
c$$$      iy=nmpy(i1,ihu)
c$$$      iz=nmpz(i1,ihu)
c$$$      kcell=14+ix+3*iy+9*iz
      kcell = 14
d725 1
d814 4
a817 5
c$$$      ix=nmpx(j1,ihu)
c$$$      iy=nmpy(j1,ihu)
c$$$      iz=nmpz(j1,ihu)
c$$$      kcell=14+ix+3*iy+9*iz
      kcell = 14
d895 4
a898 5
c$$$      ix=nmpx(j1,ihu)
c$$$      iy=nmpy(j1,ihu)
c$$$      iz=nmpz(j1,ihu)
c$$$      kcell=14+ix+3*iy+9*iz
      kcell = 14
d910 4
a913 5
c$$$      ix=nmpx(j1,ihu)
c$$$      iy=nmpy(j1,ihu)
c$$$      iz=nmpz(j1,ihu)
c$$$      kcell=14+ix+3*iy+9*iz
      kcell = 14
d926 4
a929 5
c$$$      ix=nmpx(j1,ihu)
c$$$      iy=nmpy(j1,ihu)
c$$$      iz=nmpz(j1,ihu)
c$$$      kcell=14+ix+3*iy+9*iz
      kcell = 14
d1011 1
d1164 4
a1167 5
c$$$      ix=nmpx(i1,ihu)
c$$$      iy=nmpy(i1,ihu)
c$$$      iz=nmpz(i1,ihu)
c$$$      kcell=14+ix+3*iy+9*iz
      kcell = 14
d1191 4
a1194 5
c$$$      ix=nmpx(i1,ihu)
c$$$      iy=nmpy(i1,ihu)
c$$$      iz=nmpz(i1,ihu)
c$$$      kcell=14+ix+3*iy+9*iz
      kcell = 14
d1207 4
a1210 5
c$$$      ix=nmpx(i1,ihu)
c$$$      iy=nmpy(i1,ihu)
c$$$      iz=nmpz(i1,ihu)
c$$$      kcell=14+ix+3*iy+9*iz
      kcell = 14
d1321 4
a1324 5
c$$$      ix=nmpx(i1,ihu)
c$$$      iy=nmpy(i1,ihu)
c$$$      iz=nmpz(i1,ihu)
c$$$      kcell=14+ix+3*iy+9*iz
      kcell = 14
d1349 4
a1352 5
c$$$      ix=nmpx(i1,ihu)
c$$$      iy=nmpy(i1,ihu)
c$$$      iz=nmpz(i1,ihu)
c$$$      kcell=14+ix+3*iy+9*iz
      kcell = 14
d1365 4
a1368 5
c$$$      ix=nmpx(i1,ihu)
c$$$      iy=nmpy(i1,ihu)
c$$$      iz=nmpz(i1,ihu)
c$$$      kcell=14+ix+3*iy+9*iz
      kcell = 14
d1491 4
a1494 5
c$$$      ix=nmpx(i1,ihu)
c$$$      iy=nmpy(i1,ihu)
c$$$      iz=nmpz(i1,ihu)
c$$$      kcell=14+ix+3*iy+9*iz
      kcell = 14
d1507 4
a1510 5
c$$$      ix=nmpx(i1,ihu)
c$$$      iy=nmpy(i1,ihu)
c$$$      iz=nmpz(i1,ihu)
c$$$      kcell=14+ix+3*iy+9*iz
      kcell = 14
d1636 1
d1931 4
a1934 5
c$$$      ix=nmpx(j(2),j(k2))
c$$$      iy=nmpy(j(2),j(k2))
c$$$      iz=nmpz(j(2),j(k2))
c$$$      kcell=14+ix+3*iy+9*iz
      kcell = 14
d1941 4
a1944 5
c$$$      ix=nmpx(j(2),ihu)
c$$$      iy=nmpy(j(2),ihu)
c$$$      iz=nmpz(j(2),ihu)
c$$$      kcell=14+ix+3*iy+9*iz
      kcell = 14
d1953 4
a1956 5
c$$$      ix=nmpx(j(2),ihu)
c$$$      iy=nmpy(j(2),ihu)
c$$$      iz=nmpz(j(2),ihu)
c$$$      kcell=14+ix+3*iy+9*iz
      kcell = 14
d1970 4
a1973 5
c$$$      ix=nmpx(j(2),ihu)
c$$$      iy=nmpy(j(2),ihu)
c$$$      iz=nmpz(j(2),ihu)
c$$$      kcell=14+ix+3*iy+9*iz
      kcell = 14
d1991 4
a1994 5
c$$$      ix=nmpx(j(2),ihu)
c$$$      iy=nmpy(j(2),ihu)
c$$$      iz=nmpz(j(2),ihu)
c$$$      kcell=14+ix+3*iy+9*iz
      kcell = 14
d2009 4
a2012 5
c$$$      ix=nmpx(j(2),ihu)
c$$$      iy=nmpy(j(2),ihu)
c$$$      iz=nmpz(j(2),ihu)
c$$$      kcell=14+ix+3*iy+9*iz
      kcell = 14
d2027 4
a2030 5
c$$$      ix=nmpx(j(2),ihu)
c$$$      iy=nmpy(j(2),ihu)
c$$$      iz=nmpz(j(2),ihu)
c$$$      kcell=14+ix+3*iy+9*iz
      kcell = 14
d2058 1
d2144 4
a2147 5
c$$$      ix=nmpx(j(2),j(3))
c$$$      iy=nmpy(j(2),j(3))
c$$$      iz=nmpz(j(2),j(3))
c$$$      kcell=14+ix+3*iy+9*iz
      kcell = 14
d2155 4
a2158 5
c$$$      ix=nmpx(j(2),j(k2))
c$$$      iy=nmpy(j(2),j(k2))
c$$$      iz=nmpz(j(2),j(k2))
c$$$      kcell=14+ix+3*iy+9*iz
      kcell = 14
d2165 4
a2168 5
c$$$      ix=nmpx(j(2),ihu)
c$$$      iy=nmpy(j(2),ihu)
c$$$      iz=nmpz(j(2),ihu)
c$$$      kcell=14+ix+3*iy+9*iz
      kcell = 14
d2206 1
d2610 4
a2613 5
c$$$      ix=nmpx(j(2),j(k2))
c$$$      iy=nmpy(j(2),j(k2))
c$$$      iz=nmpz(j(2),j(k2))
c$$$      kcell=14+ix+3*iy+9*iz
      kcell = 14
d2623 4
a2626 5
c$$$      ix=nmpx(j(2),ihu)
c$$$      iy=nmpy(j(2),ihu)
c$$$      iz=nmpz(j(2),ihu)
c$$$      kcell=14+ix+3*iy+9*iz
      kcell = 14
d2635 4
a2638 5
c$$$      ix=nmpx(j(2),ihu)
c$$$      iy=nmpy(j(2),ihu)
c$$$      iz=nmpz(j(2),ihu)
c$$$      kcell=14+ix+3*iy+9*iz
      kcell = 14
d2649 4
a2652 5
c$$$      ix=nmpx(j(2),ihu)
c$$$      iy=nmpy(j(2),ihu)
c$$$      iz=nmpz(j(2),ihu)
c$$$      kcell=14+ix+3*iy+9*iz
      kcell = 14
d2665 4
a2668 5
c$$$      ix=nmpx(j(2),ihu)
c$$$      iy=nmpy(j(2),ihu)
c$$$      iz=nmpz(j(2),ihu)
c$$$      kcell=14+ix+3*iy+9*iz
      kcell = 14
d2683 4
a2686 5
c$$$      ix=nmpx(j(2),ihu)
c$$$      iy=nmpy(j(2),ihu)
c$$$      iz=nmpz(j(2),ihu)
c$$$      kcell=14+ix+3*iy+9*iz
      kcell = 14
@


3.2.2.7
log
@Put array dimension parameters for C++ and fortran in a single header
file called reax_defs.h. Switched all fortran include statements
to cpp #include statements. Added new-lines to all *.blk files.
@
text
@d22 9
a30 9
#include "cbka.blk"
#include "cbkc.blk"
#include "cbkdhdc.blk"
#include "cbkdrdc.blk"
#include "cbkh.blk"
#include "cbkrbo.blk"
#include "cbkvalence.blk"
#include "cellcoord.blk"
#include "control.blk"
d208 19
a226 19
#include "cbka.blk"
#include "cbkabo.blk"
#include "cbkbo.blk"
#include "cbkboncor.blk"
#include "cbkbosi.blk"
#include "cbkbopi.blk"
#include "cbkbopi2.blk"
#include "cbkconst.blk"
#include "cbkdbopi2ndc.blk"
#include "cbkdbopidc.blk"
#include "cbkdbopindc.blk"
#include "cbkff.blk"
#include "cbkia.blk"
#include "cbkidbo.blk"
#include "cbknubon2.blk"
#include "cbkrbo.blk"
#include "control.blk"
#include "small.blk"
#include "cbkdbodc.blk"
d597 13
a609 13
#include "cbka.blk"
#include "cbkabo.blk"
#include "cbkconst.blk"
#include "cbkd.blk"
#include "cbkdcell.blk"
#include "cbkenergies.blk"
#include "cbkff.blk"
#include "cbkia.blk"
#include "cbkidbo.blk"
#include "cbklonpar.blk"
#include "cbknubon2.blk"
#include "control.blk"
#include "small.blk"
d709 20
a728 20
#include "cbka.blk"
#include "cbkabo.blk"
#include "cbkbo.blk"
#include "cbkbosi.blk"
#include "cbkbopi.blk"
#include "cbkbopi2.blk"
#include "cbkconst.blk"
#include "cbkcovbon.blk"
#include "cbkd.blk"
#include "cbkdbopi2ndc.blk"
#include "cbkdbopindc.blk"
#include "cbkdcell.blk"
#include "cbkenergies.blk"
#include "cbkff.blk"
#include "cbkia.blk"
#include "cbkidbo.blk"
#include "cbknubon2.blk"
#include "cbkrbo.blk"
#include "control.blk"
#include "small.blk"
d999 19
a1017 19
#include "cbka.blk"
#include "cbkabo.blk"
#include "cbkbo.blk"
#include "cbkbopi.blk"
#include "cbkbopi2.blk"
#include "cbkconst.blk"
#include "cbkd.blk"
#include "cbkdbopi2ndc.blk"
#include "cbkdbopindc.blk"
#include "cbkdcell.blk"
#include "cbkenergies.blk"
#include "cbkff.blk"
#include "cbkia.blk"
#include "cbkidbo.blk"
#include "cbklonpar.blk"
#include "cbknubon2.blk"
#include "cbkrbo.blk"
#include "control.blk"
#include "small.blk"
d1546 12
a1557 12
#include "cbka.blk"
#include "cbkbo.blk"
#include "cbkconst.blk"
#include "cbkd.blk"
#include "cbkenergies.blk"
#include "cbkff.blk"
#include "cbkia.blk"
#include "cbkidbo.blk"
#include "cbknmolat.blk"
#include "cbknubon2.blk"
#include "control.blk"
#include "small.blk"
d1630 21
a1650 21
#include "cbka.blk"
#include "cbkabo.blk"
#include "cbkbo.blk"
#include "cbkbopi.blk"
#include "cbkbopi2.blk"
#include "cbkconst.blk"
#include "cbkd.blk"
#include "cbkdbopi2ndc.blk"
#include "cbkdbopindc.blk"
#include "cbkdcell.blk"
#include "cbkdhdc.blk"
#include "cbkenergies.blk"
#include "cbkff.blk"
#include "cbkh.blk"
#include "cbkia.blk"
#include "cbkidbo.blk"
#include "cbknubon2.blk"
#include "cbkvalence.blk"
#include "control.blk"
#include "valang.blk"
#include "small.blk"
d2067 11
a2077 11
#include "cbka.blk"
#include "cbkbo.blk"
#include "cbkconst.blk"
#include "cbkd.blk"
#include "cbkdcell.blk"
#include "cbkenergies.blk"
#include "cbkidbo.blk"
#include "cbksrthb.blk"
#include "control.blk"
#include "cbkhbond.blk"
#include "small.blk"
d2206 27
a2232 27
#include "cbka.blk"
#include "cbkabo.blk"
#include "cbkbo.blk"
#include "cbkbopi.blk"
#include "cbkc.blk"
#include "cbkconst.blk"
#include "cbkd.blk"
#include "cbkdbopindc.blk"
#include "cbkdcell.blk"
#include "cbkdhdc.blk"
#include "cbkdrdc.blk"
#include "cbkenergies.blk"
#include "cbkff.blk"
#include "cbkfftorang.blk"
#include "cbkh.blk"
#include "cbkia.blk"
#include "cbkidbo.blk"
#include "cbkinit.blk"
#include "cbknubon2.blk"
#include "cbkrbo.blk"
#include "cbktorang.blk"
#include "cbktorsion.blk"
#include "cbktregime.blk"
#include "cbkvalence.blk"
#include "cellcoord.blk"
#include "control.blk"
#include "small.blk"
d2730 14
a2743 14
#include "cbka.blk"
#include "cbkc.blk"
#include "cbkch.blk"
#include "cbkconst.blk"
#include "cbkd.blk"
#include "cbkdcell.blk"
#include "cbkenergies.blk"
#include "cbkff.blk"
#include "cbkia.blk"
#include "cbknonbon.blk"
#include "cbkpairs.blk"
#include "cellcoord.blk"
#include "control.blk"
#include "small.blk"
d2994 10
a3003 10
#include "cbka.blk"
#include "cbkc.blk"
#include "cbkch.blk"
#include "cbkcha.blk"
#include "cbkd.blk"
#include "cbkefield.blk"
#include "cbkenergies.blk"
#include "cbktregime.blk"
#include "control.blk"
#include "small.blk"
d3058 2
a3059 2
#include "cbka.blk"
#include "control.blk"
d3161 13
a3173 13
#include "cbka.blk"
#include "cbkatomcoord.blk"
#include "cbkc.blk"
#include "cbkconst.blk"
#include "cbkd.blk"
#include "cbkenergies.blk"
#include "cbkrestr.blk"
#include "cbktorang.blk"
#include "cbktorsion.blk"
#include "cbktregime.blk"
#include "control.blk"
#include "small.blk"
#include "cbkinit.blk"
d3391 1
a3391 1
#include "cbka.blk"
d3477 5
a3481 5
#include "cbka.blk"
#include "cbkenergies.blk"
#include "cbktregime.blk"
#include "control.blk"
#include "cbkinit.blk"
@


3.1
log
@Finally, this is the REAXFF branch, first pass
@
text
@@

