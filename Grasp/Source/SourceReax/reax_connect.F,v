head	4.14;
access;
symbols
	ReverseComm_branch:4.5.0.4
	ADTools_branch:4.5.0.2
	Monaco_Aidan:4.0.0.12
	Root-of-Monaco_Aidan:4.0
	PPPM_Crozier2:4.0.0.10
	PPPM_Crozier:4.0
	Root-of-PPPM_Crozier:4.0
	Monaco:4.0.0.8
	PreMonaco:4.0
	Recovery-2004-04-12:4.0
	BRANCH:4.0.0.6
	PMONACO:4.0.0.4
	ROOT:4.0
	initial:4.0.0.2
	pmonaco:4.0
	Version_4_0:4.0;
locks; strict;
comment	@c @;


4.14
date	2008.11.04.00.24.50;	author athomps;	state Exp;
branches;
next	4.13;

4.13
date	2007.10.23.22.05.56;	author athomps;	state Exp;
branches;
next	4.12;

4.12
date	2007.09.09.20.58.36;	author athomps;	state Exp;
branches;
next	4.11;

4.11
date	2007.06.02.03.27.21;	author athomps;	state Exp;
branches;
next	4.10;

4.10
date	2007.05.31.00.50.12;	author athomps;	state Exp;
branches;
next	4.9;

4.9
date	2007.05.30.05.41.46;	author athomps;	state Exp;
branches;
next	4.8;

4.8
date	2007.03.15.22.01.01;	author athomps;	state Exp;
branches;
next	4.7;

4.7
date	2006.12.12.06.57.32;	author athomps;	state Exp;
branches;
next	4.6;

4.6
date	2006.11.09.20.13.52;	author athomps;	state Exp;
branches;
next	4.5;

4.5
date	2006.03.20.20.56.03;	author athomps;	state Exp;
branches
	4.5.4.1;
next	4.4;

4.4
date	2006.02.21.00.53.53;	author athomps;	state Exp;
branches;
next	4.3;

4.3
date	2006.02.20.18.12.56;	author athomps;	state Exp;
branches;
next	4.2;

4.2
date	2005.09.02.23.03.05;	author athomps;	state Exp;
branches;
next	4.1;

4.1
date	2005.08.03.17.56.30;	author athomps;	state Exp;
branches;
next	4.0;

4.0
date	2005.04.05.16.43.30;	author athomps;	state Exp;
branches;
next	1.1;

1.1
date	2005.04.02.00.37.56;	author athomps;	state Exp;
branches;
next	;

4.5.4.1
date	2006.09.07.19.49.27;	author athomps;	state Exp;
branches;
next	4.5.4.2;

4.5.4.2
date	2006.09.08.18.14.51;	author athomps;	state Exp;
branches;
next	;


desc
@@


4.14
log
@Tweaked the charge equilibration output a little.
@
text
@**********************************************************************
*                                                                    *
*     REAXFF Reactive force field program                            *
*                                                                    *
*     Developed and written by Adri van Duin, duin@@wag.caltech.edu   *
*                                                                    *
*     Copyright (c) 2001-2010 California Institute of Technology     *
*                                                                    *
*     This is an open-source program. Feel free to modify its        *
*     contents. Please keep me informed of any useful modification   *
*     or addition that you made. Please do not distribute this       *
*     program to others; if people are interested in obtaining       *
*     a copy of this program let them contact me first.              *
*                                                                    *
**********************************************************************
********************************************************************** 

      subroutine srtatom

********************************************************************** 
#include "cbka.blk"
#include "cbkatomcoord.blk"
#include "cbkff.blk"
#include "cbkia.blk"
#include "cbkqa.blk"
#include "control.blk"
#include "opt.blk"
#include "small.blk"
********************************************************************** 
*                                                                    *
*     Determine atom types in system                                 *
*                                                                    *
********************************************************************** 
*     Requires the following variables
*     ndebug - opt.blk; determines whether to debug or not; everywhere
*     xmasmd - cbka.blk; some sort of atmoic mass?; srtatom, reac.f
*     molin - opt.blk; keeps info on?; srtatom
*     nso - cbka.blk; number of atoms?; srtatom, inout.f
*     nprob - cbka.blk; does?; connect.f, inout.f, reac.f
*     nasort - cbka.blk; a sorting array; srtatom
*     ia - cbka.blk; atom numbers?; poten.f, inout.f, connect.f, charges.f
*     iag - cbka.blk; ; connect.f, inout.f, poten.f, reac.f
*     xmasat - cbka.blk; does?; srtatom, reac.f
*     amas - cbka.blk; ? ; srtatom, ffinpt, molanal, ovcor
*     qa - cbka.blk; some sort of error statement variable?; srtatom, srtbon1, inout.f, radbo
*     
c$$$      if (ndebug.eq.1) then
c$$$C      open (65,file='fort.65',status='unknown',access='append')
c$$$      write (65,*) 'In srtatom'
c$$$      call timer(65)
c$$$      close (65)
c$$$      end if

      xmasmd=0.0
      do i1=1,nso
      molin(nprob,i1)=0
      nasort(i1)=0
      end do
      do i1=1,na
      ia(i1,1)=0
      iag(i1,1)=0
      do i2=1,nso
      if (qa(i1).eq.qas(i2)) then
      ia(i1,1)=i2
      iag(i1,1)=i2
      molin(nprob,i2)=molin(nprob,i2)+1
      xmasat(i1)=amas(i2)
      xmasmd=xmasmd+amas(i2)
      nasort(i2)=nasort(i2)+1
      end if
      end do
      if (ia(i1,1).eq.0) then
      write (*,*)'Unknown atom type: ',qa(i1)
      stop 'Unknown atom type'
      end if
      end do

      return
      end
********************************************************************** 
********************************************************************** 

      subroutine molec

********************************************************************** 
#include "cbka.blk"
#include "cbkdcell.blk"
#include "cbkff.blk"
#include "cbkia.blk"
#include "cbkmolec.blk"
#include "cbknmolat.blk"
#include "control.blk"
#include "small.blk"
      dimension nmolo2(nat),iseen(nmolmax),isee2(nmolmax)
********************************************************************** 
*                                                                    *
*     Determine changes in molecules                                 *
*                                                                    *
********************************************************************** 
c$$$      if (ndebug.eq.1) then
c$$$C      open (65,file='fort.65',status='unknown',access='append')
c$$$      write (65,*) 'In molec'
c$$$      call timer(65)
c$$$      close (65)
c$$$      end if
      npreac=0

      do i1=1,nmolo
      natmol=0
      do i2=1,na
      if (ia(i2,3+mbond).eq.i1) then
      natmol=natmol+1
      nmolat(i1,natmol+1)=i2
      end if
      end do
      nmolat(i1,1)=natmol
      end do

      if (nmolo5.lt.nmolo5o) nradcount=0     !reset reaction counter
      do i1=1,nmolo5
      natmol=0
      do i2=1,na
      if (iag(i2,3+mbond).eq.i1) then
      natmol=natmol+1
      nmolat2(i1,natmol+1)=i2
      end if
      end do
      nmolat2(i1,1)=natmol
      end do
      nmolo5o=nmolo5

      do i1=nmolo+1,nmoloold
      do i2=1,nmolat(i1,1)
      nmolat(i1,1+i2)=0
      end do
      nmolat(i1,1)=0
      end do

      do i1=1,nmolo
      elmol(i1)=0.0
      do i2=1,nmolat(i1,1)
      ihu=nmolat(i1,i2+1)
      ity=ia(ihu,1)
      elmol(i1)=elmol(i1)+stlp(ity)
      end do
      end do
 
      do i1=1,nmolo5
      elmol2(i1)=0.0
      do i2=1,nmolat2(i1,1)
      ihu=nmolat2(i1,i2+1)
      ity=iag(ihu,1)
      elmol2(i1)=elmol2(i1)+stlp(ity)
      end do
      end do
 
      return
      end
********************************************************************** 
********************************************************************** 

      subroutine dista2 (n1,n2,dista,dx,dy,dz)

********************************************************************** 
#include "cbka.blk"
#include "cbkc.blk"
********************************************************************** 
*                                                                    *
*     Determine interatomic distances                                *
*                                                                    *
********************************************************************** 
c$$$*     if (ndebug.eq.1) then
c$$$C*     open (65,file='fort.65',status='unknown',access='append')
c$$$*     write (65,*) 'In dista2'
c$$$*     call timer(65)
c$$$*     close (65)
c$$$*     end if
      
      dx=c(n1,1)-c(n2,1)
      dy=c(n1,2)-c(n2,2)
      dz=c(n1,3)-c(n2,3)
      dista=sqrt(dx*dx+dy*dy+dz*dz)

      return
      end
********************************************************************** 
********************************************************************** 

      subroutine srtbon1(lprune,lhb,hbcut_in)

********************************************************************** 
#include "cbka.blk"
#include "cbkabo.blk"
#include "cbkbo.blk"
#include "cbkbosi.blk"
#include "cbkbopi.blk"
#include "cbkbopi2.blk"
#include "cbkc.blk"
#include "cbkch.blk"
#include "cbkconst.blk"
#include "cbkdbopidc.blk"
#include "cbkdrdc.blk"
#include "cbkia.blk"
#include "cbknubon2.blk"
#include "cbknvlbo.blk"
#include "cbkpairs.blk"
#include "cbknvlown.blk"
#include "cbkqa.blk"
#include "cbkrbo.blk"
#include "cellcoord.blk"
#include "control.blk"
#include "small.blk"
#include "cbkdbodc.blk"
#include "cbksrtbon1.blk"
#include "cbkff.blk"
#include "cbksrthb.blk"
      logical found
      integer nboncol(nboallmax)
      integer iball(nboallmax,3)

********************************************************************** 
*                                                                    *
*     Determine connections within the molecule                      *
*                                                                    *
********************************************************************** 
c$$$      if (ndebug.eq.1) then
c$$$C      open (65,file='fort.65',status='unknown',access='append')
c$$$      write (65,*) 'In srtbon1'
c$$$      call timer(65)
c$$$      close (65)
c$$$      end if

c Transfer hbcut from C++ calling function
      hbcut = hbcut_in

      do i1=1,na
      abo(i1)=0.0d0
      end do
      nbonall=0
      nbon2=0
      nsbmax=0
      nsbma2=0

      if (imolde.eq.0) then

      nmolo=0
      nmolo5=0
      end if
      if (imolde.eq.0) then
      do i1=1,na
      do i2=2,mbond+3
      ia(i1,i2)=0
      iag(i1,i2)=0
      end do
      end do
     
      else

      do i1=1,na
      do i2=2,mbond+2
      ia(i1,i2)=0
      iag(i1,i2)=0
      end do
      end do

      end if

      do i1=1,na
      do i2=1,mbond
      nubon1(i1,i2)=0
      nubon2(i1,i2)=0
      end do
      end do

* First detect all bonds and create preliminary list
 
      do 11 ivl=1,nvpair
      if (nvlbo(ivl).eq.0) goto 11  !not in bond order range
      i1=nvl1(ivl)
      i2=nvl2(ivl)
      call dista2(i1,i2,dis,dxm,dym,dzm)
      ih1=ia(i1,1)
      ih2=ia(i2,1)
      disdx=dxm/dis
      disdy=dym/dis
      disdz=dzm/dis
      itype=0
      if (ih1.gt.ih2) then
      ih1=ia(i2,1)
      ih2=ia(i1,1)
      end if
      do i3=1,nboty2
      if (ih1.eq.nbs(i3,1).and.ih2.eq.nbs(i3,2)) itype=i3
      end do
      if (itype.eq.0.and.rat(ih1).gt.zero.and.rat(ih2).gt.zero) then
c$$$      call mdsav(1,qfile(nprob))
      write (*,*)qa(i1),'-',qa(i2),'Fatal: Unknown bond in molecule'
      stop 
      end if

      rhulp=dis/rob1(ih1,ih2)
 
********************************************************************** 
*                                                                    *
*     Determine bond orders                                          *
*                                                                    *
********************************************************************** 
      rh2=zero
      rh2p=zero
      rh2pp=zero
      ehulp=zero
      ehulpp=zero
      ehulppp=zero
      bomh=bom(itype)
      if (rapt(ih1).gt.zero.and.rapt(ih2).gt.zero) then
      rhulp2=dis/rob2(ih1,ih2)
      rh2p=rhulp2**ptp(itype)
      ehulpp=bomh*exp(pdp(itype)*rh2p)
      end if
      if (vnq(ih1).gt.zero.and.vnq(ih2).gt.zero) then
      rhulp3=dis/rob3(ih1,ih2)
      rh2pp=rhulp3**popi(itype)
      ehulppp=bomh*exp(pdo(itype)*rh2pp)
      end if

      if (rat(ih1).gt.zero.and.rat(ih2).gt.zero) then
      rh2=rhulp**bop2(itype)
      ehulp=bomh*(1.0+cutoff)*exp(bop1(itype)*rh2)
      end if

      bor=ehulp+ehulpp+ehulppp

      j1=i1
      j2=i2

********************************************************************** 
*                                                                    *
*     Determine bond orders                                          *
*                                                                    *
********************************************************************** 
      if (bor.gt.cutoff) then
      nbonall=nbonall+1
      if (nbonall.gt.nboallmax) then 
      write (6,*)'nbonall = ',nbonall,
     $ ' reax_defs.h::NBOALLMAXDEF = ',NBOALLMAXDEF,
     $     ' after',ivl, ' of ',nvpair,' pairs completed.' 
      stop 'Too many bonds; maybe wrong cell parameters.'
      end if
      iball(nbonall,1)=itype
      iball(nbonall,2)=j1
      iball(nbonall,3)=j2

      ia(i1,2)=ia(i1,2)+1
      if (ia(i1,2).gt.mbond) then 
         write (6,*)'ia(i1,2) = ',ia(i1,2),
     $        ' reax_defs.h::MBONDDEF = ',MBONDDEF,
     $        ' after',ivl, ' of ',nvpair,' pairs completed.' 
         stop 'Too many bonds on atom. Increase MBONDDEF'
      end if

      if (i1.ne.i2) then
         ia(i2,2)=ia(i2,2)+1
         if (ia(i2,2).gt.mbond) then 
            write (6,*)'ia(i1,2) = ',ia(i1,2),
     $           ' reax_defs.h::MBONDDEF = ',MBONDDEF,
     $           ' after',ivl, ' of ',nvpair,' pairs completed.' 
            stop 'Too many bonds on atom. Increase MBONDDEF'
         end if
      endif

      ia(i1,ia(i1,2)+2)=i2 
      ia(i2,ia(i2,2)+2)=i1 
      if (abs(de1(iball(nbonall,1))).gt.-0.01) then
      nubon2(i1,ia(i1,2))=nbonall
      nubon2(i2,ia(i2,2))=nbonall
      else
      nbonall=nbonall-1      !Inorganics
      end if
      end if
 11   continue

********************************************************************** 
*                                                                    *
*     lprune controls level of bond-pruning performed to increase    *
*     performance. For correct results, it should be set to 4.       *
*     However, making it smaller can speed up                        *
*     force calculation and may not have a big effect on forces.     *
*     Setting it to 0 turns off pruning, useful for debugging.       *
*                                                                    *
********************************************************************** 
********************************************************************* 
*                                                                    *
*     lhb controls whether or not to unprune ghost bonds that        *
*     may possibly form ghost hydrogen bonds.                        *
*     Setting it to 1 causes unpruning, and so is the safe option.   *
*     If lprune = 0, then pruning is not used, results are exact     *
*     and lhb has no effect.                                         *
*                                                                    *
********************************************************************** 
      if (lprune .gt. 0) then
********************************************************************** 
*                                                                    *
*     Eliminate bonds that are not in 1-6 interaction                *
*     with local atom, or closer.                                    *
*     Need additional sweep to catch possible hydrogen bonds         *
*                                                                    *
********************************************************************** 

      ntmp0 = 0
      ntmp1 = 0
      ntmp2 = 0
      ntmp3 = 0
      ntmp4 = 0
      ntmp5 = 0
      ntmp6 = 0
      ntmphb = 0

* color 1 are bonds with two local atoms
* color 2 are bonds with one local atom
* color 3 are bonds adjacent to bond with one local atom

      do i1 = 1,nbonall
         if (iball(i1,2).le.na_local) then
            if (iball(i1,3).le.na_local) then
               nboncol(i1) = 1
               ntmp1 = ntmp1+1
            else
               nboncol(i1) = 2
               ntmp2 = ntmp2+1
            endif
         else if (iball(i1,3).le.na_local) then
            nboncol(i1) = 2
            ntmp2 = ntmp2+1
         else
            nboncol(i1) = 0
         endif
      end do

      if (lprune .ge. 3) then
      do i1 = 1,nbonall
         if (nboncol(i1).eq.2) then
            if (iball(i1,2).le.na_local) then
               i3=iball(i1,3)
            else
               i3=iball(i1,2)
            endif
           
            do i4 = 1,ia(i3,2)
               i5=nubon2(i3,i4)
               if (nboncol(i5).eq.0) then
                  nboncol(i5)=3
                  ntmp3 = ntmp3+1
               endif
            end do
         endif
      end do
      endif
* color 4 bonds are part of a 1-4 interaction with local atom

      if (lprune .ge. 4) then
      do i1 = 1,nbonall
         if (nboncol(i1).eq.3) then
* One end definitely has a bond of color 2
* Find it and color bonds on other end 4
            i3=iball(i1,2)
            i3b=0
            do i4 = 1,ia(i3,2)
               i5=nubon2(i3,i4)
               if (nboncol(i5).eq.2) then
                  i3b=iball(i1,3)
               endif
            end do

            if (i3b.eq.0) then
               i3=iball(i1,3)
               i3b=0
               do i4 = 1,ia(i3,2)
                  i5=nubon2(i3,i4)
                  if (nboncol(i5).eq.2) then
                     i3b=iball(i1,2)
                  endif
               end do
            endif

            if (i3b.eq.0) then
               stop 'Could not find color 2 from color 3 bond'
            endif

            do i4 = 1,ia(i3b,2)
               i5=nubon2(i3b,i4)
               if (nboncol(i5).eq.0) then
                  nboncol(i5)=4
                  ntmp4 = ntmp4+1
               endif
            end do
           
         endif
      end do
      endif

* color 5 bonds are part of a 1-5 interaction with local atom

      if (lprune .ge. 5) then
      do i1 = 1,nbonall
         if (nboncol(i1).eq.4) then
* One end definitely has a bond of color 3
* Find it and color bonds on other end 5
            i3=iball(i1,2)
            i3b=0
            do i4 = 1,ia(i3,2)
               i5=nubon2(i3,i4)
               if (nboncol(i5).eq.3) then
                  i3b=iball(i1,3)
               endif
            end do

            if (i3b.eq.0) then
               i3=iball(i1,3)
               i3b=0
               do i4 = 1,ia(i3,2)
                  i5=nubon2(i3,i4)
                  if (nboncol(i5).eq.3) then
                     i3b=iball(i1,2)
                  endif
               end do
            endif

            if (i3b.eq.0) then
               stop 'Could not find color 3 from color 4 bond'
            endif

            do i4 = 1,ia(i3b,2)
               i5=nubon2(i3b,i4)
               if (nboncol(i5).eq.0) then
                  nboncol(i5)=5
                  ntmp5 = ntmp5+1
               endif
            end do
           
         endif
      end do
      endif

* color 6 bonds are part of a 1-6 interaction with local atom

      if (lprune .ge. 6) then
      do i1 = 1,nbonall
         if (nboncol(i1).eq.5) then
* One end definitely has a bond of color 4
* Find it and color bonds on other end 6
            i3=iball(i1,2)
            i3b=0
            do i4 = 1,ia(i3,2)
               i5=nubon2(i3,i4)
               if (nboncol(i5).eq.4) then
                  i3b=iball(i1,3)
               endif
            end do

            if (i3b.eq.0) then
               i3=iball(i1,3)
               i3b=0
               do i4 = 1,ia(i3,2)
                  i5=nubon2(i3,i4)
                  if (nboncol(i5).eq.4) then
                     i3b=iball(i1,2)
                  endif
               end do
            endif

            if (i3b.eq.0) then
               stop 'Could not find color 4 from color 5 bond'
            endif

            do i4 = 1,ia(i3b,2)
               i5=nubon2(i3b,i4)
               if (nboncol(i5).eq.0) then
                  nboncol(i5)=6
                  ntmp6 = ntmp6+1
               endif
            end do
           
         endif
      end do
      endif

* Catch all the possible hydrogen bonds
* This section replicates the logic used in srthb()
      if (lhb .eq. 1) then
c  Outer loop must be Verlet list, because ia() does not store Verlet entries,
c  but it does store bond entries in nubon2()
      do ivl=1,nvpair    !Use Verlet-list to find donor-acceptor pairs

      j1=nvl1(ivl)
      j2=nvl2(ivl)
      ihhb1=nphb(ia(j1,1))
      ihhb2=nphb(ia(j2,1))

      if (ihhb1.gt.ihhb2) then        !Make j1 donor(H) atom and j2 acceptor(O) atom
      j2=nvl1(ivl)
      j1=nvl2(ivl)
      ihhb1=nphb(ia(j1,1))
      ihhb2=nphb(ia(j2,1))
      end if

*     Only need to compute bonds where j1 is local
      if (j1 .le. na_local) then

      if (ihhb1.eq.1.and.ihhb2.eq.2) then
         call dista2(j1,j2,dishb,dxm,dym,dzm)
         if (dishb.lt.hbcut) then
            do i23=1,ia(j1,2)   !Search for acceptor atoms bound to donor atom
               if (nboncol(nubon2(j1,i23)).eq.0) then
                  j3=ia(j1,2+i23)
                  if (nphb(ia(j3,1)).eq.2.and.j3.ne.j2) then
                     nboncol(nubon2(j1,i23))=-1
                     ntmphb = ntmphb+1
                  endif
               endif
            end do
         end if
      end if
      end if
      end do
      end if

* Compact the list, removing all uncolored bonds

      nbon = 0
      do i1 = 1,nbonall
         if (nboncol(i1).eq.0) then
            ntmp0=ntmp0+1
         else
            nbon = nbon+1

            if (nbon.gt.nbomax) then 
               write (6,*)nbon,nbomax
               write (6,*)'nbon = ',nbon,' reax_defs.h::NBOMAXDEF = ',
     $              NBOMAXDEF,' after',i1, ' of ',nbonall,
     $              ' initial bonds completed.' 
               stop 'Too many pruned bonds; increase NBOMAXDEF'
            end if


            ib(nbon,1) = iball(i1,1)
            ib(nbon,2) = iball(i1,2)
            ib(nbon,3) = iball(i1,3)
         endif
      end do

********************************************************************** 
*                                                                    *
*     Do not perform ghost-bond pruning                              *
*                                                                    *
********************************************************************** 

      else

      nbon = 0
      do i1 = 1,nbonall
         nbon = nbon+1

         if (nbon.gt.nbomax) then 
            write (6,*)nbon,nbomax
            write (6,*)'nbon = ',nbon,' reax_defs.h::NBOMAXDEF = ',
     $           NBOMAXDEF,' after',i1, ' of ',nbonall,
     $           ' initial bonds completed.' 
            stop 'Too many pruned bonds; increase NBOMAXDEF'
         end if

         ib(nbon,1) = iball(i1,1)
         ib(nbon,2) = iball(i1,2)
         ib(nbon,3) = iball(i1,3)
      end do

      endif

      do i1=1,na
      do i2=2,mbond+2
      ia(i1,i2)=0
      iag(i1,i2)=0
      end do
      end do

* Generate full set of bond data structures

      do 10 i0 = 1,nbon
      i1 = ib(i0,2)
      i2 = ib(i0,3)
      call dista2(i1,i2,dis,dxm,dym,dzm)
*     do 10 i1=1,na-1
*     do 10 i2=i1+1,na
*     call dista2(i1,i2,dis,dxm,dym,dzm)
      ih1=ia(i1,1)
      ih2=ia(i2,1)
*     if (dis.gt.5.0*rob) goto 10
      disdx=dxm/dis
      disdy=dym/dis
      disdz=dzm/dis
      itype=0
      if (ih1.gt.ih2) then
      ih1=ia(i2,1)
      ih2=ia(i1,1)
      end if
      do i3=1,nboty2
      if (ih1.eq.nbs(i3,1).and.ih2.eq.nbs(i3,2)) itype=i3
      end do
      if (itype.eq.0.and.rat(ih1).gt.zero.and.rat(ih2).gt.zero) then
c$$$      call mdsav(1,qfile(nprob))
      write (*,*)qa(i1),'-',qa(i2),'Fatal: Unknown bond in molecule'
      stop 
      end if

      rhulp=dis/rob1(ih1,ih2)
 
********************************************************************** 
*                                                                    *
*     Determine bond orders                                          *
*                                                                    *
********************************************************************** 
      rh2=zero
      rh2p=zero
      rh2pp=zero
      ehulp=zero
      ehulpp=zero
      ehulppp=zero
      bomh=bom(itype)
      if (rapt(ih1).gt.zero.and.rapt(ih2).gt.zero) then
      rhulp2=dis/rob2(ih1,ih2)
      rh2p=rhulp2**ptp(itype)
      ehulpp=bomh*exp(pdp(itype)*rh2p)
      end if
      if (vnq(ih1).gt.zero.and.vnq(ih2).gt.zero) then
      rhulp3=dis/rob3(ih1,ih2)
      rh2pp=rhulp3**popi(itype)
      ehulppp=bomh*exp(pdo(itype)*rh2pp)
      end if

      if (rat(ih1).gt.zero.and.rat(ih2).gt.zero) then
      rh2=rhulp**bop2(itype)
      ehulp=bomh*(1.0+cutoff)*exp(bop1(itype)*rh2)
      end if

      bor=ehulp+ehulpp+ehulppp
      borsi=ehulp
      borpi=ehulpp
      borpi2=ehulppp
      dbordrob=bop2(itype)*bop1(itype)*rh2*(1.0/dis)*ehulp+
     $ptp(itype)*pdp(itype)*rh2p*(1.0/dis)*ehulpp+
     $popi(itype)*pdo(itype)*rh2pp*(1.0/dis)*ehulppp
      dborsidrob=bop2(itype)*bop1(itype)*rh2*(1.0/dis)*ehulp
      dborpidrob=ptp(itype)*pdp(itype)*rh2p*(1.0/dis)*ehulpp
      dborpi2drob=popi(itype)*pdo(itype)*rh2pp*(1.0/dis)*ehulppp
     
      nbon2=nbon2+1
      j1=i1
      j2=i2

********************************************************************** 
*                                                                    *
*     Determine bond orders                                          *
*                                                                    *
********************************************************************** 
      ib(i0,1)=itype
      ib(i0,2)=j1
      ib(i0,3)=j2
      ibsym(i0)=ivl
      drdc(i0,1,1)=disdx
      drdc(i0,2,1)=disdy
      drdc(i0,3,1)=disdz
      drdc(i0,1,2)=-disdx
      drdc(i0,2,2)=-disdy
      drdc(i0,3,2)=-disdz
      abo(i1)=abo(i1)+bor-cutoff
      if (i1.ne.i2) abo(i2)=abo(i2)+bor-cutoff
      bo(i0)=bor-cutoff
      bos(i0)=bor-cutoff
      bosi(i0)=borsi-cutoff
      bopi(i0)=borpi
      bopi2(i0)=borpi2
      rbo(i0)=dis
      dbodr(i0)=dbordrob
*     dbosidr(i0)=dborsidrob
      dbopidr(i0)=dborpidrob
      dbopi2dr(i0)=dborpi2drob
      dbodc(i0,1,1)=dbodr(i0)*drdc(i0,1,1)
      dbodc(i0,2,1)=dbodr(i0)*drdc(i0,2,1)
      dbodc(i0,3,1)=dbodr(i0)*drdc(i0,3,1)
      dbodc(i0,1,2)=dbodr(i0)*drdc(i0,1,2)
      dbodc(i0,2,2)=dbodr(i0)*drdc(i0,2,2)
      dbodc(i0,3,2)=dbodr(i0)*drdc(i0,3,2)
*     dbosidc(i0,1,1)=dbosidr(i0)*drdc(i0,1,1)
*     dbosidc(i0,2,1)=dbosidr(i0)*drdc(i0,2,1)
*     dbosidc(i0,3,1)=dbosidr(i0)*drdc(i0,3,1)
*     dbosidc(i0,1,2)=dbosidr(i0)*drdc(i0,1,2)
*     dbosidc(i0,2,2)=dbosidr(i0)*drdc(i0,2,2)
*     dbosidc(i0,3,2)=dbosidr(i0)*drdc(i0,3,2)
      dbopidc(i0,1,1)=dbopidr(i0)*drdc(i0,1,1)
      dbopidc(i0,2,1)=dbopidr(i0)*drdc(i0,2,1)
      dbopidc(i0,3,1)=dbopidr(i0)*drdc(i0,3,1)
      dbopidc(i0,1,2)=dbopidr(i0)*drdc(i0,1,2)
      dbopidc(i0,2,2)=dbopidr(i0)*drdc(i0,2,2)
      dbopidc(i0,3,2)=dbopidr(i0)*drdc(i0,3,2)
      dbopi2dc(i0,1,1)=dbopi2dr(i0)*drdc(i0,1,1)
      dbopi2dc(i0,2,1)=dbopi2dr(i0)*drdc(i0,2,1)
      dbopi2dc(i0,3,1)=dbopi2dr(i0)*drdc(i0,3,1)
      dbopi2dc(i0,1,2)=dbopi2dr(i0)*drdc(i0,1,2)
      dbopi2dc(i0,2,2)=dbopi2dr(i0)*drdc(i0,2,2)
      dbopi2dc(i0,3,2)=dbopi2dr(i0)*drdc(i0,3,2)
      ia(i1,2)=ia(i1,2)+1
      if (i1.ne.i2) ia(i2,2)=ia(i2,2)+1
      ia(i1,ia(i1,2)+2)=i2 
      ia(i2,ia(i2,2)+2)=i1 
      if (ia(i1,2).gt.nsbma2) nsbma2=ia(i1,2)
      if (ia(i2,2).gt.nsbma2) nsbma2=ia(i2,2)
      if (bor.gt.cutof3) then
      iag(i1,2)=iag(i1,2)+1
      iag(i2,2)=iag(i2,2)+1
      iag(i1,iag(i1,2)+2)=i2 
      iag(i2,iag(i2,2)+2)=i1 
      nubon1(i1,iag(i1,2))=i0
      nubon1(i2,iag(i2,2))=i0
      if (iag(i1,2).gt.nsbmax) nsbmax=iag(i1,2)
      if (iag(i2,2).gt.nsbmax) nsbmax=iag(i2,2)
      end if
      nubon2(i1,ia(i1,2))=i0
      nubon2(i2,ia(i2,2))=i0

   10 continue

********************************************************************** 
*                                                                    *
*     Sort molecules                                                 *
*                                                                    *
********************************************************************** 
      imolde = 1
      if (imolde.eq.1) return    !fixed molecular definitions

      FOUND=.FALSE.
      DO 31 K1=1,NA
      IF (IA(K1,3+mbond).EQ.0) FOUND=.TRUE.
   31 IF (IA(K1,3+mbond).GT.NMOLO) NMOLO=IA(K1,3+mbond)
      IF (.NOT.FOUND) GOTO 32
************************************************************************
*                                                                      *
*     Molecule numbers are assigned. No restrictions are made for the  *
*     sequence of the numbers in the connection table.                 *
*                                                                      *
************************************************************************
      N3=1
   34 N2=N3
      NMOLO=NMOLO+1
      if (nmolo.gt.nmolmax) then
      write (*,*)nmolmax
      write (*,*)'Too many molecules in system; increase nmolmax'
      write (*,*)'nmolmax = ',nmolmax
      write (*,*)'nmolo = ',nmolo
      write (*,*)'n2 = ',n2
      stop 'Too many molecules in system'
      end if
      IA(N2,3+mbond)=NMOLO
   37 FOUND=.FALSE.
      DO 36 N1=N2+1,NA
      IF (IA(N1,3+mbond).NE.0) GOTO 36
      DO 35 L=1,mbond
      IF (IA(N1,l+2).EQ.0) GOTO 36
      IF (IA(IA(N1,l+2),3+mbond).EQ.NMOLO) THEN
      FOUND=.TRUE.
      IA(N1,3+mbond)=NMOLO
      GOTO 36
      ENDIF
   35 CONTINUE
   36 CONTINUE
      IF (FOUND) GOTO 37
      DO 33 N3=N2+1,NA
   33 IF (IA(N3,3+mbond).EQ.0) GOTO 34
************************************************************************
*                                                                      *
*     The assigned or input molecule numbers are checked for their     *
*     consistency.                                                     *
*                                                                      *
************************************************************************
   32 FOUND=.FALSE.
      DO 42 N1=1,NA
      DO 41 L=1,mbond
      IF (IA(N1,L+2).EQ.0) GOTO 42
      IF (IA(IA(N1,L+2),3+mbond).NE.IA(N1,3+mbond)) THEN
      FOUND=.TRUE.
      ENDIF
   41 CONTINUE
   42 CONTINUE
      IF (FOUND) THEN
      write (7,1000)NA,qmol
      do i1=1,NA
      write (7,1100)i1,ia(i1,1),(ia(i1,2+i2),i2=1,nsbmax),
     $ia(i1,3+mbond)
      end do
      write (7,*)tm11,tm22,tm33,angle(1),angle(2),angle(3)
      STOP' Mol.nrs. not consistent; maybe wrong cell parameters'
      end if
********************************************************************** 
*                                                                    *
*     Sort molecules again                                           *
*     This sort is on iag, enforces bond order cutoff                *
*                                                                    *
********************************************************************** 
      FOUND=.FALSE.
      DO 61 K1=1,NA
      IF (IAG(K1,3+mbond).EQ.0) FOUND=.TRUE.
   61 IF (IAG(K1,3+mbond).GT.NMOLO5) NMOLO5=IAG(K1,3+mbond)
      IF (.NOT.FOUND) GOTO 62
************************************************************************
*                                                                      *
*     Molecule numbers are assigned. No restrictions are made for the  *
*     sequence of the numbers in the connection table.                 *
*                                                                      *
************************************************************************
      N3=1
   64 N2=N3
      NMOLO5=NMOLO5+1
      if (nmolo5.gt.nmolmax) stop 'Too many molecules in system'
      IAG(N2,3+mbond)=NMOLO5
   67 FOUND=.FALSE.
      DO 66 N1=N2+1,NA
      IF (IAG(N1,3+mbond).NE.0) GOTO 66
      DO 65 L=1,mbond
      IF (IAG(N1,l+2).EQ.0) GOTO 66
      IF (IAG(IAG(N1,l+2),3+mbond).EQ.NMOLO5) THEN
      FOUND=.TRUE.
      IAG(N1,3+mbond)=NMOLO5
      GOTO 66
      ENDIF
   65 CONTINUE
   66 CONTINUE
      IF (FOUND) GOTO 67
      DO 63 N3=N2+1,NA
   63 IF (IAG(N3,3+mbond).EQ.0) GOTO 64
************************************************************************
*                                                                      *
*     The assigned or input molecule numbers are checked for their     *
*     consistency.                                                     *
*                                                                      *
************************************************************************
   62 FOUND=.FALSE.
      DO 72 N1=1,NA
      DO 71 L=1,mbond
      IF (IAG(N1,L+2).EQ.0) GOTO 72
      IF (IAG(IAG(N1,L+2),3+mbond).NE.IAG(N1,3+mbond)) THEN
      FOUND=.TRUE.
      ENDIF
   71 CONTINUE
   72 CONTINUE
      IF (FOUND) THEN
      write (7,1000)NA,qmol
      do i1=1,NA
      write (7,1100)i1,iag(i1,1),(iag(i1,2+i2),i2=1,nsbmax),
     $iag(i1,3+mbond)
      end do
      write (7,*)tm11,tm22,tm33,angle(1),angle(2),angle(3)
      STOP' Mol.nrs. not consistent; maybe wrong cell parameters'
      ENDIF

********************************************************************** 
*                                                                    *
*     Format part                                                    *
*                                                                    *
********************************************************************** 
 1000 format (i3,2x,a60)
 1100 format (8i3)
      end
********************************************************************** 
********************************************************************** 

      subroutine srtang

********************************************************************** 
#include "cbka.blk"
#include "cbkbo.blk"
#include "cbknubon2.blk"
#include "cbkff.blk"
#include "cbkia.blk"
#include "cbkrbo.blk"
#include "cbkvalence.blk"
#include "cellcoord.blk"
#include "control.blk"
#include "small.blk"

      dimension a(3),b(3),j(3)
      dimension ityva(100)

********************************************************************** 
*                                                                    *
*     Find valency angles in molecule                                *
*                                                                    *
********************************************************************** 
c$$$      if (ndebug.eq.1) then
c$$$C      open (65,file='fort.65',status='unknown',access='append')
c$$$      write (65,*) 'In srtang'
c$$$      call timer(65)
c$$$      close (65)
c$$$      end if

      nval=0
      if (nvaty.eq.0) return
      do iindexatom=1,na
      inumbonds=ia(iindexatom,2)
      do jindexbond=1,inumbonds-1
      jindexbondlist = nubon2(iindexatom,jindexbond)
      if (bo(jindexbondlist).lt.cutof2) goto 51
      k4=ib(jindexbondlist,2)
      k5=ib(jindexbondlist,3)
      do kindexbond=jindexbond+1,inumbonds
      kindexbondlist = nubon2(iindexatom,kindexbond)
      iju=0
      if (bo(kindexbondlist).lt.cutof2) goto 50
      if (bo(jindexbondlist)*bo(kindexbondlist).lt.0.001) goto 50
      k7=ib(kindexbondlist,2)
      k8=ib(kindexbondlist,3)

*     Exclude angles that have no local atoms.
*     Angles with non-local center atom are not needed for angle
*     energies, but are needed to construct torsions. 
      if ( k4 .le. na_local .or. 
     $     k5 .le. na_local .or. 
     $     k7 .le. na_local .or. 
     $     k8 .le. na_local) then 

      if (k4.eq.k7.and.k5.eq.k8.and.k4.ne.k8.and.k5.ne.k7) then
      nval=nval+1
      iv(nval,2)=k5
      iv(nval,3)=k4
      iv(nval,4)=k8
      iv(nval,5)=jindexbondlist
      iv(nval,6)=kindexbondlist
      nval=nval+1
      iv(nval,2)=k4
      iv(nval,3)=k5
      iv(nval,4)=k7
      iv(nval,5)=jindexbondlist
      iv(nval,6)=kindexbondlist
      iju=2
      write(6,*) 'Aaaah!'
      end if
      if (iju.eq.2) goto 50

      if (k4.eq.k8.and.k5.eq.k7.and.k4.ne.k7.and.k5.ne.k8) then
      nval=nval+1
      iv(nval,2)=k5
      iv(nval,3)=k4
      iv(nval,4)=k7
      iv(nval,5)=jindexbondlist
      iv(nval,6)=kindexbondlist
      nval=nval+1
      iv(nval,2)=k4
      iv(nval,3)=k5
      iv(nval,4)=k8
      iv(nval,5)=jindexbondlist
      iv(nval,6)=kindexbondlist
      iju=2
      write(6,*) 'Aaaah!'
      end if
      if (iju.eq.2) goto 50

      if (k4.eq.k7) then
      nval=nval+1
      iv(nval,2)=k5
      iv(nval,3)=k4
      iv(nval,4)=k8
      iv(nval,5)=jindexbondlist
      iv(nval,6)=kindexbondlist
      iju=1
      end if
      if (iju.eq.1) goto 50

      if (k4.eq.k8) then
      nval=nval+1
      iv(nval,2)=k5
      iv(nval,3)=k4
      iv(nval,4)=k7
      iv(nval,5)=jindexbondlist
      iv(nval,6)=kindexbondlist
      iju=1
      end if
      if (iju.eq.1) goto 50

      if (k5.eq.k7) then
      nval=nval+1
      iv(nval,2)=k4
      iv(nval,3)=k5
      iv(nval,4)=k8
      iv(nval,5)=jindexbondlist
      iv(nval,6)=kindexbondlist
      iju=1
      end if
      if (iju.eq.1) goto 50

      if (k5.eq.k8) then
      nval=nval+1
      iv(nval,2)=k4
      iv(nval,3)=k5
      iv(nval,4)=k7
      iv(nval,5)=jindexbondlist
      iv(nval,6)=kindexbondlist
      iju=1
      end if
      if (iju.eq.1) goto 50

      write (6,*)'nval = ',nval,
     $        ' after',iindexatom, ' of ',na,' atoms completed.'
      stop 'Adjacent bonds did not make an angle'

      endif

   50 continue

      if (nval.gt.nvamax) then
         write (6,*)'nval = ',nval,' reax_defs.h::NVAMAXDEF = ',
     $        NVAMAXDEF,
     $        ' after',iindexatom, ' of ',na,' atoms completed.'
         stop 'Too many valency angles. Increase NVAMAXDEF'
      endif

      if (iju.gt.0) then
**********************************************************************
*                                                                    *
*     Determine force field types of angles                          *
*                                                                    *
**********************************************************************
      ityva(1)=0
      ih1=ia(iv(nval,2),1)
      ih2=ia(iv(nval,3),1)
      ih3=ia(iv(nval,4),1)
      if (ih3.lt.ih1) then
      ih3=ia(iv(nval,2),1)
      ih2=ia(iv(nval,3),1)
      ih1=ia(iv(nval,4),1)
      end if

      nfound=0
      do i3=1,nvaty
      if (ih1.eq.nvs(i3,1).and.ih2.eq.nvs(i3,2).and.
     $ih3.eq.nvs(i3,3)) then
      nfound=nfound+1
      ityva(nfound)=i3
      end if
      end do

      if (ityva(1).eq.0.or.abs(vka(ityva(1))).lt.0.001) then   !Valence angle does not exist in force field;ignore
      nval=nval-1
      ihul=0
      else
      iv(nval,1)=ityva(1)
      ihul=1

      do i3=1,nfound-1           !Found multiple angles of the same type
      nval=nval+1
      iv(nval,1)=ityva(i3+1)
      do i4=2,6
      iv(nval,i4)=iv(nval-1,i4)
      end do

      end do

      end if

      if (iju.eq.2) then
      ityva(1)=0
      ih1=ia(iv(nval-ihul,2),1)
      ih2=ia(iv(nval-ihul,3),1)
      ih3=ia(iv(nval-ihul,4),1)
      if (ih3.lt.ih1) then
      ih3=ia(iv(nval-ihul,2),1)
      ih2=ia(iv(nval-ihul,3),1)
      ih1=ia(iv(nval-ihul,4),1)
      end if

      nfound=0
      do i3=1,nvaty
      if (ih1.eq.nvs(i3,1).and.ih2.eq.nvs(i3,2).and.
     $ih3.eq.nvs(i3,3)) then
      nfound=nfound+1
      ityva(nfound)=i3
      end if
      end do

      if (ityva(1).eq.0.or.abs(vka(ityva(1))).lt.0.001) then   !Valence angle does not exist in force field;ignore
      if (ihul.eq.1) then
      do i3=1,6
      iv(nval-1,i3)=iv(nval,i3)
      end do
      end if
      nval=nval-1
      else
      iv(nval-ihul,1)=ityva(1)

      do i3=1,nfound-1           !Found multiple angles of the same type
      nval=nval+1
      iv(nval,1)=ityva(i3+1)
      do i4=2,6
      iv(nval,i4)=iv(nval-1,i4)
      end do

      end do

      end if

      end if

      end if

      end do
   51 continue
      end do
      end do

      nbonop=0
     
      return
      end
********************************************************************** 
********************************************************************** 

      subroutine srttor

********************************************************************** 
#include "cbka.blk"
#include "cbkc.blk"
#include "cbkbo.blk"
#include "cbkrbo.blk"
#include "cbkia.blk"
#include "cbktorsion.blk"
#include "cbkvalence.blk"
#include "cellcoord.blk"
#include "control.blk"
#include "small.blk"
#include "cbknubon2.blk"
********************************************************************** 
*                                                                    *
*     Find torsion angles in molecule                                *
*                                                                    *
********************************************************************** 
c$$$      if (ndebug.eq.1) then
c$$$      open (65,file='fort.65',status='unknown',access='append')
c$$$      write (65,*) 'In srttor'
c$$$      call timer(65)
c$$$      close (65)
c$$$      end if
      ntor=0
      if (ntoty.eq.0) return
      do 61 i1=1,nbon
      k2=ib(i1,2)
      k3=ib(i1,3)
c     Only compute interaction if both atoms local
c     are local or else flip a coin 
      if (k2 .gt. na_local) go to 61
      if (k3 .gt. na_local) then
         if (itag(k2) .lt. itag(k3)) go to 61
         if (itag(k2) .eq. itag(k3)) then
            if(c(k2,3) .gt. c(k3,3)) go to 61
            if(c(k2,3) .eq. c(k3,3) .and. 
     $           c(k2,2) .gt. c(k3,2)) go to 61
            if(c(k2,3) .eq. c(k3,3) .and. 
     $           c(k2,2) .eq. c(k3,2) .and. 
     $           c(k2,1) .gt. c(k3,1)) go to 61
         endif
      endif

      iob1=ia(k2,2)
      iob2=ia(k3,2)
      do 60 i2=1,iob1        !Atoms connected to k2
      k4=ia(k2,2+i2)
      ibo2=nubon2(k2,i2)
      do 60 i3=1,iob2        !Atoms connected to k3
      k5=ia(k3,2+i3)
      ibo3=nubon2(k3,i3)
      bopr=bo(i1)*bo(ibo2)*bo(ibo3)
      if (bopr.gt.cutof2.and.k2.ne.k5.and.k3.ne.k4.and.k4.ne.k5) then

      ntor=ntor+1
      it(ntor,2)=k4
      it(ntor,3)=k2
      it(ntor,4)=k3
      it(ntor,5)=k5
      it(ntor,6)=ibo2
      it(ntor,7)=i1
      it(ntor,8)=ibo3

**********************************************************************
*                                                                    *
*     Determine force field types of torsion angles                  *
*                                                                    *
**********************************************************************
      ity=0
      ih1=ia(it(ntor,2),1)
      ih2=ia(it(ntor,3),1)
      ih3=ia(it(ntor,4),1)
      ih4=ia(it(ntor,5),1)

      if (ih2.gt.ih3) then
      ih1=ia(it(ntor,5),1)
      ih2=ia(it(ntor,4),1)
      ih3=ia(it(ntor,3),1)
      ih4=ia(it(ntor,2),1)
      end if

      if (ih2.eq.ih3.and.ih4.lt.ih1) then
      ih1=ia(it(ntor,5),1)
      ih2=ia(it(ntor,4),1)
      ih3=ia(it(ntor,3),1)
      ih4=ia(it(ntor,2),1)
      end if

      do i4=1,ntoty
      if (ih1.eq.nts(i4,1).and.ih2.eq.nts(i4,2).and.ih3.eq.nts(i4,3)
     $.and.ih4.eq.nts(i4,4)) ity=i4
      end do

      if (ity.eq.0) then
      do i4=1,ntoty
      if (nts(i4,1).eq.0.and.ih2.eq.nts(i4,2).and.ih3.eq.nts(i4,3)
     $.and.nts(i4,4).eq.0) ity=i4
      end do
      end if

      if (ity.eq.0) then
      ntor=ntor-1           !Torsion angle does not exist in force field: ignore
      else
      it(ntor,1)=ity
      end if

      end if

   60 continue
 61   continue

      if (ntor.gt.ntomax) stop 'Too many torsion angles'
*     do i1=1,ntor
*     write (41,'(20i4)')i1,it(i1,1),it(i1,2),it(i1,3),
*    $it(i1,4),it(i1,5),it(i1,6),it(i1,7),it(i1,8)
*     end do

      return
      end
********************************************************************** 
********************************************************************** 

      subroutine srtoop

********************************************************************** 
#include "cbka.blk"
#include "cbkbo.blk"
#include "cbkrbo.blk"
#include "cbkvalence.blk"
#include "control.blk"
#include "small.blk"
********************************************************************** 
c$$$      if (ndebug.eq.1) then
c$$$C      open (65,file='fort.65',status='unknown',access='append')
c$$$      write (65,*) 'In srtoop'
c$$$      call timer(65)
c$$$      close (65)
c$$$      end if
**********************************************************************
*                                                                    *
*     Find out of plane angles in molecule                           *
*                                                                    *
**********************************************************************
      noop=0
      do i1=1,nval
      k2=iv(i1,2)
      k3=iv(i1,3)
      k4=iv(i1,4)
      k5=iv(i1,5)
      k6=iv(i1,6)
      do i2=1,nbon
      k7=ib(i2,2)
      k8=ib(i2,3)
      if (bo(i2).gt.cutof2) then
      if (k7.eq.k3.and.k8.ne.k4.and.k8.ne.k2) then
      noop=noop+1 
      ioop(noop,2)=k8
      ioop(noop,3)=k3
      ioop(noop,4)=k2
      ioop(noop,5)=k4
      ioop(noop,6)=i2
      ioop(noop,7)=iv(i1,5)
      ioop(noop,8)=iv(i1,6)
      ioop(noop,9)=i1
      end if
      if (k8.eq.k3.and.k7.ne.k4.and.k7.ne.k2) then
      noop=noop+1 
      ioop(noop,2)=k7
      ioop(noop,3)=k3
      ioop(noop,4)=k2
      ioop(noop,5)=k4
      ioop(noop,6)=i2
      ioop(noop,7)=iv(i1,5)
      ioop(noop,8)=iv(i1,6)
      ioop(noop,9)=i1
      end if
      end if
      end do
      end do
      
      do i1=1,noop
      call caltor(ioop(i1,2),ioop(i1,3),ioop(i1,4),ioop(i1,5),hoop)
      end do
      
********************************************************************** 
      return
      end
**********************************************************************

**********************************************************************

      subroutine srthb

**********************************************************************
#include "cbka.blk"
#include "cbkc.blk"
#include "cbkbo.blk"
#include "cbkconst.blk"
#include "cbkia.blk"
#include "cbkrbo.blk"
#include "cbksrthb.blk"
#include "control.blk"
#include "small.blk"
#include "cbkpairs.blk"
#include "cbknvlown.blk"
#include "cbknubon2.blk"
**********************************************************************
*                                                                    *
*     Find hydrogen bonds in molecule                                *
*                                                                    *
**********************************************************************
c$$$      if (ndebug.eq.1) then
c$$$      open (65,file='fort.65',status='unknown',access='append')
c$$$      write (65,*) 'In srthb'
c$$$      call timer(65)
c$$$      close (65)
c$$$      end if
      nhb=0
**********************************************************************
*                                                                    *
*     Locate donor/acceptor bonds                                    *
*                                                                    *
**********************************************************************
c  Outer loop must be Verlet list, because ia() does not store Verlet entries,
c  but it does store bond entries in nubon2()
c
c The problem with using the nvlown ownership criterion
c is that it would require that we unprune every bond that is within 
c certain distance, as well as its first and second neighbor bonds.
c
c For the ownership criterion based on H atom location no unpruning is required.
c Apparently lprune=4 is sufficient here, implying that we need to capture first and
c second neighbor bonds of the O-H bond, and of course we need to include all hydrogen
c bond partners within hbcut. 
c 

      do 20 ivl=1,nvpair    !Use Verlet-list to find donor-acceptor pairs

      j1=nvl1(ivl)
      j2=nvl2(ivl)
      ity1=ia(j1,1)
      ity2=ia(j2,1)
      ihhb1=nphb(ia(j1,1))
      ihhb2=nphb(ia(j2,1))

      if (ihhb1.gt.ihhb2) then        !Make j1 donor(H) atom and j2 acceptor(O) atom
      j2=nvl1(ivl)
      j1=nvl2(ivl)
      ity1=ia(j1,1)
      ity2=ia(j2,1)
      ihhb1=nphb(ia(j1,1))
      ihhb2=nphb(ia(j2,1))
      end if

* Only need to compute bonds where j1 is local
      if (j1 .le. na_local) then

      if (ihhb1.eq.1.and.ihhb2.eq.2) then
      call dista2(j1,j2,dishb,dxm,dym,dzm)
      if (dishb.lt.hbcut) then
      do 10 i23=1,ia(j1,2)                !Search for acceptor atoms bound to donor atom
      j3=ia(j1,2+i23)
      ity3=ia(j3,1)
      nbohb=nubon2(j1,i23)
      if (nphb(ity3).eq.2.and.j3.ne.j2.and.bo(nbohb).gt.0.01) then
**********************************************************************
*                                                                    *
*     Accept hydrogen bond and find hydrogen bond type               *
*                                                                    *
**********************************************************************
      nhb=nhb+1

      if (nhb.gt.nhbmax) then
      write (*,*)nhb,nhbmax
      write (*,*)'Maximum number of hydrogen bonds exceeded'
      stop 'Maximum number of hydrogen bonds exceeded'
      end if

      ihb(nhb,1)=0

      do i3=1,nhbty
      if (ity3.eq.nhbs(i3,1).and.ity1.eq.nhbs(i3,2).and.ity2.eq.
     $nhbs(i3,3)) ihb(nhb,1)=i3
      end do

      if (ihb(nhb,1).eq.0) then    !Hydrogen bond not in force field
      nhb=nhb-1 
*     write (*,*)'Warning: added hydrogen bond ',ity3,ity1,ity2
*     nhbty=nhbty+1
*     nhbs(nhbty,1)=ity3
*     nhbs(nhbty,2)=ity1
*     nhbs(nhbty,3)=ity2
*     rhb(nhbty)=2.70
*     dehb(nhbty)=zero
*     vhb1(nhbty)=5.0
*     vhb2(nhbty)=20.0
*     ihb(nhb,1)=nhbty
      end if

      ihb(nhb,2)=j3
      ihb(nhb,3)=j1
      ihb(nhb,4)=j2
      ihb(nhb,5)=nbohb
      ihb(nhb,6)=k1
      ihb(nhb,7)=k2
      ihb(nhb,8)=k3
*     write (64,*)nhb,ihb(nhb,1),j3,j1,j2,nbohb,k1,k2,k3,bo(nbohb),
*    $dishb
      end if

   10 continue

      end if
      end if
      end if
   20 end do

*     stop 'end in srthb'
      return
      end
**********************************************************************
@


4.13
log
@removed some unnecessary dynamic_casts and fixed problems with self-interactions
@
text
@a395 1
*     With the new midpoint method, lhb=0 may miss some h-bonds      *
d606 1
a606 1
*     Only need to compute bonds where j3 is local
d613 6
a618 4
               j3=ia(j1,2+i23)
               if (nphb(ia(j3,1)).eq.2.and.j3.ne.j2) then
                  nboncol(nubon2(j1,i23))=-1
                  ntmphb = ntmphb+1
d1479 1
a1479 1
* Only need to compute bonds where j3 is local
@


4.12
log
@Fixed problem with hbonds in ReaxFF implementation. Now matches pre-midpoint results
@
text
@d827 1
d1253 14
a1266 4
c     or else flip a coin.
      if (k2 .gt. na_local ) go to 61
      if (k3 .gt. na_local .and.
     $     itag(k2) .lt. itag(k3)) go to 61
@


4.11
log
@Added commands to control midpoint rule, iprune, ihb and hbcut
@
text
@a593 2
c Use precomputed midpoint criterion to decide if interaction is owned.
      if (nvlown(ivl).eq.1) then
d607 3
d1438 11
a1449 2
c Use precomputed midpoint criterion to decide if interaction is owned.
      if (nvlown(ivl).eq.1) then
d1467 3
@


4.10
log
@Cleaned up the midpoint method some more
@
text
@d189 1
a189 1
      subroutine srtbon1
a219 1
      integer Lprune
d233 3
d384 1
a384 1
*     Lprune controls level of bond-pruning performed to increase    *
d386 1
a386 1
*     However, making it smaller can speed up       *
d388 1
a388 1
*     Setting it to 0 turns off pruning, useful for debugging.                             *
a390 2
      Lprune = 4
c$$$      Lprune = 0
d393 1
a393 1
*     Lhb controls whether or not to prune ghost bonds that          *
d395 4
a398 4
*     Setting it to 1 suppresses pruning, and so is the safe option. *
*     With the new midpoint method, Lhb=0 may miss some h-bonds      *
*     If Lprune = 0, then pruning is not used, results are exact     *
*     and Lhb has no effect.                                         *
d401 1
a401 4
c$$$      Lhb = 0
      Lhb = 1

      if (Lprune .gt. 0) then
d440 1
a440 1
      if (Lprune .ge. 3) then
d461 1
a461 1
      if (Lprune .ge. 4) then
d504 1
a504 1
      if (Lprune .ge. 5) then
d547 1
a547 1
      if (Lprune .ge. 6) then
d590 1
a590 1
      if (Lhb .eq. 1) then
d611 1
a611 1
         if (dishb.lt.10.00) then
d1459 1
a1459 1
      if (dishb.lt.10.00) then
@


4.9
log
@Implemented midpoint method for ReaxFF
@
text
@a161 54
      subroutine distan

********************************************************************** 
#include "cbka.blk"
#include "cbkconst.blk"
#include "cbkdistan.blk"
#include "cellcoord.blk"
#include "control.blk"
********************************************************************** 
*                                                                    *
*     Set up interatomic distance calculation                        *
*                                                                    *
********************************************************************** 
c$$$      if (ndebug.eq.1) then
c$$$C      open (65,file='fort.65',status='unknown',access='append')
c$$$      write (65,*) 'In distan'
c$$$      call timer(65)
c$$$      close (65)
c$$$      end if

      iortho=1
      if (qr.eq.'F'.or.qr.eq.'Y'.or.qr.eq.'3'.or.qr.eq.'5'.
     $or.qr.eq.'P'.or.qr.eq.'B'.or.qr.eq.'S') then 
      if (angle(1).ne.90.0.or.angle(2).ne.90.0.or.angle(3).ne.90.0) 
     $iortho=0           !Non-orthogonal

      halfa=angle(1)*dgrrdn
      hbeta=angle(2)*dgrrdn
      hgamma=angle(3)*dgrrdn
      sinalf=sin(halfa)
      cosalf=cos(halfa)
      sinbet=sin(hbeta)
      cosbet=cos(hbeta)
      cosphi=(cos(hgamma)-cosalf*cosbet)/(sinalf*sinbet)
      if (cosphi.gt.1.0) cosphi=1.0
      sinphi=sqrt(one-cosphi*cosphi)
      tm11=axis(1)*sinbet*sinphi
      tm21=axis(1)*sinbet*cosphi
      tm31=axis(1)*cosbet
      tm22=axis(2)*sinalf
      tm32=axis(2)*cosalf
      tm33=axis(3)
      end if
      aaxh=sqrt(tm11*tm11+tm21*tm21+tm31*tm31)
      baxh=sqrt(tm22*tm22+tm32*tm32)
      caxh=tm33


      return
      end

********************************************************************** 
********************************************************************** 

a166 2
#include "cbkdistan.blk"
#include "cellcoord.blk"
d207 1
d401 1
a402 1
c$$$      Lhb = 0
d592 19
d612 13
a624 18
      if (Lhb .eq. 1) then
      do i1 = 1,nbonall
         if (nboncol(i1).eq.0) then
            j1=iball(i1,2)
            j2=iball(i1,3)
            ihhb1=nphb(ia(j1,1))
            ihhb2=nphb(ia(j2,1))
            if (ihhb1.gt.ihhb2) then
               j1=iball(i1,3)
               j2=iball(i1,2)
               ihhb1=nphb(ia(j1,1))
               ihhb2=nphb(ia(j2,1))
            end if
            if (ihhb1.eq.1.and.ihhb2.eq.2) then
               nboncol(i1)=-1
               ntmphb = ntmphb+1
            endif
         endif
d626 1
a626 1
      endif
d1438 2
@


4.8
log
@Fixed some FORTRAN lapses and changed dump timestep to write timestep
@
text
@d451 1
a451 1
*     However, Lprune = 4 and Lhb = 0 should give exact results.  *
d456 2
a457 2
c$$$      Lhb = 1
      Lhb = 0
d1460 1
d1480 3
d1490 1
a1490 1
      if (ihhb1.gt.ihhb2) then        !Make j1 donor atom and j2 acceptor atom
a1498 3
* Only need to compute bonds where j3 is local
      if (j1 .le. na_local) then

@


4.7
log
@Upgraded ReaxFF in Grasp to latest version
@
text
@d47 6
a52 6
      if (ndebug.eq.1) then
C      open (65,file='fort.65',status='unknown',access='append')
      write (65,*) 'In srtatom'
      call timer(65)
      close (65)
      end if
d100 6
a105 6
      if (ndebug.eq.1) then
C      open (65,file='fort.65',status='unknown',access='append')
      write (65,*) 'In molec'
      call timer(65)
      close (65)
      end if
d175 6
a180 6
      if (ndebug.eq.1) then
C      open (65,file='fort.65',status='unknown',access='append')
      write (65,*) 'In distan'
      call timer(65)
      close (65)
      end if
d228 6
a233 6
*     if (ndebug.eq.1) then
C*     open (65,file='fort.65',status='unknown',access='append')
*     write (65,*) 'In dista2'
*     call timer(65)
*     close (65)
*     end if
d282 6
a287 27
      if (ndebug.eq.1) then
C      open (65,file='fort.65',status='unknown',access='append')
      write (65,*) 'In srtbon1'
      call timer(65)
      close (65)
      end if


      if (ndebug.eq.1) then
C      open (65,file='fort.65',status='unknown',access='append')
      write(65,*) 'Nonself pairs srtbon1'
      write(65,*) tm11,tm21,tm22,tm31,tm32,tm33
      do ivl=1,nvpair-nvlself
         i1=nvl1(ivl)
         i2=nvl2(ivl)
         call dista2(i1,i2,dis,dxm,dym,dzm)
         write(65,*) i1,i2,ix,iy,iz,nvlbo(ivl),dis
      end do

      write(65,*) 'Self pairs srtbon1'
      do ivl=nvpair-nvlself+1,nvpair
         i1=nvl1(ivl)
         i2=nvl2(ivl)
         call dista2(i1,i2,dis,dxm,dym,dzm)
         write(65,*) i1,ix,iy,iz,nvlbo(ivl),dis
      end do
      endif
a871 8
      if (ndebug.eq.1) then
      write(65,*) 'Total atom bond orders'
      do i1=1,na
         write(65,*) i1,ia(i1,1),ia(i1,2),abo(i1)
      end do
      close (65)
      endif

d1037 6
a1042 6
      if (ndebug.eq.1) then
C      open (65,file='fort.65',status='unknown',access='append')
      write (65,*) 'In srtang'
      call timer(65)
      close (65)
      end if
d1283 6
a1288 6
      if (ndebug.eq.1) then
      open (65,file='fort.65',status='unknown',access='append')
      write (65,*) 'In srttor'
      call timer(65)
      close (65)
      end if
d1388 6
a1393 6
      if (ndebug.eq.1) then
C      open (65,file='fort.65',status='unknown',access='append')
      write (65,*) 'In srtoop'
      call timer(65)
      close (65)
      end if
d1466 6
a1471 6
      if (ndebug.eq.1) then
      open (65,file='fort.65',status='unknown',access='append')
      write (65,*) 'In srthb'
      call timer(65)
      close (65)
      end if
@


4.6
log
@Merged ReverseComm_branch back into main branch
@
text
@d297 1
a297 4
         dxm=c(i1,1)-c(i2,1)
         dym=c(i1,2)-c(i2,2)
         dzm=c(i1,3)-c(i2,3)
         dis=sqrt(dxm*dxm+dym*dym+dzm*dzm)
d305 1
a305 4
         dxm=c(i1,1)-c(i2,1)
         dym=c(i1,2)-c(i2,2)
         dzm=c(i1,3)-c(i2,3)
         dis=sqrt(dxm*dxm+dym*dym+dzm*dzm)
d355 1
a355 4
      dxm=c(i1,1)-c(i2,1)
      dym=c(i1,2)-c(i2,2)
      dzm=c(i1,3)-c(i2,3)
      dis=sqrt(dxm*dxm+dym*dym+dzm*dzm)
a713 2
c$$$      write(6,'(12i6)') ntmphb,ntmp0,ntmp1,ntmp2,ntmp3,ntmp4,ntmp5,
c$$$     $     ntmp6
d753 1
a753 4
      dxm=c(i1,1)-c(i2,1)
      dym=c(i1,2)-c(i2,2)
      dzm=c(i1,3)-c(i2,3)
      dis=sqrt(dxm*dxm+dym*dym+dzm*dzm)
a1049 1
#include "cbknuval.blk"
d1059 2
a1072 5
      do i1=1,nbon
      nuvalna(i1)=0
      nuvalnb(i1)=0
      end do

d1112 1
d1130 1
d1199 1
a1199 1
      ity=0
d1209 1
d1212 4
a1215 1
     $ih3.eq.nvs(i3,3)) ity=i3
d1218 1
a1218 1
      if (ity.eq.0.or.abs(vka(ity)).lt.0.001) then   !Valence angle does not exist in force field;ignore
d1222 1
a1222 1
      iv(nval,1)=ity
d1224 10
a1233 18
      if (iv(nval,2).lt.iv(nval,3)) then
         nuvalna(jindexbondlist)=nuvalna(jindexbondlist)+1
         nuvala(jindexbondlist,nuvalna(jindexbondlist),1)=kindexbondlist
         nuvala(jindexbondlist,nuvalna(jindexbondlist),2)=nval
      else
         nuvalnb(jindexbondlist)=nuvalnb(jindexbondlist)+1
         nuvalb(jindexbondlist,nuvalnb(jindexbondlist),1)=kindexbondlist
         nuvalb(jindexbondlist,nuvalnb(jindexbondlist),2)=nval
      endif
      if (iv(nval,4).lt.iv(nval,3)) then
         nuvalna(kindexbondlist)=nuvalna(kindexbondlist)+1
         nuvala(kindexbondlist,nuvalna(kindexbondlist),1)=jindexbondlist
         nuvala(kindexbondlist,nuvalna(kindexbondlist),2)=nval
      else
         nuvalnb(kindexbondlist)=nuvalnb(kindexbondlist)+1
         nuvalb(kindexbondlist,nuvalnb(kindexbondlist),1)=jindexbondlist
         nuvalb(kindexbondlist,nuvalnb(kindexbondlist),2)=nval
      endif
d1237 1
a1237 1
      ity=0
d1247 1
d1250 4
a1253 1
     $ih3.eq.nvs(i3,3)) ity=i3
d1256 1
a1256 1
      if (ity.eq.0.or.abs(vka(ity)).lt.0.001) then   !Valence angle does not exist in force field;ignore
d1264 11
a1274 19
      iv(nval-ihul,1)=ity
      if (iv(nval,2).lt.iv(nval,3)) then
         nuvalna(jindexbondlist)=nuvalna(jindexbondlist)+1
         nuvala(jindexbondlist,nuvalna(jindexbondlist),1)=kindexbondlist
         nuvala(jindexbondlist,nuvalna(jindexbondlist),2)=nval
      else
         nuvalnb(jindexbondlist)=nuvalnb(jindexbondlist)+1
         nuvalb(jindexbondlist,nuvalnb(jindexbondlist),1)=kindexbondlist
         nuvalb(jindexbondlist,nuvalnb(jindexbondlist),2)=nval
      endif
      if (iv(nval,3).lt.iv(nval,4)) then
         nuvalna(kindexbondlist)=nuvalna(kindexbondlist)+1
         nuvala(kindexbondlist,nuvalna(kindexbondlist),1)=jindexbondlist
         nuvala(kindexbondlist,nuvalna(kindexbondlist),2)=nval
      else
         nuvalnb(kindexbondlist)=nuvalnb(kindexbondlist)+1
         nuvalb(kindexbondlist,nuvalnb(kindexbondlist),1)=jindexbondlist
         nuvalb(kindexbondlist,nuvalnb(kindexbondlist),2)=nval
      endif
a1302 1
#include "cbknuval.blk"
d1306 1
d1313 1
a1313 1
C      open (65,file='fort.65',status='unknown',access='append')
d1320 18
a1338 90
      do iindexbondlist=1,nbon

      jbond1=ib(iindexbondlist,2)
      jbond2=ib(iindexbondlist,3)

c     Only compute interaction if both atoms
c     are local or else flip a coin

      if (jbond1 .le. na_local) then
      if (jbond2 .le. na_local .or. 
     $     itag(jbond1) .lt. itag(jbond2)) then

      if (bo(iindexbondlist).lt.cutof2) goto 61
      inumbondsa=nuvalna(iindexbondlist)
      inumbondsb=nuvalnb(iindexbondlist)
      do jindexbond=1,inumbondsa
      jindexbondlist = nuvala(iindexbondlist,jindexbond,1)
      i1 = nuvala(iindexbondlist,jindexbond,2)
      if (bo(jindexbondlist).lt.cutof2) goto 601
      k3=iv(i1,3)
      k4=iv(i1,5)
      k5=iv(i1,6)
      do kindexbond=1,inumbondsb
      kindexbondlist = nuvalb(iindexbondlist,kindexbond,1)
      i2 = nuvalb(iindexbondlist,kindexbond,2)
      if (bo(kindexbondlist).lt.cutof2) goto 602
      k6=iv(i2,3)
      k7=iv(i2,5)
      k8=iv(i2,6)

      bopr=bo(k4)*bo(k5)*bo(k7)*bo(k8)
      if (bopr.lt.0.000100) goto 602
      nju=0
      
      if (k3.eq.k6) goto 60
*     if (k3.eq.k6) then
*     write (42,'(20i4)')k2,k3,k3h,k9,k6,k6h
*     write (42,'(20i4)')nvlx(ibsym(k4)),nvly(ibsym(k4)),
*    $nvlz(ibsym(k4))
*     write (42,'(20i4)')nvlx(ibsym(k7)),nvly(ibsym(k7)),
*    $nvlz(ibsym(k7))
*     if ((k3.lt.k2).and.(k6.lt.k9)) goto 60
*     if (nvlx(ibsym(k4)).eq.nvlx(ibsym(k7)).and.
*    $nvly(ibsym(k4)).eq.nvly(ibsym(k7)).and.
*    $nvlz(ibsym(k4)).eq.nvlz(ibsym(k7))) goto 60
*     end if
 
      if (k4.eq.k7.and.iv(i1,4).ne.iv(i2,4)) then
      ntor=ntor+1
      it(ntor,2)=iv(i1,4)
      it(ntor,3)=iv(i1,3)
      it(ntor,4)=iv(i1,2)
      it(ntor,5)=iv(i2,4)
      it(ntor,6)=iv(i1,6)
      it(ntor,7)=iv(i1,5)
      it(ntor,8)=iv(i2,6)
      it(ntor,9)=i1
      it(ntor,10)=i2
      nju=1
      end if
      if (nju.eq.1) goto 60
      if (k4.eq.k8.and.iv(i1,4).ne.iv(i2,2)) then
      ntor=ntor+1
      it(ntor,2)=iv(i1,4)
      it(ntor,3)=iv(i1,3)
      it(ntor,4)=iv(i1,2)
      it(ntor,5)=iv(i2,2)
      it(ntor,6)=iv(i1,6)
      it(ntor,7)=iv(i1,5)
      it(ntor,8)=iv(i2,5)
      it(ntor,9)=i1
      it(ntor,10)=i2
      nju=1
      end if
      if (nju.eq.1) goto 60
      if (k5.eq.k7.and.iv(i1,2).ne.iv(i2,4)) then
      ntor=ntor+1
      it(ntor,2)=iv(i1,2)
      it(ntor,3)=iv(i1,3)
      it(ntor,4)=iv(i1,4)
      it(ntor,5)=iv(i2,4)
      it(ntor,6)=iv(i1,5)
      it(ntor,7)=iv(i1,6)
      it(ntor,8)=iv(i2,6)
      it(ntor,9)=i1
      it(ntor,10)=i2
      nju=1
      end if
      if (nju.eq.1) goto 60
      if (k5.eq.k8.and.iv(i1,2).ne.iv(i2,2)) then
d1340 7
a1346 12
      it(ntor,2)=iv(i1,2)
      it(ntor,3)=iv(i1,3)
      it(ntor,4)=iv(i1,4)
      it(ntor,5)=iv(i2,2)
      it(ntor,6)=iv(i1,5)
      it(ntor,7)=iv(i1,6)
      it(ntor,8)=iv(i2,5)
      it(ntor,9)=i1
      it(ntor,10)=i2
      nju=1
      end if
   60 continue
a1347 8
      if (ntor.gt.ntomax) then
         write (6,*)'ntor = ',ntor,' reax_defs.h::NTOMAXDEF = ',
     $        NTOMAXDEF,
     $        ' after',iindexbondlist, ' of ',nbon,' bonds completed.' 
         stop 'Too many torsion angles. Increase NTOMAX'
      endif

      if (nju.eq.1) then
a1352 4
*     write (41,'(20i4)')ntor,it(ntor,2),it(ntor,3),it(ntor,4),
*    $it(ntor,5),it(ntor,6),it(ntor,7),it(ntor,8),it(ntor,9),
*    $it(ntor,10),ibsym(it(ntor,6)),ibsym(it(ntor,7)),
*    $ibsym(it(ntor,8))
d1358 1
d1365 1
d1372 4
a1375 3
      do i3=1,ntoty
      if (ih1.eq.nts(i3,1).and.ih2.eq.nts(i3,2).and.ih3.eq.nts(i3,3)
     $.and.ih4.eq.nts(i3,4)) ity=i3
d1377 1
d1379 3
a1381 3
      do i3=1,ntoty
      if (nts(i3,1).eq.0.and.ih2.eq.nts(i3,2).and.ih3.eq.nts(i3,3)
     $.and.nts(i3,4).eq.0) ity=i3
d1384 1
d1390 1
d1393 2
a1394 2
 602  end do
 601  end do
d1396 5
a1400 4
      endif
      endif

   61 end do
d1473 1
d1488 2
d1496 1
a1496 1
C      open (65,file='fort.65',status='unknown',access='append')
d1507 5
a1511 3
      do i1=1,nbon
      j1=ib(i1,2)
      j2=ib(i1,3)
d1514 6
a1519 3
      if (ihhb1.gt.ihhb2) then
      j1=ib(i1,3)
      j2=ib(i1,2)
d1524 2
a1525 2
* Only need to compute bonds where j2 is local
      if (j2 .le. na_local) then
d1527 8
a1534 10
      if (ihhb1.eq.1.and.ihhb2.eq.2.and.bo(i1).gt.0.01) then
      do i2=1,na
      ity=ia(i2,1)
      if (i2.ne.j1.and.i2.ne.j2) then
      dxm=c(j2,1)-c(i2,1)
      dym=c(j2,2)-c(i2,2)
      dzm=c(j2,3)-c(i2,3)
      dishb=sqrt(dxm*dxm+dym*dym+dzm*dzm)
*      call dista2(j2,i2,dishb,dx,dy,dz)
      if (nphb(ity).eq.2.and.dishb.lt.10.00) then
d1541 1
d1543 3
a1545 4
      write (65,*)nhb,nhbmax
      write (6,*)'nhb = ',nhb,' reax_defs.h::NHBMAX = ',NHBMAX,
     $     ' after',i1, ' of ',nbon,' bonds completed.' 
      stop 'Too many hydrogen bonds. Increase NHBMAX.'
d1547 1
d1549 1
a1549 3
      ih1=ia(j2,1)
      ih2=ia(j1,1)
      ih3=ia(i2,1)
d1551 1
a1551 1
      if (ih1.eq.nhbs(i3,1).and.ih2.eq.nhbs(i3,2).and.ih3.eq.
d1554 13
a1566 12
      if (ihb(nhb,1).eq.0) then
      write (*,*)'Warning: added hydrogen bond ',ih1,ih2,ih3
      nhbty=nhbty+1
      nhbs(nhbty,1)=ih1
      nhbs(nhbty,2)=ih2
      nhbs(nhbty,3)=ih3
      nhbs(nhbty,3)=ih3
      rhb(nhbty)=2.70
      dehb(nhbty)=zero
      vhb1(nhbty)=5.0
      vhb2(nhbty)=20.0
      ihb(nhb,1)=nhbty
d1568 2
a1569 1
      ihb(nhb,2)=j2
d1571 11
a1581 2
      ihb(nhb,4)=i2
      ihb(nhb,5)=i1
a1583 2
      end do

d1585 1
d1587 1
a1587 8
      endif

      end do

*     do i1=1,nhb
*     write (65,'(5i6)')(ihb(i1,i2),i2=1,5)
*     end do
*     stop 'End of srthb'
@


4.5
log
@Added better diagnostics for ReaxFF memory footprint.
Output to nodefiles for successful runs (grep reax_def).
Output to standard output for unsuccessful runs.
@
text
@d468 2
a469 2
*     performance. For correct results, it should be set to 6.       *
*     However, making it smaller (4) can dramatically speed up       *
d471 1
a471 1
*     Setting it to 0 turns off pruning.                             *
d474 3
a476 3
      Lprune = 6
c      Lprune = 0
********************************************************************** 
d478 6
a483 5
*     Lhb controls whether or not possible ghost hydrogen bonds are  *
*     pruned. For correct results it should be set to 1.             *
*     However, setting it to 0 can dramatically speed up             *
*     force calculation and may not have a big effect on forces.     *
*     If Lprune is set to zero, then Lhb has no effect               * 
d486 2
a487 2
      Lhb = 1
c      Lhb = 0
a504 4
      ntmp7 = 0
      ntmp8 = 0
      ntmp9 = 0
      ntmp10 = 0
a675 176
c$$$
c$$$* color 7 bonds are part of a 1-7 interaction with local atom
c$$$
c$$$      do i1 = 1,nbonall
c$$$         if (nboncol(i1).eq.6) then
c$$$* One end definitely has a bond of color 5
c$$$* Find it and color bonds on other end 7
c$$$            i3=iball(i1,2)
c$$$            i3b=0
c$$$            do i4 = 1,ia(i3,2)
c$$$               i5=nubon2(i3,i4)
c$$$               if (nboncol(i5).eq.5) then
c$$$                  i3b=iball(i1,3)
c$$$               endif
c$$$            end do
c$$$
c$$$            if (i3b.eq.0) then
c$$$               i3=iball(i1,3)
c$$$               i3b=0
c$$$               do i4 = 1,ia(i3,2)
c$$$                  i5=nubon2(i3,i4)
c$$$                  if (nboncol(i5).eq.5) then
c$$$                     i3b=iball(i1,2)
c$$$                  endif
c$$$               end do
c$$$            endif
c$$$
c$$$            if (i3b.eq.0) then
c$$$               stop 'Could not find color 5 from color 6 bond'
c$$$            endif
c$$$
c$$$            do i4 = 1,ia(i3b,2)
c$$$               i5=nubon2(i3b,i4)
c$$$               if (nboncol(i5).eq.0) then
c$$$                  nboncol(i5)=7
c$$$                  ntmp7 = ntmp7+1
c$$$               endif
c$$$            end do
c$$$           
c$$$         endif
c$$$      end do
c$$$
c$$$* color 8 bonds are part of a 1-8 interaction with local atom
c$$$
c$$$      do i1 = 1,nbonall
c$$$         if (nboncol(i1).eq.7) then
c$$$* One end definitely has a bond of color 6
c$$$* Find it and color bonds on other end 8
c$$$            i3=iball(i1,2)
c$$$            i3b=0
c$$$            do i4 = 1,ia(i3,2)
c$$$               i5=nubon2(i3,i4)
c$$$               if (nboncol(i5).eq.6) then
c$$$                  i3b=iball(i1,3)
c$$$               endif
c$$$            end do
c$$$
c$$$            if (i3b.eq.0) then
c$$$               i3=iball(i1,3)
c$$$               i3b=0
c$$$               do i4 = 1,ia(i3,2)
c$$$                  i5=nubon2(i3,i4)
c$$$                  if (nboncol(i5).eq.6) then
c$$$                     i3b=iball(i1,2)
c$$$                  endif
c$$$               end do
c$$$            endif
c$$$
c$$$            if (i3b.eq.0) then
c$$$               stop 'Could not find color 6 from color 7 bond'
c$$$            endif
c$$$
c$$$            do i4 = 1,ia(i3b,2)
c$$$               i5=nubon2(i3b,i4)
c$$$               if (nboncol(i5).eq.0) then
c$$$                  nboncol(i5)=8
c$$$                  ntmp8 = ntmp8+1
c$$$               endif
c$$$            end do
c$$$           
c$$$         endif
c$$$      end do
c$$$
c$$$* color 9 bonds are part of a 1-9 interaction with local atom
c$$$
c$$$      do i1 = 1,nbonall
c$$$         if (nboncol(i1).eq.8) then
c$$$* One end definitely has a bond of color 7
c$$$* Find it and color bonds on other end 9
c$$$            i3=iball(i1,2)
c$$$            i3b=0
c$$$            do i4 = 1,ia(i3,2)
c$$$               i5=nubon2(i3,i4)
c$$$               if (nboncol(i5).eq.7) then
c$$$                  i3b=iball(i1,3)
c$$$               endif
c$$$            end do
c$$$
c$$$            if (i3b.eq.0) then
c$$$               i3=iball(i1,3)
c$$$               i3b=0
c$$$               do i4 = 1,ia(i3,2)
c$$$                  i5=nubon2(i3,i4)
c$$$                  if (nboncol(i5).eq.7) then
c$$$                     i3b=iball(i1,2)
c$$$                  endif
c$$$               end do
c$$$            endif
c$$$
c$$$            if (i3b.eq.0) then
c$$$               stop 'Could not find color 7 from color 8 bond'
c$$$            endif
c$$$
c$$$            do i4 = 1,ia(i3b,2)
c$$$               i5=nubon2(i3b,i4)
c$$$               if (nboncol(i5).eq.0) then
c$$$                  nboncol(i5)=9
c$$$                  ntmp9 = ntmp9+1
c$$$               endif
c$$$            end do
c$$$           
c$$$         endif
c$$$      end do
c$$$
c$$$* color 10 bonds are part of a 1-10 interaction with local atom
c$$$
c$$$      do i1 = 1,nbonall
c$$$         if (nboncol(i1).eq.9) then
c$$$* One end definitely has a bond of color 8
c$$$* Find it and color bonds on other end 10
c$$$            i3=iball(i1,2)
c$$$            i3b=0
c$$$            do i4 = 1,ia(i3,2)
c$$$               i5=nubon2(i3,i4)
c$$$               if (nboncol(i5).eq.8) then
c$$$                  i3b=iball(i1,3)
c$$$               endif
c$$$            end do
c$$$
c$$$            if (i3b.eq.0) then
c$$$               i3=iball(i1,3)
c$$$               i3b=0
c$$$               do i4 = 1,ia(i3,2)
c$$$                  i5=nubon2(i3,i4)
c$$$                  if (nboncol(i5).eq.8) then
c$$$                     i3b=iball(i1,2)
c$$$                  endif
c$$$               end do
c$$$            endif
c$$$
c$$$            if (i3b.eq.0) then
c$$$               stop 'Could not find color 8 from color 9 bond'
c$$$            endif
c$$$
c$$$            do i4 = 1,ia(i3b,2)
c$$$               i5=nubon2(i3b,i4)
c$$$               if (nboncol(i5).eq.0) then
c$$$                  nboncol(i5)=10
c$$$                  ntmp10 = ntmp10+1
c$$$               endif
c$$$            end do
c$$$           
c$$$         endif
c$$$      end do



c$$$* Set the bond orders of excluded bonds to zero.
c$$$
c$$$      do i1 = 1,nbonall
c$$$         if (nboncol(i1).eq.0) then
c$$$            bo(i1) = 0.0
c$$$            ntmp0=ntmp0+1
c$$$         endif
c$$$      end do

d724 1
a724 1
c$$$     $     ntmp6,ntmp7,ntmp8,ntmp9,ntmp10
a1055 188
c$$$********************************************************************** 
c$$$
c$$$      subroutine srtang
c$$$
c$$$********************************************************************** 
c$$$#include "cbka.blk"
c$$$#include "cbkbo.blk"
c$$$#include "cbkff.blk"
c$$$#include "cbkia.blk"
c$$$#include "cbkrbo.blk"
c$$$#include "cbkvalence.blk"
c$$$#include "cellcoord.blk"
c$$$#include "control.blk"
c$$$#include "small.blk"
c$$$
c$$$      dimension a(3),b(3),j(3)
c$$$********************************************************************** 
c$$$*                                                                    *
c$$$*     Find valency angles in molecule                                *
c$$$*                                                                    *
c$$$********************************************************************** 
c$$$      if (ndebug.eq.1) then
Cc$$$      open (65,file='fort.65',status='unknown',access='append')
c$$$      write (65,*) 'In srtang'
c$$$      call timer(65)
c$$$      close (65)
c$$$      end if
c$$$      nval=0
c$$$      if (nvaty.eq.0) return
c$$$      do i1=1,nbon-1
c$$$      k4=ib(i1,2)
c$$$      k5=ib(i1,3)
c$$$      if (bo(i1).lt.cutof2) goto 51
c$$$      do i2=i1+1,nbon
c$$$      iju=0
c$$$      if (bo(i2).lt.cutof2) goto 50
c$$$      if (bo(i1)*bo(i2).lt.0.001) goto 50
c$$$      k7=ib(i2,2)
c$$$      k8=ib(i2,3)
c$$$
c$$$      if (k4.eq.k7.and.k5.eq.k8.and.k4.ne.k8.and.k5.ne.k7) then
c$$$      nval=nval+1
c$$$      iv(nval,2)=k5
c$$$      iv(nval,3)=k4
c$$$      iv(nval,4)=k8
c$$$      iv(nval,5)=i1
c$$$      iv(nval,6)=i2
c$$$      nval=nval+1
c$$$      iv(nval,2)=k4
c$$$      iv(nval,3)=k5
c$$$      iv(nval,4)=k7
c$$$      iv(nval,5)=i1
c$$$      iv(nval,6)=i2
c$$$      iju=2
c$$$      end if
c$$$      if (iju.eq.2) goto 50
c$$$
c$$$      if (k4.eq.k8.and.k5.eq.k7.and.k4.ne.k7.and.k5.ne.k8) then
c$$$      nval=nval+1
c$$$      iv(nval,2)=k5
c$$$      iv(nval,3)=k4
c$$$      iv(nval,4)=k7
c$$$      iv(nval,5)=i1
c$$$      iv(nval,6)=i2
c$$$      nval=nval+1
c$$$      iv(nval,2)=k4
c$$$      iv(nval,3)=k5
c$$$      iv(nval,4)=k8
c$$$      iv(nval,5)=i1
c$$$      iv(nval,6)=i2
c$$$      iju=2
c$$$      end if
c$$$      if (iju.eq.2) goto 50
c$$$
c$$$      if (k4.eq.k7) then
c$$$      nval=nval+1
c$$$      iv(nval,2)=k5
c$$$      iv(nval,3)=k4
c$$$      iv(nval,4)=k8
c$$$      iv(nval,5)=i1
c$$$      iv(nval,6)=i2
c$$$      iju=1
c$$$      end if
c$$$      if (iju.eq.1) goto 50
c$$$
c$$$      if (k4.eq.k8) then
c$$$      nval=nval+1
c$$$      iv(nval,2)=k5
c$$$      iv(nval,3)=k4
c$$$      iv(nval,4)=k7
c$$$      iv(nval,5)=i1
c$$$      iv(nval,6)=i2
c$$$      iju=1
c$$$      end if
c$$$      if (iju.eq.1) goto 50
c$$$
c$$$      if (k5.eq.k7) then
c$$$      nval=nval+1
c$$$      iv(nval,2)=k4
c$$$      iv(nval,3)=k5
c$$$      iv(nval,4)=k8
c$$$      iv(nval,5)=i1
c$$$      iv(nval,6)=i2
c$$$      iju=1
c$$$      end if
c$$$      if (iju.eq.1) goto 50
c$$$
c$$$      if (k5.eq.k8) then
c$$$      nval=nval+1
c$$$      iv(nval,2)=k4
c$$$      iv(nval,3)=k5
c$$$      iv(nval,4)=k7
c$$$      iv(nval,5)=i1
c$$$      iv(nval,6)=i2
c$$$      iju=1
c$$$      end if
c$$$   50 continue
c$$$      if (iju.gt.0) then
c$$$**********************************************************************
c$$$*                                                                    *
c$$$*     Determine force field types of angles                          *
c$$$*                                                                    *
c$$$**********************************************************************
c$$$      ity=0
c$$$      ih1=ia(iv(nval,2),1)
c$$$      ih2=ia(iv(nval,3),1)
c$$$      ih3=ia(iv(nval,4),1)
c$$$      if (ih3.lt.ih1) then
c$$$      ih3=ia(iv(nval,2),1)
c$$$      ih2=ia(iv(nval,3),1)
c$$$      ih1=ia(iv(nval,4),1)
c$$$      end if
c$$$
c$$$      do i3=1,nvaty
c$$$      if (ih1.eq.nvs(i3,1).and.ih2.eq.nvs(i3,2).and.
c$$$     $ih3.eq.nvs(i3,3)) ity=i3
c$$$      end do
c$$$
c$$$      if (ity.eq.0.or.abs(vka(ity)).lt.0.001) then   !Valence angle does not exist in force field;ignore
c$$$      nval=nval-1
c$$$      ihul=0
c$$$      else
c$$$      iv(nval,1)=ity
c$$$      ihul=1
c$$$      end if
c$$$
c$$$      if (iju.eq.2) then
c$$$      ity=0
c$$$      ih1=ia(iv(nval-ihul,2),1)
c$$$      ih2=ia(iv(nval-ihul,3),1)
c$$$      ih3=ia(iv(nval-ihul,4),1)
c$$$      if (ih3.lt.ih1) then
c$$$      ih3=ia(iv(nval-ihul,2),1)
c$$$      ih2=ia(iv(nval-ihul,3),1)
c$$$      ih1=ia(iv(nval-ihul,4),1)
c$$$      end if
c$$$
c$$$      do i3=1,nvaty
c$$$      if (ih1.eq.nvs(i3,1).and.ih2.eq.nvs(i3,2).and.
c$$$     $ih3.eq.nvs(i3,3)) ity=i3
c$$$      end do
c$$$
c$$$      if (ity.eq.0.or.abs(vka(ity)).lt.0.001) then   !Valence angle does not exist in force field;ignore
c$$$      if (ihul.eq.1) then
c$$$      do i3=1,6
c$$$      iv(nval-1,i3)=iv(nval,i3)
c$$$      end do
c$$$      end if
c$$$      nval=nval-1
c$$$      else
c$$$      iv(nval-ihul,1)=ity
c$$$      end if
c$$$
c$$$      end if
c$$$
c$$$      end if
c$$$
c$$$      end do
c$$$   51 continue
c$$$      end do
c$$$
c$$$      nbonop=0
c$$$
c$$$      if (nval.gt.nvamax) stop 'Too many valency angles'
c$$$     
c$$$      return
c$$$      end
c$$$********************************************************************** 
d1108 8
d1192 8
a1314 161
c$$$********************************************************************** 
c$$$
c$$$      subroutine srttor
c$$$
c$$$********************************************************************** 
c$$$#include "cbka.blk"
c$$$#include "cbkbo.blk"
c$$$#include "cbkia.blk"
c$$$#include "cbktorsion.blk"
c$$$#include "cbkvalence.blk"
c$$$#include "cellcoord.blk"
c$$$#include "control.blk"
c$$$********************************************************************** 
c$$$*                                                                    *
c$$$*     Find torsion angles in molecule                                *
c$$$*                                                                    *
c$$$********************************************************************** 
c$$$      if (ndebug.eq.1) then
Cc$$$      open (65,file='fort.65',status='unknown',access='append')
c$$$      write (65,*) 'In srttor'
c$$$      call timer(65)
c$$$      close (65)
c$$$      end if
c$$$      ntor=0
c$$$      if (ntoty.eq.0) return
c$$$      do i1=1,nval-1
c$$$      k2=iv(i1,2)
c$$$      k3=iv(i1,3)
c$$$      k3h=iv(i1,4)
c$$$      k4=iv(i1,5)
c$$$      k5=iv(i1,6)
c$$$      do i2=i1+1,nval
c$$$      k9=iv(i2,2)
c$$$      k6=iv(i2,3)
c$$$      k6h=iv(i2,4)
c$$$      k7=iv(i2,5)
c$$$      k8=iv(i2,6)
c$$$      bopr=bo(k4)*bo(k5)*bo(k7)*bo(k8)
c$$$      if (bopr.lt.0.000100) goto 61
c$$$      nju=0
c$$$      
c$$$      if (k3.eq.k6) goto 60
c$$$*     if (k3.eq.k6) then
c$$$*     write (42,'(20i4)')k2,k3,k3h,k9,k6,k6h
c$$$*     write (42,'(20i4)')nvlx(ibsym(k4)),nvly(ibsym(k4)),
c$$$*    $nvlz(ibsym(k4))
c$$$*     write (42,'(20i4)')nvlx(ibsym(k7)),nvly(ibsym(k7)),
c$$$*    $nvlz(ibsym(k7))
c$$$*     if ((k3.lt.k2).and.(k6.lt.k9)) goto 60
c$$$*     if (nvlx(ibsym(k4)).eq.nvlx(ibsym(k7)).and.
c$$$*    $nvly(ibsym(k4)).eq.nvly(ibsym(k7)).and.
c$$$*    $nvlz(ibsym(k4)).eq.nvlz(ibsym(k7))) goto 60
c$$$*     end if
c$$$ 
c$$$      if (k4.eq.k7.and.iv(i1,4).ne.iv(i2,4)) then
c$$$      ntor=ntor+1
c$$$      it(ntor,2)=iv(i1,4)
c$$$      it(ntor,3)=iv(i1,3)
c$$$      it(ntor,4)=iv(i1,2)
c$$$      it(ntor,5)=iv(i2,4)
c$$$      it(ntor,6)=iv(i1,6)
c$$$      it(ntor,7)=iv(i1,5)
c$$$      it(ntor,8)=iv(i2,6)
c$$$      it(ntor,9)=i1
c$$$      it(ntor,10)=i2
c$$$      nju=1
c$$$      end if
c$$$      if (nju.eq.1) goto 60
c$$$      if (k4.eq.k8.and.iv(i1,4).ne.iv(i2,2)) then
c$$$      ntor=ntor+1
c$$$      it(ntor,2)=iv(i1,4)
c$$$      it(ntor,3)=iv(i1,3)
c$$$      it(ntor,4)=iv(i1,2)
c$$$      it(ntor,5)=iv(i2,2)
c$$$      it(ntor,6)=iv(i1,6)
c$$$      it(ntor,7)=iv(i1,5)
c$$$      it(ntor,8)=iv(i2,5)
c$$$      it(ntor,9)=i1
c$$$      it(ntor,10)=i2
c$$$      nju=1
c$$$      end if
c$$$      if (nju.eq.1) goto 60
c$$$      if (k5.eq.k7.and.iv(i1,2).ne.iv(i2,4)) then
c$$$      ntor=ntor+1
c$$$      it(ntor,2)=iv(i1,2)
c$$$      it(ntor,3)=iv(i1,3)
c$$$      it(ntor,4)=iv(i1,4)
c$$$      it(ntor,5)=iv(i2,4)
c$$$      it(ntor,6)=iv(i1,5)
c$$$      it(ntor,7)=iv(i1,6)
c$$$      it(ntor,8)=iv(i2,6)
c$$$      it(ntor,9)=i1
c$$$      it(ntor,10)=i2
c$$$      nju=1
c$$$      end if
c$$$      if (nju.eq.1) goto 60
c$$$      if (k5.eq.k8.and.iv(i1,2).ne.iv(i2,2)) then
c$$$      ntor=ntor+1
c$$$      it(ntor,2)=iv(i1,2)
c$$$      it(ntor,3)=iv(i1,3)
c$$$      it(ntor,4)=iv(i1,4)
c$$$      it(ntor,5)=iv(i2,2)
c$$$      it(ntor,6)=iv(i1,5)
c$$$      it(ntor,7)=iv(i1,6)
c$$$      it(ntor,8)=iv(i2,5)
c$$$      it(ntor,9)=i1
c$$$      it(ntor,10)=i2
c$$$      nju=1
c$$$      end if
c$$$   60 continue
c$$$      if (nju.eq.1) then
c$$$**********************************************************************
c$$$*                                                                    *
c$$$*     Determine force field types of torsion angles                  *
c$$$*                                                                    *
c$$$**********************************************************************
c$$$*     write (41,'(20i4)')ntor,it(ntor,2),it(ntor,3),it(ntor,4),
c$$$*    $it(ntor,5),it(ntor,6),it(ntor,7),it(ntor,8),it(ntor,9),
c$$$*    $it(ntor,10),ibsym(it(ntor,6)),ibsym(it(ntor,7)),
c$$$*    $ibsym(it(ntor,8))
c$$$      ity=0
c$$$      ih1=ia(it(ntor,2),1)
c$$$      ih2=ia(it(ntor,3),1)
c$$$      ih3=ia(it(ntor,4),1)
c$$$      ih4=ia(it(ntor,5),1)
c$$$      if (ih2.gt.ih3) then
c$$$      ih1=ia(it(ntor,5),1)
c$$$      ih2=ia(it(ntor,4),1)
c$$$      ih3=ia(it(ntor,3),1)
c$$$      ih4=ia(it(ntor,2),1)
c$$$      end if
c$$$      if (ih2.eq.ih3.and.ih4.lt.ih1) then
c$$$      ih1=ia(it(ntor,5),1)
c$$$      ih2=ia(it(ntor,4),1)
c$$$      ih3=ia(it(ntor,3),1)
c$$$      ih4=ia(it(ntor,2),1)
c$$$      end if
c$$$      do i3=1,ntoty
c$$$      if (ih1.eq.nts(i3,1).and.ih2.eq.nts(i3,2).and.ih3.eq.nts(i3,3)
c$$$     $.and.ih4.eq.nts(i3,4)) ity=i3
c$$$      end do
c$$$      if (ity.eq.0) then
c$$$      do i3=1,ntoty
c$$$      if (nts(i3,1).eq.0.and.ih2.eq.nts(i3,2).and.ih3.eq.nts(i3,3)
c$$$     $.and.nts(i3,4).eq.0) ity=i3
c$$$      end do
c$$$      end if
c$$$      if (ity.eq.0) then
c$$$      ntor=ntor-1           !Torsion angle does not exist in force field: ignore
c$$$      else
c$$$      it(ntor,1)=ity
c$$$      end if
c$$$      end if
c$$$
c$$$   61 end do
c$$$   62 end do
c$$$      if (ntor.gt.ntomax) stop 'Too many torsion angles'
c$$$
c$$$      return
c$$$      end
c$$$********************************************************************** 
d1321 1
d1323 1
d1346 11
d1502 4
d1621 4
d1677 3
@


4.5.4.1
log
@Implemented ri*Fi pressure calc
@
text
@a2115 4

* Only need to compute bonds where j2 is local
      if (j2 .le. na_local) then

a2167 3

      endif

@


4.5.4.2
log
@Optimized speed and memory footprint of ReaxFF by eliminating angles and torsions made redundant by reverse communication. Also set Lprune=4 and Lhb=0 without missing and force terms.
@
text
@d468 2
a469 2
*     performance. For correct results, it should be set to 4.       *
*     However, making it smaller can speed up       *
d471 1
a471 1
*     Setting it to 0 turns off pruning, useful for debugging.                             *
d474 3
a476 3
      Lprune = 4
c$$$      Lprune = 0
********************************************************************* 
d478 5
a482 6
*     Lhb controls whether or not to prune ghost bonds that          *
*     may possibly form ghost hydrogen bonds.                        *
*     Setting it to 1 suppresses pruning, and so is the safe option. *
*     However, Lprune = 4 and Lhb = 0 should give exact results.  *
*     If Lprune = 0, then pruning is not used, results are exact     *
*     and Lhb has no effect.                                         *
d485 2
a486 2
c$$$      Lhb = 1
      Lhb = 0
d504 4
d679 176
d903 1
a903 1
c$$$     $     ntmp6
d1235 188
a1474 8
*     Exclude angles that have no local atoms.
*     Angles with non-local center atom are not needed for angle
*     energies, but are needed to construct torsions. 
      if ( k4 .le. na_local .or. 
     $     k5 .le. na_local .or. 
     $     k7 .le. na_local .or. 
     $     k8 .le. na_local) then 

a1550 8
      if (iju.eq.1) goto 50

      write (6,*)'nval = ',nval,
     $        ' after',iindexatom, ' of ',na,' atoms completed.'
      stop 'Adjacent bonds did not make an angle'

      endif

d1666 161
a1832 1
#include "cbkc.blk"
a1833 1
#include "cbkrbo.blk"
a1855 11

      jbond1=ib(iindexbondlist,2)
      jbond2=ib(iindexbondlist,3)

c     Only compute interaction if both atoms
c     are local or else flip a coin

      if (jbond1 .le. na_local) then
      if (jbond2 .le. na_local .or. 
     $     itag(jbond1) .lt. itag(jbond2)) then

a2000 4

      endif
      endif

@


4.4
log
@Finished fixing bug in reax_connect.F
@
text
@d427 4
a430 2
      write (6,*)nbonall,nboallmax,ivl,nvpair
      stop 'Too many bonds; maybe wrong cell parameters'
d438 4
a441 2
         write (6,*)ia(i1,2),mbond
         stop 'Too many bonds on atom. Increase mbond'
d447 4
a450 2
            write (6,*)ia(i2,2),mbond
            stop 'Too many bonds on atom. Increase mbond'
d886 10
d915 9
a930 5
      if (nbon.gt.nbomax) then 
      write (6,*)nbon,nbomax
      stop 'Too many bonds; maybe wrong cell parameters'
      end if

d1552 8
a1661 2

      if (nval.gt.nvamax) stop 'Too many valency angles'
d1947 8
a2001 1
      if (ntor.gt.ntomax) stop 'Too many torsion angles'
d2134 3
a2136 1
      stop 'Maximum number of hydrogen bonds exceeded'
@


4.3
log
@Fixed bug in reax_connect.F
@
text
@d271 1
d461 16
a476 2
*     Lprune controls whether bond-pruning is performed to increase  *
*     performance.                                                   *
d479 4
a482 2
      Lprune = 0
      if (Lprune .eq. 1) then
d485 3
a487 2
*     Eliminate bonds that are not in dihedral with a local atom     *
*     Need to include bonds adjacent to those bonds too.             *
d498 10
d525 1
d543 2
d546 1
d585 1
a585 27
      do i1 = 1,nbonall
         if (nboncol(i1).eq.3) then
* One end definitely has a bond of color 2
* Find it and color bonds on other end 4
            i3=iball(i1,2)
            i3b=0
            do i4 = 1,ia(i3,2)
               i5=nubon2(i3,i4)
               if (nboncol(i5).eq.2) then
                  i3b=iball(i1,3)
               endif
            end do

            if (i3b.eq.0) then
               i3=iball(i1,3)
               i3b=0
               do i4 = 1,ia(i3,2)
                  i5=nubon2(i3,i4)
                  if (nboncol(i5).eq.2) then
                     i3b=iball(i1,2)
                  endif
               end do
            endif

            if (i3b.eq.0) then
               stop 'Could not find color 2 from color 3 bond'
            endif
d587 1
a587 10
            do i4 = 1,ia(i3b,2)
               i5=nubon2(i3b,i4)
               if (nboncol(i5).eq.0) then
                  nboncol(i5)=4
                  ntmp4 = ntmp4+1
               endif
            end do
           
         endif
      end do
d589 1
d628 3
d632 1
d671 168
d849 23
d886 2
@


4.2
log
@Added ramp variants for thermostats
@
text
@d274 1
d354 1
a354 1
* Fist detect all bonds and create preliminary list
d460 8
d469 1
a469 1
*     Need to include bonds adjacent to those bonds too.              *
d479 1
d631 39
d693 18
@


4.1
log
@reaxFF: Added 1-5 neighbors of local atoms to bond list; needed for over-coordination forces.
@
text
@a237 3
      dx=dx-anint(dx/aaxh)*aaxh
      dy=dy-anint(dy/baxh)*baxh
      dz=dz-anint(dz/caxh)*caxh
d1785 1
d1825 5
a1829 1
      call dista2(j2,i2,dishb,dx,dy,dz)
@


4.0
log
@This is version 4.0
@
text
@d463 1
d472 1
d546 77
@


1.1
log
@Merged REAX version with main version
@
text
@d1 15
a15 1
********************************************************************** 
@

