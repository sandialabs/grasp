head	4.12;
access;
symbols
	ReverseComm_branch:4.4.0.4
	ADTools_branch:4.4.0.2
	Monaco_Aidan:4.0.0.12
	Root-of-Monaco_Aidan:4.0
	PPPM_Crozier2:4.0.0.10
	PPPM_Crozier:4.0
	Root-of-PPPM_Crozier:4.0
	Monaco:4.0.0.8
	PreMonaco:4.0
	Recovery-2004-04-12:4.0
	BRANCH:4.0.0.6
	PMONACO:4.0.0.4
	ROOT:4.0
	initial:4.0.0.2
	pmonaco:4.0
	Version_4_0:4.0;
locks; strict;
comment	@c @;


4.12
date	2009.02.11.23.25.17;	author athomps;	state Exp;
branches;
next	4.11;

4.11
date	2007.10.23.22.05.56;	author athomps;	state Exp;
branches;
next	4.10;

4.10
date	2007.05.30.05.41.46;	author athomps;	state Exp;
branches;
next	4.9;

4.9
date	2007.03.15.22.01.01;	author athomps;	state Exp;
branches;
next	4.8;

4.8
date	2007.01.16.21.56.22;	author athomps;	state Exp;
branches;
next	4.7;

4.7
date	2006.12.12.06.57.32;	author athomps;	state Exp;
branches;
next	4.6;

4.6
date	2006.11.28.06.24.21;	author athomps;	state Exp;
branches;
next	4.5;

4.5
date	2006.11.09.20.13.52;	author athomps;	state Exp;
branches;
next	4.4;

4.4
date	2005.10.11.01.40.34;	author athomps;	state Exp;
branches
	4.4.4.1;
next	4.3;

4.3
date	2005.08.30.21.44.25;	author athomps;	state Exp;
branches;
next	4.2;

4.2
date	2005.08.10.20.17.02;	author athomps;	state Exp;
branches;
next	4.1;

4.1
date	2005.08.03.17.56.30;	author athomps;	state Exp;
branches;
next	4.0;

4.0
date	2005.04.05.16.43.30;	author athomps;	state Exp;
branches;
next	1.1;

1.1
date	2005.04.02.00.37.56;	author athomps;	state Exp;
branches;
next	;

4.4.4.1
date	2006.09.06.18.46.13;	author athomps;	state Exp;
branches;
next	4.4.4.2;

4.4.4.2
date	2006.09.07.19.49.27;	author athomps;	state Exp;
branches;
next	4.4.4.3;

4.4.4.3
date	2006.09.08.18.14.51;	author athomps;	state Exp;
branches;
next	4.4.4.4;

4.4.4.4
date	2006.11.08.04.18.38;	author athomps;	state Exp;
branches;
next	4.4.4.5;

4.4.4.5
date	2006.11.09.00.20.53;	author athomps;	state Exp;
branches;
next	;


desc
@@


4.12
log
@Fixed the Triple bond issue and double counting of estrain for torsions.
@
text
@**********************************************************************
*                                                                    *
*     REAXFF Reactive force field program                            *
*                                                                    *
*     Developed and written by Adri van Duin, duin@@wag.caltech.edu   *
*                                                                    *
*     Copyright (c) 2001-2010 California Institute of Technology     *
*                                                                    *
*     This is an open-source program. Feel free to modify its        *
*     contents. Please keep me informed of any useful modification   *
*     or addition that you made. Please do not distribute this       *
*     program to others; if people are interested in obtaining       *
*     a copy of this program let them contact me first.              *
*                                                                    *
**********************************************************************
******************************************************************** 

      subroutine calval

********************************************************************** 
#include "cbka.blk"
#include "cbkc.blk"
#include "cbkdhdc.blk"
#include "cbkdrdc.blk"
#include "cbkh.blk"
#include "cbkrbo.blk"
#include "cbkvalence.blk"
#include "cellcoord.blk"
#include "control.blk"
      dimension a(3),b(3),j(3),dradc(3,3),drbdc(3,3),dtdc(3,3),
     $dargdc(3,3),dndc(3,3),dadc(3),dbdc(3)
********************************************************************** 
*                                                                    *
*     Calculate valency angles and their derivatives to cartesian    *
*     coordinates                                                    *
*     Valency angle energies are calculated in valang                *
*                                                                    *
********************************************************************** 
********************************************************************** 
*     Description of variables used in this routine.       
*                                                          
*     ndebug: stored in cbka.blk; control-parameter
*     third: local variable                  
*     twothird: local variable    
*     dadc(3): local array; stores derivative distance to cartesians    
*     dbdc(3): local array; stores derivative distance to cartesians
*     i1: local do-loop counter
*     i2: local do-loop counter
*     k1: local do-loop counter
*     k2: local do-loop counter
*     dradc(3,3): local array; stores derivatives bond lengths to
*                 cartesians
*     drbdc(3,3): local array; stores derivatives bond lengths to
*                 cartesians
*     nval: stored in cbka.blk; number of valence angles
*     ity: local integer; atom type                        
*     iv(nvalmax,6): stored in cbka.blk; valence angle identifiers
*     j(3): local integer array; stores valence angle atom numbers
*     la: local integer: stores bond numbers in valence angle
*     lb: local integer: stores bond numbers in valence angle
*     ivl1: local integer; stores symmetric copy number of bond
*     ivl2: local integer; stores symmetric copy number of bond
*     ibsym(nbomax): stored in cbka.blk; symmetric copy number of bond
*     isign1: local integer; -1 or 1                       
*     isign2: local integer; -1 or 1                       
*     rla: local variable; stores bond length for bond la
*     rlb: local variable; stores bond length for bond lb
*     rbo(nbomax): stored in cbka.blk; stores bond lengths
*     ix1,iy1,iz1,ix2,iy2,iz2: local integers; periodic cell shifts
*     a(3): local variable; distance in x,y and z-direction between atoms
*     b(3): local variable; distance in x,y and z-direction between atoms
*     c(nat,3): stored in cbka.blk; cartesian coordinate array
*     tm11,tm21,tm22,tm31,tm32,tm33: stored in cbka.blk; periodic cell
*                  matrix                                  
*     poem: local variable; product of bond lengths                                 
*     tel: local variable; cross-product of x,y and z-interatomic
*                  distances                    
*     arg: local variable; cosine of angle between bonds a and b
*     arg2: local variable; square of arg
*     s1ma22: local variable; used to check whether angle gets to 180
*                  degrees
*     s1ma2: local variable; square root of s1ma22                         
*     hl: local variable; angle (in radians) between bonds a and b
*     h(nvamax): stored in cbka.blk; angle (in radians) between bonds a
*                  and b
*     ib(nbomax,3): stored in cbka.blk: bond distance identifiers                   
*     drdc(nbomax,3,2): stored in cbka.blk; derivatives bond distances
*                  to cartesian coordinates
*     dndc(3,3): local variable; temporary storage for calculating
*                  derivatives of valence angle to cartesians
*     dtdc(3,3): local variable; temporary storage for calculating
*                  derivatives of valence angle to cartesians
*     dargdc(3,3): local variable; temporary storage for calculating
*                  derivatives of valence angle to cartesians
*     dhdc(nvamax,3,3): stored in cbka.blk; derivatives of valence angle 
*                  to cartesians
*                                                          
********************************************************************** 
c$$$      if (ndebug.eq.1) then
c$$$C      open (65,file='fort.65',status='unknown',access='append')
c$$$      write (65,*) 'In calval'
c$$$      call timer(65)
c$$$      close (65)
c$$$      end if

      third=1.0/3.0
      twothird=2.0/3.0
      dadc(1)=-1.0
      dadc(2)=1.0
      dadc(3)=0.0
      dbdc(1)=0.0
      dbdc(2)=1.0
      dbdc(3)=-1.0
      do k1=1,3
      do k2=1,3
      dradc(k1,k2)=0.0
      drbdc(k1,k2)=0.0
      end do
      end do
      if (nval.eq.0) return
 
      do 10 i1=1,nval
      ity=iv(i1,1)
      j(1)=iv(i1,2)
      j(2)=iv(i1,3)
      j(3)=iv(i1,4)
**********************************************************************
*                                                                    *
*     Determine valency angle                                        *
*                                                                    *
**********************************************************************
      la=iv(i1,5)
      lb=iv(i1,6)
      ivl1=ibsym(la)
      ivl2=ibsym(lb)
      isign1=1
      isign2=1
      rla=rbo(la)
      rlb=rbo(lb)
 
      call dista2(j(2),j(1),dis,a(1),a(2),a(3))
      call dista2(j(2),j(3),dis,b(1),b(2),b(3))

      poem=rla*rlb
      tel=a(1)*b(1)+a(2)*b(2)+a(3)*b(3)
      arg=tel/poem
      arg2=arg*arg
      s1ma22=1.0-arg2
      if (s1ma22.lt.1.0d-10) s1ma22=1.0d-10
      s1ma2=sqrt(s1ma22)
      if (arg.gt.1.0) arg=1.0
      if (arg.lt.-1.0) arg=-1.0
      hl=acos(arg)
      h(i1)=hl
**********************************************************************
*                                                                    *
*     Calculate derivative valency angle to cartesian coordinates    *
*                                                                    *
**********************************************************************
      if (j(1).eq.ib(la,2)) then
      do k1=1,3
      dradc(k1,1)=drdc(la,k1,1)
      dradc(k1,2)=drdc(la,k1,2)
      end do
      else
      do k1=1,3
      dradc(k1,1)=drdc(la,k1,2)
      dradc(k1,2)=drdc(la,k1,1)
      end do
      end if
      if (j(2).eq.ib(lb,2)) then
      do k1=1,3
      drbdc(k1,2)=drdc(lb,k1,1)
      drbdc(k1,3)=drdc(lb,k1,2)
      end do
      else
      do k1=1,3
      drbdc(k1,2)=drdc(lb,k1,2)
      drbdc(k1,3)=drdc(lb,k1,1)
      end do
      end if
      do k1=1,3
      do k2=1,3
      dndc(k1,k2)=rla*drbdc(k1,k2)+rlb*dradc(k1,k2)
      dtdc(k1,k2)=a(k1)*dbdc(k2)+b(k1)*dadc(k2)
      dargdc(k1,k2)=(dtdc(k1,k2)-arg*dndc(k1,k2))/poem
      dhdc(i1,k1,k2)=-dargdc(k1,k2)/s1ma2
      end do
      end do
      
   10 continue

      return
      end
********************************************************************** 
********************************************************************** 

      subroutine boncor

********************************************************************** 
#include "cbka.blk"
#include "cbkabo.blk"
#include "cbkc.blk"
#include "cbkbo.blk"
#include "cbkboncor.blk"
#include "cbkbosi.blk"
#include "cbkbopi.blk"
#include "cbkbopi2.blk"
#include "cbkconst.blk"
#include "cbkdbopi2ndc.blk"
#include "cbkdbopidc.blk"
#include "cbkdbopindc.blk"
#include "cbkff.blk"
#include "cbkia.blk"
#include "cbkidbo.blk"
#include "cbknubon2.blk"
#include "cbkrbo.blk"
#include "control.blk"
#include "small.blk"
#include "cbkdbodc.blk"
c$$$      if (ndebug.eq.1) then
c$$$C      open (65,file='fort.65',status='unknown',access='append')
c$$$      write (65,*) 'In boncor'
c$$$      call timer(65)
c$$$      close (65)
c$$$      end if
********************************************************************** 
*                                                                    *
*     Correction for overcoordination and 1-3 bond orders            *
*                                                                    *
********************************************************************** 
********************************************************************** 
*     Description of variables used in this routine.       
*                                                          
*     ndebug: stored in cbka.blk; control-parameter
*     i1: local do-loop counter
*     i2: local do-loop counter
*     k1: local do-loop counter
*     k2: local do-loop counter
*     nbon: stored in cbka.blk; number of bonds in system
*     ibt: local integer; stores bond type
*     ib(nbomax,3): stored in cbka.blk: bond distance identifiers                   
*     j1: local integer; stores atom number 1st atom in bond
*     j2: local integer; stores atom number 2nd atom in bond
*     ovc(nbotym): stored in cbka.blk: force field parameter for
*                  overcoordination correction
*     v13cor(nbotym): stored in cbka.blk: force field parameter for
*                  1-3 bond order correction
*     idbo1(nbomax): stored in cbka.blk; number of atoms in the
*                  derivative of the bond order
*     idbo(nbomax,2*mbond): stored in cbka.blk; atom numbers of the
*                  atoms in the derivative of the bond order
*     dbondc(nbomax,3,2*mbond): stored in cbka.blk; derivative of
*                  corrected total bond orders to cartesians
*     dbosindc(nbomax,3,2*mbond): stored in cbka.blk; derivative of
*                  corrected sigma bond orders to cartesians
*     dbopindc(nbomax,3,2*mbond): stored in cbka.blk; derivative of
*                  corrected pi bond orders to cartesians
*     dbopi2ndc(nbomax,3,2*mbond): stored in cbka.blk; derivative of
*                  corrected double pi bond orders to cartesians
*     dbodc(nbomax,3,2): stored in cbka.blk; derivative of
*                  uncorrected total bond orders to cartesians
*     dbosidc(nbomax,3,2): stored in cbka.blk; derivative of
*                  uncorrected sigma bond orders to cartesians
*     dbopidc(nbomax,3,2): stored in cbka.blk; derivative of
*                  uncorrected pi bond orders to cartesians
*     dbopi2dc(nbomax,3,2): stored in cbka.blk; derivative of
*                  uncorrected double pi bond orders to cartesians
*     boo: local variable; storage of uncorrected total bond order
*     bo(nbomax): stored in cbka.blk; total bond order          
*     bopi(nbomax): stored in cbka.blk; pi bond order          
*     bopi2(nbomax): stored in cbka.blk; double pi bond order          
*     bopio: local variable; storage of uncorrected pi bond order
*     bopi2o: local variable; storage of uncorrected double pi bond order
*     iti: local integer; atom type first atom in bond     
*     itj: local integer; atom type second atom in bond     
*     ia(nat,mbond+3): stored in cbka.blk; connection table without bond
*                  order cutoff
*     aboi: local variable: total bond order around atom i
*     aboj: local variable: total bond order around atom j
*     abo(nat): stored in cbka.blk; total bond order around atoms
*     vp131: local variable; force field cross-term        
*     vp132: local variable; force field cross-term        
*     vp133: local variable; force field cross-term        
*     bo131(nsort): stored in cbka.blk; force field parameter for 1-3
*                  bond order correction
*     bo132(nsort): stored in cbka.blk; force field parameter for 1-3
*                  bond order correction
*     bo133(nsort): stored in cbka.blk; force field parameter for 1-3
*                  bond order correction
*     corrtot:local variable; total correction on bond order
*     dbodsboi1: local variable; derivative of bond order to sum of bond
*                  orders around atom i
*     dbodsboj1: local variable; derivative of bond order to sum of bond
*                  orders around atom j
*     ovi: local variable; overcoordination on atom i      
*     ovj: local variable; overcoordination on atom j      
*     aval(nat): stored in cbka.blk; nr. of valence electrons on atom       
*     exphu1: local variable; stores exponential
*     exphu2: local variable; stores exponential
*     exp11: local variable; stores exponential
*     exp21: local variable; stores exponential
*     vpar(npamax): stored in cbka.blk: general parameters                                  
*     exphu12: local variable; stores sum of exponential
*     ovcor: local variable; temporary storage for BO/ovcor corr.
*     huli: local variable; temporary storage for BO/ovcor corr.
*     hulj: local variable; temporary storage for BO/ovcor corr.
*     corr1: local variable; temporary storage for BO/ovcor corr.
*     corr2: local variable; temporary storage for BO/ovcor corr.
*     dbodsboi2: local variable; derivative of 1-3 BO correction to sum 
*                  of bond orders around atom i 
*     dbodsboj2: local variable; derivative of 1-3 BO correction to sum 
*                  of bond orders around atom i 
*     bocor1: local variable; 1-3 bond order correction                            
*     bocor2: local variable; 1-3 bond order correction                            
*     ovi2: local variable; overcoordination on atom i with reference to
*                  total number of electrons on atom i, including lone
*                  pairs     
*     ovj2: local variable; overcoordination on atom j with reference to
*                  total number of electrons on atom j, including lone
*                  pairs     
*     valf(nsort): stored in cbka.blk; total number of electrons on 
*                  atom, including lone pairs
*     cor1: local variable; temporary storage for BO/1-3 bond corr.
*     cor2: local variable; temporary storage for BO/1-3 bond corr.
*     exphu3: local variable; storage exponential
*     exphu4: local variable; storage exponential
*     corrtot2: local variable; square of corrtot                                  
*     dbodboo: local variable; derivative of corrected total bond order to 
*                   uncorrected bond order
*     dbopidbopio: local variable; derivative of corrected pi bond order
*                   to uncorrected pi bond order
*     dbopidboo: local variable; derivative of corrected pi bond order
*                   to uncorrected total bond order
*     dbopi2dbopi2o: local variable; derivative of corrected double pi bond order
*                   to uncorrected double pi bond order
*     dbopi2dboo: local variable; derivative of corrected double pi bond order
*                   to uncorrected total bond order
*     dbodsboit: local variable; derivative of total bond order to sum
*                   of bond orders around atom i
*     dbodsbojt: local variable; derivative of total bond order to sum
*                   of bond orders around atom j
*     vhui: local variable; temporary storage              
*     vhuj: local variable; temporary storage              
*     dbopidsboit: local variable; derivative of pi bond order to sum
*                   of bond orders around atom i
*     dbopidsbojt: local variable; derivative of pi bond order to sum
*                   of bond orders around atom j
*     dbopi2dsboit: local variable; derivative of pi bond order to sum
*                   of bond orders around atom i
*     dbopi2dsbojt: local variable; derivative of pi bond order to sum
*                   of bond orders around atom j
*     nco: local integer; counter for number of atoms in derivative
*     ihl: local integer; helps to access right dbodc-term
*     nubon2(nat,mbond): stored in cbka.blk; stored bond number as a
*                   function of atom number and connection number
*     iob: local integer; atom number of second atom in bond
*     ncubo: local integer; stores number of current bond  
*     na: stored in cbka.blk: number of atoms in system 
*     zero: stored in cbka.blk: value 0.00
*                                                          
********************************************************************** 
      do 10 i1=1,nbon
      ibt=ib(i1,1)
      j1=ib(i1,2)
      j2=ib(i1,3)
      if (ovc(ibt).lt.0.001.and.v13cor(ibt).lt.0.001) then
      idbo1(i1)=2
      idbo(i1,1)=j1
      idbo(i1,2)=j2
      do k1=1,3
      dbondc(i1,k1,1)=dbodc(i1,k1,1)
      dbondc(i1,k1,2)=dbodc(i1,k1,2)
      dbosindc(i1,k1,1)=dbosidc(i1,k1,1)
      dbosindc(i1,k1,2)=dbosidc(i1,k1,2)
      dbopindc(i1,k1,1)=dbopidc(i1,k1,1)
      dbopindc(i1,k1,2)=dbopidc(i1,k1,2)
      dbopi2ndc(i1,k1,1)=dbopi2dc(i1,k1,1)
      dbopi2ndc(i1,k1,2)=dbopi2dc(i1,k1,2)
      end do
      goto 10
      end if
      boo=bo(i1)
      bopio=bopi(i1)
      bopi2o=bopi2(i1)
      iti=ia(j1,1)
      itj=ia(j2,1)
      aboi=abo(j1)
      aboj=abo(j2)
      vp131=sqrt(bo131(iti)*bo131(itj))
      vp132=sqrt(bo132(iti)*bo132(itj))
      vp133=sqrt(bo133(iti)*bo133(itj))
      corrtot=1.0
      dbodsboi1=zero
      dbodsboj1=zero
      if (ovc(ibt).gt.0.001) then
      ovi=aboi-aval(iti)
      ovj=aboj-aval(itj)

********************************************************************** 
*                                                                    *
*     Correction for overcoordination                                *
*                                                                    *
********************************************************************** 
      exphu1=exp(-vpar(2)*ovi)
      exphu2=exp(-vpar(2)*ovj)
      exp11=exp(-vpar(1)*ovi)
      exp21=exp(-vpar(1)*ovj)
      exphu12=(exphu1+exphu2)
      ovcor=-(1.0/vpar(2))*log(0.50*exphu12)
*     huli=((1.0/ovc(ibt))*aval(iti)+exp11+exp21)
*     hulj=((1.0/ovc(ibt))*aval(itj)+exp11+exp21)
      huli=aval(iti)+exp11+exp21
      hulj=aval(itj)+exp11+exp21
      corr1=huli/(huli+ovcor)
      corr2=hulj/(hulj+ovcor)
      corrtot=0.50*(corr1+corr2)

      dbodsboi1=0.50*(-vpar(1)*exp11/(huli+ovcor)-
     $(corr1/(huli+ovcor))*
     $(-vpar(1)*exp11+exphu1/exphu12)-vpar(1)*exp11/(hulj+ovcor)-
     $(corr2/(hulj+ovcor))*(-vpar(1)*exp11+exphu1/exphu12))
      dbodsboj1=0.50*(-vpar(1)*exp21/(huli+ovcor)-
     $(corr1/(huli+ovcor))*
     $(-vpar(1)*exp21+exphu2/exphu12)-vpar(1)*exp21/(hulj+ovcor)-
     $(corr2/(hulj+ovcor))*(-vpar(1)*exp21+exphu2/exphu12))
      end if
********************************************************************** 
*                                                                    *
*     Correction for 1-3 bond orders                                 *
*                                                                    *
********************************************************************** 
      dbodsboi2=zero
      dbodsboj2=zero
      bocor1=1.0
      bocor2=1.0
      if (v13cor(ibt).gt.0.001) then
      ovi2=aboi-vval3(iti)                  !Modification for metal surfaces
      ovj2=aboj-vval3(itj)
*     ovi2=aboi-valf(iti)
*     ovj2=aboj-valf(itj)
*     ovi2=aboi-aval(iti)
*     ovj2=aboj-aval(itj)
      cor1=vp131*boo*boo-ovi2
      cor2=vp131*boo*boo-ovj2
*     exphu3=v13cor(ibt)*exp(-vp132*cor1+vp133)
*     exphu4=v13cor(ibt)*exp(-vp132*cor2+vp133)
      exphu3=exp(-vp132*cor1+vp133)
      exphu4=exp(-vp132*cor2+vp133)
      bocor1=1.0/(1.0+exphu3)
      bocor2=1.0/(1.0+exphu4)
      dbodsboi2=-bocor1*bocor1*bocor2*vp132*exphu3
      dbodsboj2=-bocor1*bocor2*bocor2*vp132*exphu4
      end if

      bo(i1)=boo*corrtot*bocor1*bocor2
      if (bo(i1).lt.1e-10) bo(i1)=zero
      corrtot2=corrtot*corrtot
      bopi(i1)=bopio*corrtot2*bocor1*bocor2
      bopi2(i1)=bopi2o*corrtot2*bocor1*bocor2
      if (bopi(i1).lt.1e-10) bopi(i1)=zero
      if (bopi2(i1).lt.1e-10) bopi2(i1)=zero

      dbodboo=corrtot*bocor1*bocor2+corrtot*
     $bocor1*bocor1*bocor2*boo*vp132*vp131*2.0*boo*exphu3+
     $corrtot*bocor1*bocor2*bocor2*boo*
     $vp132*vp131*exphu4*2.0*boo

      dbopidbopio=corrtot2*bocor1*bocor2

      dbopidboo=corrtot2*
     $bocor1*bocor1*bocor2*boo*vp132*vp131*2.0*bopio*exphu3+
     $corrtot2*bocor1*bocor2*bocor2*boo*
     $vp132*vp131*exphu4*2.0*bopio

      dbopi2dbopi2o=corrtot2*bocor1*bocor2

      dbopi2dboo=corrtot2*
     $bocor1*bocor1*bocor2*boo*vp132*vp131*2.0*bopi2o*exphu3+
     $corrtot2*bocor1*bocor2*bocor2*boo*
     $vp132*vp131*exphu4*2.0*bopi2o

      dbodsboit=boo*dbodsboi1*bocor1*bocor2+boo*corrtot*dbodsboi2
      dbodsbojt=boo*dbodsboj1*bocor1*bocor2+boo*corrtot*dbodsboj2

      vhui=2.0*corrtot*dbodsboi1*bocor1*bocor2+corrtot2*dbodsboi2
      vhuj=2.0*corrtot*dbodsboj1*bocor1*bocor2+corrtot2*dbodsboj2
      dbopidsboit=bopio*vhui
      dbopidsbojt=bopio*vhuj

      dbopi2dsboit=bopi2o*vhui
      dbopi2dsbojt=bopi2o*vhuj

********************************************************************** 
*                                                                    *
*     Calculate bond order derivatives                               *
*                                                                    *
********************************************************************** 
      idbo1(i1)=2+ia(j1,2)+ia(j2,2)
      idbo(i1,1)=j1
      idbo(i1,2)=j2
      nco=0
      do k1=1,3
      dbondc(i1,k1,1)=dbodc(i1,k1,1)*dbodboo
      dbondc(i1,k1,2)=dbodc(i1,k1,2)*dbodboo
*     dbosindc(i1,k1,1)=dbosidc(i1,k1,1)*dbosidboo
*     dbosindc(i1,k1,2)=dbosidc(i1,k1,2)*dbosidboo
      dbopindc(i1,k1,1)=dbopidc(i1,k1,1)*dbopidbopio+
     $dbodc(i1,k1,1)*dbopidboo
      dbopindc(i1,k1,2)=dbopidc(i1,k1,2)*dbopidbopio+
     $dbodc(i1,k1,2)*dbopidboo
      dbopi2ndc(i1,k1,1)=dbopi2dc(i1,k1,1)*dbopi2dbopi2o+
     $dbodc(i1,k1,1)*dbopi2dboo
      dbopi2ndc(i1,k1,2)=dbopi2dc(i1,k1,2)*dbopi2dbopi2o+
     $dbodc(i1,k1,2)*dbopi2dboo
      end do
      do i2=1,ia(j1,2)
      ihl=0
      iob=ia(j1,2+i2)
      if (iob.lt.j1) ihl=1
      ncubo=nubon2(j1,i2)
      idbo(i1,2+nco+1)=iob
      do k1=1,3
      dbondc(i1,k1,1)=dbondc(i1,k1,1)+dbodc(ncubo,k1,1+ihl)*dbodsboit
      dbondc(i1,k1,2+nco+1)=dbodc(ncubo,k1,2-ihl)*dbodsboit

*     dbosindc(i1,k1,1)=dbosindc(i1,k1,1)+
*    $dbodc(ncubo,k1,1+ihl)*dbosidsboit
*     dbosindc(i1,k1,2+nco+1)=dbodc(ncubo,k1,2-ihl)*dbosidsboit

      dbopindc(i1,k1,1)=dbopindc(i1,k1,1)+
     $dbodc(ncubo,k1,1+ihl)*dbopidsboit
      dbopindc(i1,k1,2+nco+1)=dbodc(ncubo,k1,2-ihl)*dbopidsboit

      dbopi2ndc(i1,k1,1)=dbopi2ndc(i1,k1,1)+
     $dbodc(ncubo,k1,1+ihl)*dbopi2dsboit
      dbopi2ndc(i1,k1,2+nco+1)=dbodc(ncubo,k1,2-ihl)*dbopi2dsboit

      end do
      nco=nco+1
      end do
      do i2=1,ia(j2,2)
      ihl=0
      iob=ia(j2,2+i2)
      if (iob.lt.j2) ihl=1
      ncubo=nubon2(j2,i2)
      idbo(i1,2+nco+1)=iob
      do k1=1,3

      dbondc(i1,k1,2)=dbondc(i1,k1,2)+dbodc(ncubo,k1,1+ihl)*dbodsbojt
      dbondc(i1,k1,2+nco+1)=dbodc(ncubo,k1,2-ihl)*dbodsbojt

*     dbosindc(i1,k1,2)=dbosindc(i1,k1,2)+
*    $dbodc(ncubo,k1,1+ihl)*dbosidsbojt
*     dbosindc(i1,k1,2+nco+1)=dbodc(ncubo,k1,2-ihl)*dbosidsbojt

      dbopindc(i1,k1,2)=dbopindc(i1,k1,2)+
     $dbodc(ncubo,k1,1+ihl)*dbopidsbojt
      dbopindc(i1,k1,2+nco+1)=dbodc(ncubo,k1,2-ihl)*dbopidsbojt

      dbopi2ndc(i1,k1,2)=dbopi2ndc(i1,k1,2)+
     $dbodc(ncubo,k1,1+ihl)*dbopi2dsbojt
      dbopi2ndc(i1,k1,2+nco+1)=dbodc(ncubo,k1,2-ihl)*dbopi2dsbojt

      end do
      nco=nco+1
      end do

   10 continue

      do i1=1,na
      abo(i1)=zero
      end do
*     do i1=1,na
*     do i2=1,ia(i1,2)
*     iob=ia(i1,2+i2)
*     ncubo=nubon2(i1,i2)
*     abo(i1)=abo(i1)+bo(ncubo)
*     end do
*     end do
      do i1=1,nbon
      j1=ib(i1,2)
      j2=ib(i1,3)
      abo(j1)=abo(j1)+bo(i1)
      if (j1.ne.j2) abo(j2)=abo(j2)+bo(i1)
      end do

   15 continue
      return
      end
********************************************************************** 
********************************************************************** 

      subroutine lonpar

********************************************************************** 
#include "cbka.blk"
#include "cbkabo.blk"
#include "cbkconst.blk"
#include "cbkc.blk"
#include "cbkd.blk"
#include "cbkdcell.blk"
#include "cbkenergies.blk"
#include "cbkff.blk"
#include "cbkia.blk"
#include "cbkidbo.blk"
#include "cbklonpar.blk"
#include "cbknubon2.blk"
#include "control.blk"
#include "small.blk"
      dimension virial_tmp(3,3),virialsym(6)
c$$$      if (ndebug.eq.1) then
c$$$C      open (65,file='fort.65',status='unknown',access='append')
c$$$      write (65,*) 'In lonpar'
c$$$      call timer(65)
c$$$      close (65)
c$$$      end if
**********************************************************************
*                                                                    *
*     Calculate lone pair energy and first derivatives               *
*                                                                    *
**********************************************************************
      elp=zero
      do i1=1,na
**********************************************************************
*                                                                    *
*     Determine number of lone pairs on atoms
*                                                                    *
**********************************************************************
      ity=ia(i1,1)
      voptlp=0.50*(stlp(ity)-aval(ity))
      vlp(i1)=zero
      vund=abo(i1)-stlp(ity)
      vlph=2.0*int(vund/2.0)
      vlpex=vund-vlph
      vp16h=vpar(16)-1.0

      expvlp=exp(-vpar(16)*(2.0+vlpex)*(2.0+vlpex))
      dvlpdsbo(i1)=-vpar(16)*2.0*(2.0+vlpex)*expvlp
      vlp(i1)=expvlp-int(vund/2.0)
*     expvlp=exp(-vpar(16)*(2.0+vlpex))
*     dvlpdsbo(i1)=-vpar(16)*expvlp
*     expvlp=exp(-6.0*((-0.50*vlpex)**vpar(16)))
*     vlp(i1)=(1.0-expvlp)-int(vund/2.0)
*     dvlpdsbo(i1)=-0.5*6.0*vpar(16)*((-0.5*vlpex)**vp16h)*
*    $expvlp
**********************************************************************
*                                                                    *
*     Calculate lone pair energy                                     *
*                                                                    *
**********************************************************************
      if (i1 .le. na_local) then

      diffvlp=voptlp-vlp(i1)
      exphu1=exp(-75.0*diffvlp)
      hulp1=1.0/(1.0+exphu1)
      elph=vlp1(ity)*diffvlp*hulp1
*     elph=vlp1(ity)*diffvlp
      delpdvlp=-vlp1(ity)*hulp1-vlp1(ity)*diffvlp*hulp1*hulp1*
     $75.0*exphu1

      elp=elp+elph
      estrain(i1)=estrain(i1)+elph !atom energy

      delpdsbo=delpdvlp*dvlpdsbo(i1)
**********************************************************************
*                                                                    *
*     Calculate first derivative of lone pair energy to              *
*     cartesian coordinates                                          *
*                                                                    *
**********************************************************************
      do i3=1,ia(i1,2)
      iob=ia(i1,2+i3)
      ncubo=nubon2(i1,i3)

      if (Lvirial.eq.1) then
         do k1=1,3
         do k2=1,3
            virial_tmp(k1,k2) = 0.0
         end do
         end do
      endif

      do i4=1,idbo1(ncubo)
      ihu=idbo(ncubo,i4)
      do k1=1,3
      ftmp = delpdsbo*dbondc(ncubo,k1,i4)
      d(k1,ihu)=d(k1,ihu)+ftmp

      if (Lvirial.eq.1) then
         do k1p=1,3
            virial_tmp(k1,k1p)=virial_tmp(k1,k1p)+ftmp*c(ihu,k1p)
         end do
      endif

      end do
      end do
      if (Lvirial.eq.1) then
         virialsym(1) = virial_tmp(1,1)
         virialsym(2) = virial_tmp(2,2)
         virialsym(3) = virial_tmp(3,3)
         virialsym(4) = virial_tmp(1,2)
         virialsym(5) = virial_tmp(1,3)
         virialsym(6) = virial_tmp(2,3)
         do k1 = 1,6
            virial(k1) = virial(k1) + virialsym(k1)
         end do

         if (Latomvirial.eq.1) then
            frac = 1.0d0/idbo1(ncubo)
            do k1 = 1,6
               vtmp = virialsym(k1)*frac
               do i4=1,idbo1(ncubo)
                  ihu=idbo(ncubo,i4)
                  atomvirial(k1,ihu) = atomvirial(k1,ihu) + vtmp
               end do
            end do
         endif
      endif

      end do
      endif

      end do

      return
      end
********************************************************************** 
********************************************************************** 

      subroutine covbon

********************************************************************** 
#include "cbka.blk"
#include "cbkc.blk"
#include "cbkabo.blk"
#include "cbkbo.blk"
#include "cbkbosi.blk"
#include "cbkbopi.blk"
#include "cbkbopi2.blk"
#include "cbkconst.blk"
#include "cbkcovbon.blk"
#include "cbkd.blk"
#include "cbkdbopi2ndc.blk"
#include "cbkdbopindc.blk"
#include "cbkdcell.blk"
#include "cbkenergies.blk"
#include "cbkff.blk"
#include "cbkia.blk"
#include "cbkidbo.blk"
#include "cbknubon2.blk"
#include "cbkqa.blk"
#include "cbkrbo.blk"
#include "control.blk"
#include "small.blk"
      dimension virial_tmp(3,3),virialsym(6)
********************************************************************** 
*                                                                    *
*     Calculate bond energy and first derivatives                    *
*                                                                    *
********************************************************************** 
c$$$      if (ndebug.eq.1) then
c$$$C      open (65,file='fort.65',status='unknown',access='append')
c$$$      write (65,*) 'In covbon'
c$$$      call timer(65)
c$$$      close (65)
c$$$      end if
      eb=0.0d0
      if (nbon.eq.0) return
********************************************************************** 
*                                                                    *
*     Calculate bond energies                                        *
*                                                                    *
********************************************************************** 
c$$$      if (ndebug.eq.1) then
c$$$C      open (65,file='fort.65',status='unknown',access='append')
c$$$      write(65,*) 'Bond forces'
c$$$      write(65,*) 'nbon = ',nbon
c$$$      endif

      do 20 i1=1,nbon

      boa=bo(i1)
*     if (boa.lt.cutof2) goto 20
      j1=ib(i1,2)
      j2=ib(i1,3)

c     Only compute interaction if both atoms
c     are local or else flip a coin 
      if (j1 .gt. na_local) go to 20
      if (j2 .gt. na_local) then
         if (itag(j1) .lt. itag(j2)) go to 20
         if (itag(j1) .eq. itag(j2)) then
            if(c(j1,3) .gt. c(j2,3)) go to 20
            if(c(j1,3) .eq. c(j2,3) .and. 
     $           c(j1,2) .gt. c(j2,2)) go to 20
            if(c(j1,3) .eq. c(j2,3) .and. 
     $           c(j1,2) .eq. c(j2,2) .and. 
     $           c(j1,1) .gt. c(j2,1)) go to 20
         endif
      endif
      vsymm=1.0
      if (j1.eq.j2) vsymm=0.5

      bopia=bopi(i1)
      bopi2a=bopi2(i1)
      bosia=boa-bopia-bopi2a
      if (bosia.lt.zero) bosia=zero
      it1=ia(j1,1)
      it2=ia(j2,1)
      ibt=ib(i1,1)
      de1h=vsymm*de1(ibt)
      de2h=vsymm*de2(ibt)
      de3h=vsymm*de3(ibt)

      bopo1=bosia**psp(ibt)
      exphu1=exp(psi(ibt)*(1.0-bopo1))
      ebh=-de1h*bosia*exphu1-de2h*bopia-de3h*bopi2a

      debdbo=-de1h*exphu1+de1h*exphu1*psp(ibt)*psi(ibt)*bopo1
      debdbopi=-de2h
      debdbopi2=-de3h

      eb=eb+ebh
      estrain(j1)=estrain(j1)+0.50*ebh !1st atom energy
      estrain(j2)=estrain(j2)+0.50*ebh !2nd atom energy

      if (Lvirial.eq.1) then
         do k1=1,3
         do k2=1,3
            virial_tmp(k1,k2) = 0.0
         end do
         end do
      endif

      do i2=1,idbo1(i1)
      ihu=idbo(i1,i2)
      do k1=1,3
      ftmp = debdbo*(dbondc(i1,k1,i2)-dbopindc(i1,k1,i2)-
     $dbopi2ndc(i1,k1,i2))+
     $debdbopi*dbopindc(i1,k1,i2)+
     $debdbopi2*dbopi2ndc(i1,k1,i2)
      d(k1,ihu)=d(k1,ihu)+ftmp

      if (Lvirial.eq.1) then
      do k1p=1,3
      virial_tmp(k1,k1p)=virial_tmp(k1,k1p)+ftmp*c(ihu,k1p)
      end do
      endif

      end do
      end do
      if (Lvirial.eq.1) then
         virialsym(1) = virial_tmp(1,1)
         virialsym(2) = virial_tmp(2,2)
         virialsym(3) = virial_tmp(3,3)
         virialsym(4) = virial_tmp(1,2)
         virialsym(5) = virial_tmp(1,3)
         virialsym(6) = virial_tmp(2,3)
         do k1 = 1,6
            virial(k1) = virial(k1) + virialsym(k1)
         end do

         if (Latomvirial.eq.1) then
            frac = 1.0d0/idbo1(i1)
            do k1 = 1,6
               vtmp = virialsym(k1)*frac
               do i2=1,idbo1(i1)
                  ihu=idbo(i1,i2)
                  atomvirial(k1,ihu) = atomvirial(k1,ihu) + vtmp
               end do
            end do
         endif

      endif

**********************************************************************
*                                                                    *
*     Stabilisation terminal triple bond in CO                       *
*                                                                    *
**********************************************************************
      if (boa.lt.1.00) goto 20
* Stabilization for all triple bonds (not just for CO) in ReaxFF combustion FF
*      if ((qa(j1).eq.'C '.and.qa(j2).eq.'O ').or.
*     $(qa(j1).eq.'O '.and.qa(j2).eq.'C ')) then
      ba=(boa-2.50)*(boa-2.50)
      exphu=exp(-vpar(8)*ba)
      oboa=abo(j1)-boa
      obob=abo(j2)-boa
      exphua1=exp(-vpar(4)*oboa)
      exphub1=exp(-vpar(4)*obob)
      ovoab=abo(j1)-aval(it1)+abo(j2)-aval(it2)
      exphuov=exp(vpar(5)*ovoab)
      hulpov=1.0/(1.0+25.0*exphuov)
      
      estriph=vpar(11)*exphu*hulpov*(exphua1+exphub1)

      eb=eb+estriph
      estrain(j1)=estrain(j1)+0.50*estriph !1st atom energy
      estrain(j2)=estrain(j2)+0.50*estriph !2nd atom energy

      decobdbo=vpar(4)*vpar(11)*exphu*hulpov*(exphua1+exphub1)
     $-2.0*vpar(11)*vpar(8)*(boa-2.50)*hulpov*exphu*
     $(exphua1+exphub1)
      decobdboua=-25.0*vpar(5)*vpar(11)*exphu*exphuov*hulpov*hulpov*
     $(exphua1+exphub1)-vpar(11)*exphu*vpar(4)*hulpov*exphua1
      decobdboub=-25.0*vpar(5)*vpar(11)*exphu*exphuov*hulpov*hulpov*
     $(exphua1+exphub1)-vpar(11)*exphu*vpar(4)*hulpov*exphub1

      if (Lvirial.eq.1) then
         do k1=1,3
         do k2=1,3
            virial_tmp(k1,k2) = 0.0
         end do
         end do
      endif

      do i2=1,idbo1(i1)
      ihu=idbo(i1,i2)
      do k1=1,3
      ftmp = decobdbo*dbondc(i1,k1,i2)
      d(k1,ihu)=d(k1,ihu)+ftmp

      if (Lvirial.eq.1) then
      do k1p=1,3
      virial_tmp(k1,k1p)=virial_tmp(k1,k1p)+ftmp*c(ihu,k1p)
      end do
      endif

      end do
      end do
      if (Lvirial.eq.1) then
         virialsym(1) = virial_tmp(1,1)
         virialsym(2) = virial_tmp(2,2)
         virialsym(3) = virial_tmp(3,3)
         virialsym(4) = virial_tmp(1,2)
         virialsym(5) = virial_tmp(1,3)
         virialsym(6) = virial_tmp(2,3)
         do k1 = 1,6
            virial(k1) = virial(k1) + virialsym(k1)
         end do

         if (Latomvirial.eq.1) then
            frac = 1.0d0/idbo1(i1)
            do k1 = 1,6
               vtmp = virialsym(k1)*frac
               do i2=1,idbo1(i1)
                  ihu=idbo(i1,i2)
                  atomvirial(k1,ihu) = atomvirial(k1,ihu) + vtmp
               end do
            end do
         endif

      endif

      do i3=1,ia(j1,2)
      iob=ia(j1,2+i3)
      ncubo=nubon2(j1,i3)

      if (Lvirial.eq.1) then
         do k1=1,3
         do k2=1,3
            virial_tmp(k1,k2) = 0.0
         end do
         end do
      endif

      do i4=1,idbo1(ncubo)
      ihu=idbo(ncubo,i4)
      do k1=1,3
      ftmp = decobdboua*dbondc(ncubo,k1,i4)
      d(k1,ihu)=d(k1,ihu)+ftmp

      if (Lvirial.eq.1) then
      do k1p=1,3
      virial_tmp(k1,k1p)=virial_tmp(k1,k1p)+ftmp*c(ihu,k1p)
      end do
      endif

      end do
      end do
      if (Lvirial.eq.1) then
         virialsym(1) = virial_tmp(1,1)
         virialsym(2) = virial_tmp(2,2)
         virialsym(3) = virial_tmp(3,3)
         virialsym(4) = virial_tmp(1,2)
         virialsym(5) = virial_tmp(1,3)
         virialsym(6) = virial_tmp(2,3)
         do k1 = 1,6
            virial(k1) = virial(k1) + virialsym(k1)
         end do

         if (Latomvirial.eq.1) then
            frac = 1.0d0/idbo1(ncubo)
            do k1 = 1,6
               vtmp = virialsym(k1)*frac
               do i4=1,idbo1(ncubo)
                  ihu=idbo(ncubo,i4)
                  atomvirial(k1,ihu) = atomvirial(k1,ihu) + vtmp
               end do
            end do
         endif

      endif

      end do

      do i3=1,ia(j2,2)
      iob=ia(j2,2+i3)
      ncubo=nubon2(j2,i3)
      if (Lvirial.eq.1) then
         do k1=1,3
         do k2=1,3
            virial_tmp(k1,k2) = 0.0
         end do
         end do
      endif
      do i4=1,idbo1(ncubo)
      ihu=idbo(ncubo,i4)
      do k1=1,3
      ftmp = decobdboub*dbondc(ncubo,k1,i4)
      d(k1,ihu)=d(k1,ihu)+ftmp

      if (Lvirial.eq.1) then
      do k1p=1,3
      virial_tmp(k1,k1p)=virial_tmp(k1,k1p)+ftmp*c(ihu,k1p)
      end do
      endif

      end do
      end do
      if (Lvirial.eq.1) then
         virialsym(1) = virial_tmp(1,1)
         virialsym(2) = virial_tmp(2,2)
         virialsym(3) = virial_tmp(3,3)
         virialsym(4) = virial_tmp(1,2)
         virialsym(5) = virial_tmp(1,3)
         virialsym(6) = virial_tmp(2,3)
         do k1 = 1,6
            virial(k1) = virial(k1) + virialsym(k1)
         end do

         if (Latomvirial.eq.1) then
            frac = 1.0d0/idbo1(ncubo)
            do k1 = 1,6
               vtmp = virialsym(k1)*frac
               do i4=1,idbo1(ncubo)
                  ihu=idbo(ncubo,i4)
                  atomvirial(k1,ihu) = atomvirial(k1,ihu) + vtmp
               end do
            end do
         endif

      endif

      end do

*      endif

   20 continue

      return
      end
********************************************************************** 
********************************************************************** 

      subroutine ovcor

********************************************************************** 
#include "cbka.blk"
#include "cbkc.blk"
#include "cbkabo.blk"
#include "cbkbo.blk"
#include "cbkbopi.blk"
#include "cbkbopi2.blk"
#include "cbkconst.blk"
#include "cbkd.blk"
#include "cbkdbopi2ndc.blk"
#include "cbkdbopindc.blk"
#include "cbkdcell.blk"
#include "cbkenergies.blk"
#include "cbkff.blk"
#include "cbkia.blk"
#include "cbkidbo.blk"
#include "cbklonpar.blk"
#include "cbknubon2.blk"
#include "cbkrbo.blk"
#include "control.blk"
#include "small.blk"
********************************************************************** 
*                                                                    *
*     Calculate atom energy                                          *
*     Correction for over- and undercoordinated atoms                *
*                                                                    *
********************************************************************** 
      dimension vlptemp(nat)
      dimension virial_tmp(3,3),virialsym(6)
c$$$      if (ndebug.eq.1) then
c$$$C      open (65,file='fort.65',status='unknown',access='append')
c$$$      write (65,*) 'In ovcor'
c$$$      call timer(65)
c$$$      close (65)
c$$$      end if
      do i1=1,na
      ity1=ia(i1,1)
      vlptemp(i1)=vlp(i1)
      if (amas(ity1).gt.21.0) vlptemp(i1)=0.50*(stlp(ity1)-aval(ity1))  !Only for 1st-row elements
      end do
   25 ea=zero
      eaot=zero
      eaut=zero
      epen=0.0

      do 30 i1=1,na_local
      ity1=ia(i1,1)
      dfvl=1.0                         
      if (amas(ity1).gt.21.0) dfvl=0.0  !Only for 1st-row elements
********************************************************************** 
*                                                                    *
*     Calculate overcoordination energy                              *
*     Valency is corrected for lone pairs                            *
*                                                                    *
********************************************************************** 

      voptlp=0.50*(stlp(ity1)-aval(ity1))
      diffvlph=dfvl*(voptlp-vlptemp(i1))
********************************************************************** 
*                                                                    *
*     Determine coordination neighboring atoms                       *
*                                                                    *
********************************************************************** 
      sumov=0.0
      sumov2=0.0
      do i3=1,ia(i1,2)
      iat2=ia(i1,2+i3)
      ity2=ia(iat2,1)
      ncubo=nubon2(i1,i3)
      if (bo(ncubo).gt.0.0) then
      ibt=ib(ncubo,1)
      voptlp2=0.50*(stlp(ity2)-aval(ity2))
      diffvlp2=dfvl*(voptlp2-vlptemp(iat2))
      sumov=sumov+(bopi(ncubo)+bopi2(ncubo))*
     $(abo(iat2)-aval(ity2)-diffvlp2)
      sumov2=sumov2+vover(ibt)*de1(ibt)*bo(ncubo)
      endif
      end do

      exphu1=exp(vpar(32)*sumov)
      vho=1.0/(1.0+vpar(33)*exphu1)
      diffvlp=diffvlph*vho
      
      vov1=abo(i1)-aval(ity1)-diffvlp
      dvov1dsumov=diffvlph*vpar(32)*vpar(33)*vho*vho*exphu1
      exphuo=exp(vovun(ity1)*vov1)
      hulpo=1.0/(1.0+exphuo)

      hulpp=(1.0/(vov1+aval(ity1)+1e-8))

      eah=sumov2*hulpp*hulpo*vov1
      deadvov1=-sumov2*hulpp*hulpp*vov1*hulpo+
     $sumov2*hulpp*hulpo-sumov2*hulpp*vov1*vovun(ity1)*
     $hulpo*hulpo*exphuo

      ea=ea+eah
      estrain(i1)=estrain(i1)+eah !atom energy
********************************************************************** 
*                                                                    *
*     Calculate first derivative of overcoordination energy to       *
*     cartesian coordinates                                          *
*                                                                    *
********************************************************************** 
      do i3=1,ia(i1,2)
      iob=ia(i1,2+i3)
      ncubo=nubon2(i1,i3)
      if (bo(ncubo).gt.0.0) then
      ibt=ib(ncubo,1)
      deadbo=vover(ibt)*de1(ibt)*hulpp*hulpo*vov1

      if (Lvirial.eq.1) then
         do k1=1,3
         do k2=1,3
            virial_tmp(k1,k2) = 0.0
         end do
         end do
      endif

      do i4=1,idbo1(ncubo)
      ihu=idbo(ncubo,i4)
      do k1=1,3
      ftmp = deadvov1*(1.0+dfvl*vho*dvlpdsbo(i1))*
     $dbondc(ncubo,k1,i4)+deadbo*dbondc(ncubo,k1,i4)
      d(k1,ihu)=d(k1,ihu)+ftmp

      if (Lvirial.eq.1) then
      do k1p=1,3
      virial_tmp(k1,k1p)=virial_tmp(k1,k1p)+ftmp*c(ihu,k1p)
      end do
      endif

      end do
      end do
      if (Lvirial.eq.1) then
         virialsym(1) = virial_tmp(1,1)
         virialsym(2) = virial_tmp(2,2)
         virialsym(3) = virial_tmp(3,3)
         virialsym(4) = virial_tmp(1,2)
         virialsym(5) = virial_tmp(1,3)
         virialsym(6) = virial_tmp(2,3)
         do k1 = 1,6
            virial(k1) = virial(k1) + virialsym(k1)
         end do

         if (Latomvirial.eq.1) then
            frac = 1.0d0/idbo1(ncubo)
            do k1 = 1,6
               vtmp = virialsym(k1)*frac
               do i4=1,idbo1(ncubo)
                  ihu=idbo(ncubo,i4)
                  atomvirial(k1,ihu) = atomvirial(k1,ihu) + vtmp
               end do
            end do
         endif

      endif

      endif
      end do
 
      do i2=1,ia(i1,2)
 
      iat2=ia(i1,2+i2)
      ity2=ia(iat2,1)
      nbosa=nubon2(i1,i2)
      if (bo(nbosa).gt.0.0) then
      deadvov2=deadvov1*dvov1dsumov*(bopi(nbosa)+bopi2(nbosa))
 
      voptlp2=0.50*(stlp(ity2)-aval(ity2))
      diffvlp2=dfvl*(voptlp2-vlptemp(iat2))
      deadpibo=deadvov1*dvov1dsumov*(abo(iat2)-aval(ity2)-diffvlp2)
 
      if (Lvirial.eq.1) then
         do k1=1,3
         do k2=1,3
            virial_tmp(k1,k2) = 0.0
         end do
         end do
      endif

      do i4=1,idbo1(nbosa)
      ihu=idbo(nbosa,i4)
      do k1=1,3
      ftmp = deadpibo*(dbopindc(nbosa,k1,i4)+
     $dbopi2ndc(nbosa,k1,i4))
      d(k1,ihu)=d(k1,ihu)+ftmp

      if (Lvirial.eq.1) then
      do k1p=1,3
      virial_tmp(k1,k1p)=virial_tmp(k1,k1p)+ftmp*c(ihu,k1p)
      end do
      endif

      end do
      end do
      if (Lvirial.eq.1) then
         virialsym(1) = virial_tmp(1,1)
         virialsym(2) = virial_tmp(2,2)
         virialsym(3) = virial_tmp(3,3)
         virialsym(4) = virial_tmp(1,2)
         virialsym(5) = virial_tmp(1,3)
         virialsym(6) = virial_tmp(2,3)
         do k1 = 1,6
            virial(k1) = virial(k1) + virialsym(k1)
         end do

         if (Latomvirial.eq.1) then
            frac = 1.0d0/idbo1(nbosa)
            do k1 = 1,6
               vtmp = virialsym(k1)*frac
               do i4=1,idbo1(nbosa)
                  ihu=idbo(nbosa,i4)
                  atomvirial(k1,ihu) = atomvirial(k1,ihu) + vtmp
               end do
            end do
         endif
      endif
 
      do i3=1,ia(iat2,2)
      iob=ia(iat2,2+i3)
      ncubo=nubon2(iat2,i3)
      if (bo(ncubo).gt.0.0) then

      if (Lvirial.eq.1) then
         do k1=1,3
         do k2=1,3
            virial_tmp(k1,k2) = 0.0
         end do
         end do
      endif

      do i4=1,idbo1(ncubo)
      ihu=idbo(ncubo,i4)
      do k1=1,3
      ftmp = deadvov2*(1.0+dfvl*dvlpdsbo(iat2))*
     $dbondc(ncubo,k1,i4)
      d(k1,ihu)=d(k1,ihu)+ftmp
 
      if (Lvirial.eq.1) then
      do k1p=1,3
      virial_tmp(k1,k1p)=virial_tmp(k1,k1p)+ftmp*c(ihu,k1p)
      end do
      endif

      end do
      end do
      if (Lvirial.eq.1) then
         virialsym(1) = virial_tmp(1,1)
         virialsym(2) = virial_tmp(2,2)
         virialsym(3) = virial_tmp(3,3)
         virialsym(4) = virial_tmp(1,2)
         virialsym(5) = virial_tmp(1,3)
         virialsym(6) = virial_tmp(2,3)
         do k1 = 1,6
            virial(k1) = virial(k1) + virialsym(k1)
         end do

         if (Latomvirial.eq.1) then
            frac = 1.0d0/idbo1(ncubo)
            do k1 = 1,6
               vtmp = virialsym(k1)*frac
               do i4=1,idbo1(ncubo)
                  ihu=idbo(ncubo,i4)
                  atomvirial(k1,ihu) = atomvirial(k1,ihu) + vtmp
               end do
            end do
         endif

      endif

      endif
      end do

      endif

      end do

********************************************************************** 
*                                                                    *
*     Calculate undercoordination energy                             *
*                                                                    *
********************************************************************** 
      if (valp1(ity1).lt.zero) goto 30  !skip undercoordination
      exphu2=exp(vpar(10)*sumov)
      vuhu1=1.0+vpar(9)*exphu2
      hulpu2=1.0/vuhu1

      exphu3=-exp(vpar(7)*vov1)
      hulpu3=-(1.0+exphu3)

      dise2=valp1(ity1)
      exphuu=exp(-vovun(ity1)*vov1)
      hulpu=1.0/(1.0+exphuu)
      eahu=dise2*hulpu*hulpu2*hulpu3
      deaudvov1=dise2*hulpu2*vovun(ity1)*hulpu*hulpu*exphuu*hulpu3-
     $dise2*hulpu*hulpu2*vpar(7)*exphu3

      ea=ea+eahu
      estrain(i1)=estrain(i1)+eahu !atom energy

      deaudsumov=-dise2*hulpu*vpar(9)*vpar(10)*hulpu3*exphu2*
     $hulpu2*hulpu2

********************************************************************** 
*                                                                    *
*     Calculate first derivative of atom energy to cartesian         *
*     coordinates                                                    *
*                                                                    *
********************************************************************** 

      do i3=1,ia(i1,2)
      iob=ia(i1,2+i3)
      ncubo=nubon2(i1,i3)
      if (bo(ncubo).gt.0.0) then

      if (Lvirial.eq.1) then
         do k1=1,3
         do k2=1,3
            virial_tmp(k1,k2) = 0.0
         end do
         end do
      endif

      do i4=1,idbo1(ncubo)
      ihu=idbo(ncubo,i4)
      do k1=1,3
      ftmp = deaudvov1*(1.0+dfvl*vho*dvlpdsbo(i1))*
     $dbondc(ncubo,k1,i4)
      d(k1,ihu)=d(k1,ihu)+ftmp

      if (Lvirial.eq.1) then
      do k1p=1,3
      virial_tmp(k1,k1p)=virial_tmp(k1,k1p)+ftmp*c(ihu,k1p)
      end do
      endif

      end do
      end do
      if (Lvirial.eq.1) then
         virialsym(1) = virial_tmp(1,1)
         virialsym(2) = virial_tmp(2,2)
         virialsym(3) = virial_tmp(3,3)
         virialsym(4) = virial_tmp(1,2)
         virialsym(5) = virial_tmp(1,3)
         virialsym(6) = virial_tmp(2,3)
         do k1 = 1,6
            virial(k1) = virial(k1) + virialsym(k1)
         end do

         if (Latomvirial.eq.1) then
            frac = 1.0d0/idbo1(ncubo)
            do k1 = 1,6
               vtmp = virialsym(k1)*frac
               do i4=1,idbo1(ncubo)
                  ihu=idbo(ncubo,i4)
                  atomvirial(k1,ihu) = atomvirial(k1,ihu) + vtmp
               end do
            end do
         endif

      endif

      endif
      end do
 
      do i2=1,ia(i1,2)
 
      iat2=ia(i1,2+i2)
      ity2=ia(iat2,1)
      nbosa=nubon2(i1,i2)
      if (bo(nbosa).gt.0.0) then
      deadvov2=(deaudsumov+dvov1dsumov*deaudvov1)*
     $(bopi(nbosa)+bopi2(nbosa))
 
      voptlp2=0.50*(stlp(ity2)-aval(ity2))
      diffvlp2=dfvl*(voptlp2-vlptemp(iat2))
      deadpibo1=(dvov1dsumov*deaudvov1+deaudsumov)*
     $(abo(iat2)-aval(ity2)-diffvlp2)
 
      if (Lvirial.eq.1) then
         do k1=1,3
         do k2=1,3
            virial_tmp(k1,k2) = 0.0
         end do
         end do
      endif

      do i4=1,idbo1(nbosa)
      ihu=idbo(nbosa,i4)
      do k1=1,3
      ftmp = deadpibo1*
     $(dbopindc(nbosa,k1,i4)+dbopi2ndc(nbosa,k1,i4))
      d(k1,ihu)=d(k1,ihu)+ftmp

      if (Lvirial.eq.1) then
      do k1p=1,3
      virial_tmp(k1,k1p)=virial_tmp(k1,k1p)+ftmp*c(ihu,k1p)
      end do
      endif

      end do
      end do
      if (Lvirial.eq.1) then
         virialsym(1) = virial_tmp(1,1)
         virialsym(2) = virial_tmp(2,2)
         virialsym(3) = virial_tmp(3,3)
         virialsym(4) = virial_tmp(1,2)
         virialsym(5) = virial_tmp(1,3)
         virialsym(6) = virial_tmp(2,3)
         do k1 = 1,6
            virial(k1) = virial(k1) + virialsym(k1)
         end do

         if (Latomvirial.eq.1) then
            frac = 1.0d0/idbo1(nbosa)
            do k1 = 1,6
               vtmp = virialsym(k1)*frac
               do i4=1,idbo1(nbosa)
                  ihu=idbo(nbosa,i4)
                  atomvirial(k1,ihu) = atomvirial(k1,ihu) + vtmp
               end do
            end do
         endif

      endif

      do i3=1,ia(iat2,2)
      iob=ia(iat2,2+i3)
      ncubo=nubon2(iat2,i3)
      if (bo(ncubo).gt.0.0) then

      if (Lvirial.eq.1) then
         do k1=1,3
         do k2=1,3
            virial_tmp(k1,k2) = 0.0
         end do
         end do
      endif

      do i4=1,idbo1(ncubo)
      ihu=idbo(ncubo,i4)
      do k1=1,3
      ftmp = deadvov2*(1.0+dfvl*dvlpdsbo(iat2))*
     $dbondc(ncubo,k1,i4)
      d(k1,ihu)=d(k1,ihu)+ftmp

      if (Lvirial.eq.1) then
      do k1p=1,3
      virial_tmp(k1,k1p)=virial_tmp(k1,k1p)+ftmp*c(ihu,k1p)
      end do
      endif

      end do
      end do
      if (Lvirial.eq.1) then
         virialsym(1) = virial_tmp(1,1)
         virialsym(2) = virial_tmp(2,2)
         virialsym(3) = virial_tmp(3,3)
         virialsym(4) = virial_tmp(1,2)
         virialsym(5) = virial_tmp(1,3)
         virialsym(6) = virial_tmp(2,3)
         do k1 = 1,6
            virial(k1) = virial(k1) + virialsym(k1)
         end do

         if (Latomvirial.eq.1) then
            frac = 1.0d0/idbo1(ncubo)
            do k1 = 1,6
               vtmp = virialsym(k1)*frac
               do i4=1,idbo1(ncubo)
                  ihu=idbo(ncubo,i4)
                  atomvirial(k1,ihu) = atomvirial(k1,ihu) + vtmp
               end do
            end do
         endif

      endif

      endif
      end do
 
      endif

      end do


   30 continue
 
**********************************************************************
*                                                                    *
*     Calculate correction for C2                                    *
*                                                                    *
**********************************************************************
      if (abs(vpar(6)).gt.0.001) then
      do 40 i1=1,na_local
      ity1=ia(i1,1)
      vov4=abo(i1)-aval(ity1)
 
      do i2=1,ia(i1,2)
      iat2=ia(i1,2+i2)
      nbohu=nubon2(i1,i2)
      if (bo(nbohu).gt.0.0) then
 
      ibt=ib(nbohu,1)
      elph=zero
      deahu2dbo=zero
      deahu2dsbo=zero
      vov3=bo(nbohu)-vov4-0.040*(vov4**4)
      if (vov3.gt.3.0) then
      elph=vpar(6)*(vov3-3.0)*(vov3-3.0)
      deahu2dbo=2.0*vpar(6)*(vov3-3.0)
      deahu2dsbo=2.0*vpar(6)*(vov3-3.0)*(-1.0-
     $0.16*(vov4**3))
      end if
 
      elp=elp+elph
      estrain(i1)=estrain(i1)+elph !atom energy

      if (Lvirial.eq.1) then
         do k1=1,3
         do k2=1,3
            virial_tmp(k1,k2) = 0.0
         end do
         end do
      endif

      do i3=1,idbo1(nbohu)
      ihu=idbo(nbohu,i3)
      do k1=1,3
      ftmp = deahu2dbo*dbondc(nbohu,k1,i3)
      d(k1,ihu)=d(k1,ihu)+ftmp

      if (Lvirial.eq.1) then
      do k1p=1,3
      virial_tmp(k1,k1p)=virial_tmp(k1,k1p)+ftmp*c(ihu,k1p)
      end do
      endif

      end do
      end do
      if (Lvirial.eq.1) then
         virialsym(1) = virial_tmp(1,1)
         virialsym(2) = virial_tmp(2,2)
         virialsym(3) = virial_tmp(3,3)
         virialsym(4) = virial_tmp(1,2)
         virialsym(5) = virial_tmp(1,3)
         virialsym(6) = virial_tmp(2,3)
         do k1 = 1,6
            virial(k1) = virial(k1) + virialsym(k1)
         end do

         if (Latomvirial.eq.1) then
            frac = 1.0d0/idbo1(nbohu)
            do k1 = 1,6
               vtmp = virialsym(k1)*frac
               do i3=1,idbo1(nbohu)
                  ihu=idbo(nbohu,i3)
                  atomvirial(k1,ihu) = atomvirial(k1,ihu) + vtmp
               end do
            end do
         endif

      endif

      do i3=1,ia(i1,2)
      iob=ia(i1,2+i3)
      ncubo=nubon2(i1,i3)
      if (bo(ncubo).gt.0.0) then

      if (Lvirial.eq.1) then
         do k1=1,3
         do k2=1,3
            virial_tmp(k1,k2) = 0.0
         end do
         end do
      endif

      do i4=1,idbo1(ncubo)
      ihu=idbo(ncubo,i4)
      do k1=1,3
      ftmp = deahu2dsbo*dbondc(ncubo,k1,i4)
      d(k1,ihu)=d(k1,ihu)+ftmp

      if (Lvirial.eq.1) then
      do k1p=1,3
      virial_tmp(k1,k1p)=virial_tmp(k1,k1p)+ftmp*c(ihu,k1p)
      end do
      endif

      end do
      end do
      if (Lvirial.eq.1) then
         virialsym(1) = virial_tmp(1,1)
         virialsym(2) = virial_tmp(2,2)
         virialsym(3) = virial_tmp(3,3)
         virialsym(4) = virial_tmp(1,2)
         virialsym(5) = virial_tmp(1,3)
         virialsym(6) = virial_tmp(2,3)
         do k1 = 1,6
            virial(k1) = virial(k1) + virialsym(k1)
         end do

         if (Latomvirial.eq.1) then
            frac = 1.0d0/idbo1(ncubo)
            do k1 = 1,6
               vtmp = virialsym(k1)*frac
               do i4=1,idbo1(ncubo)
                  ihu=idbo(ncubo,i4)
                  atomvirial(k1,ihu) = atomvirial(k1,ihu) + vtmp
               end do
            end do
         endif

      endif

      end if
      end do

      end if
      end do
 
   40 continue
      end if

      return
      end
**********************************************************************
********************************************************************** 

      subroutine molen

********************************************************************** 
#include "cbka.blk"
#include "cbkbo.blk"
#include "cbkconst.blk"
#include "cbkc.blk"
#include "cbkd.blk"
#include "cbkenergies.blk"
#include "cbkff.blk"
#include "cbkia.blk"
#include "cbkidbo.blk"
#include "cbknmolat.blk"
#include "cbknubon2.blk"
#include "control.blk"
#include "small.blk"
      dimension virial_tmp(3,3),virialsym(6)
********************************************************************** 
*                                                                    *
*     Calculate molecular energy and first derivatives               *
*     Only used to prevent creating virtual electrons                *
*                                                                    *
********************************************************************** 
c$$$      if (ndebug.eq.1) then
c$$$C      open (65,file='fort.65',status='unknown',access='append')
c$$$      write (65,*) 'In molen'
c$$$      call timer(65)
c$$$      close (65)
c$$$      end if
      emol=zero
      return
      do i1=1,nmolo

      enelm=0.0
      do i2=1,na
      if (ia(i2,3+mbond).eq.i1) then
      it1=ia(i2,1)
      enelm=enelm+aval(it1)
      end if
      end do

      na1m=nmolat(i1,1)

      enelm=2*int(enelm*0.50)
*     enelm=elmol(i1)
      bomsum=zero
      do i2=1,na1m
      ihu=nmolat(i1,i2+1)
      do i3=1,ia(ihu,2)
      ihu2=nubon2(ihu,i3)
      bomsum=bomsum+bo(ihu2)
      end do
      end do
      diff=(bomsum-enelm)
      exphu=exp(-vpar(37)*diff)
      exphu2=1.0/(1.0+15.0*exphu)
      emolh=zero
      demoldsbo=zero
      emolh=vpar(38)*exphu2
      emol=emol+emolh
      demoldsbo=vpar(38)*vpar(37)*15.0*exphu2*exphu2*exphu

      do i2=1,na1m
      ihu1=nmolat(i1,i2+1)
      do i3=1,ia(ihu1,2)
      iob=ia(ihu1,2+i3)
      ncubo=nubon2(ihu1,i3)

      if (Lvirial.eq.1) then
         do k1=1,3
         do k2=1,3
            virial_tmp(k1,k2) = 0.0
         end do
         end do
      endif

      do i4=1,idbo1(ncubo)
      ihu=idbo(ncubo,i4)
      do k1=1,3
      ftmp = demoldsbo*dbondc(ncubo,k1,i4)
      d(k1,ihu)=d(k1,ihu)+ftmp

      if (Lvirial.eq.1) then
      do k1p=1,3
      virial_tmp(k1,k1p)=virial_tmp(k1,k1p)+ftmp*c(ihu,k1p)
      end do
      endif

      end do
      end do
      if (Lvirial.eq.1) then
         virialsym(1) = virial_tmp(1,1)
         virialsym(2) = virial_tmp(2,2)
         virialsym(3) = virial_tmp(3,3)
         virialsym(4) = virial_tmp(1,2)
         virialsym(5) = virial_tmp(1,3)
         virialsym(6) = virial_tmp(2,3)
         do k1 = 1,6
            virial(k1) = virial(k1) + virialsym(k1)
         end do

         if (Latomvirial.eq.1) then
            frac = 1.0d0/idbo1(ncubo)
            do k1 = 1,6
               vtmp = virialsym(k1)*frac
               do i4=1,idbo1(ncubo)
                  ihu=idbo(ncubo,i4)
                  atomvirial(k1,ihu) = atomvirial(k1,ihu) + vtmp
               end do
            end do
         endif

      endif

      end do
      end do


      end do


      return
      end
********************************************************************** 
********************************************************************** 

      subroutine valang

********************************************************************** 
#include "cbka.blk"
#include "cbkabo.blk"
#include "cbkbo.blk"
#include "cbkbopi.blk"
#include "cbkbopi2.blk"
#include "cbkconst.blk"
#include "cbkc.blk"
#include "cbkd.blk"
#include "cbkdbopi2ndc.blk"
#include "cbkdbopindc.blk"
#include "cbkdcell.blk"
#include "cbkdhdc.blk"
#include "cbkenergies.blk"
#include "cbkff.blk"
#include "cbkh.blk"
#include "cbkia.blk"
#include "cbkidbo.blk"
#include "cbklonpar.blk"
#include "cbknubon2.blk"
#include "cbkvalence.blk"
#include "control.blk"
#include "valang.blk"
#include "small.blk"
      dimension j(3)
      dimension virial_tmp(3,3),virialsym(6)
********************************************************************** 
*                                                                    *
*     Calculate valency angle energies and first derivatives         *
*                                                                    *
********************************************************************** 
c$$$      if (ndebug.eq.1) then
c$$$C      open (65,file='fort.65',status='unknown',access='append')
c$$$      write (65,*) 'In valang'
c$$$      call timer(65)
c$$$      close (65)
c$$$      end if
*     eco=0.0
      ev=0.0
      ecoa=0.0
      if (nval.eq.0) return

      do 10 i1=1,nval
      ity=iv(i1,1)
      j(1)=iv(i1,2)
      j(2)=iv(i1,3)
      j(3)=iv(i1,4)

      if (j(2) .le. na_local) then

      la=iv(i1,5)
      lb=iv(i1,6)
      boa=bo(la)-cutof2
      bob=bo(lb)-cutof2
      if (boa.lt.zero.or.bob.lt.zero) goto 10

      hl=h(i1)     ! Calculated earlier in routine calval
********************************************************************** 
*                                                                    *
*     Calculate valency angle energy                                 *
*                                                                    *
********************************************************************** 
      nbocen=ia(j(2),2)
      sbo2=0.0
      vmbo=1.0
     
      do i2=1,nbocen
      ibv=nubon2(j(2),i2)
      if (bo(ibv).gt.0.0) then
      vmbo=vmbo*exp(-bo(ibv)**8)
      sbo2=sbo2+bopi(ibv)+bopi2(ibv)
      endif
      end do

      ity2=ia(j(2),1)
*     exbo=abo(j(2))-stlp(ia(j(2),1))
      exbo=abo(j(2))-valf(ity2)
*     if (exbo.gt.zero) exbo=zero
*     expov=exp(vka8(ity)*exbo)
*     expov2=exp(-vpar(13)*exbo)
*     htov1=2.0+expov2
*     htov2=1.0+expov+expov2
*     evboadj=htov1/htov2
      evboadj=1.0
      expun=exp(-vkac(ity)*exbo)
      expun2=exp(vpar(15)*exbo)
      htun1=2.0+expun2
      htun2=1.0+expun+expun2
      evboadj2=vval4(ity2)-(vval4(ity2)-1.0)*htun1/htun2
********************************************************************** 
*                                                                    *
*     Calculate number of lone pairs                                 *
*                                                                    *
********************************************************************** 
      dsbo2dvlp=(1.0-vmbo)
      vlpadj=zero
      exlp1=abo(j(2))-stlp(ia(j(2),1))
      exlp2=2.0*int(exlp1/2.0)
      exlp=exlp1-exlp2
      if (exlp.lt.zero) then
*     expvlp=exp(-vpar(16)*(2.0+exlp)*(2.0+exlp))
*     vlpadj=expvlp-int(exlp1/2.0)
*     dsbo2dvlp=(1.0-vmbo)*(1.0-vpar(34)*2.0*
*     $(2.0+exlp)*vpar(16)*expvlp)
      vlpadj=vlp(j(2))
      dsbo2dvlp=(1.0-vmbo)*(1.0+vpar(34)*dvlpdsbo(j(2)))
      end if

      sbo2=sbo2+(1.0-vmbo)*(-exbo-vpar(34)*vlpadj)
      dsbo2dvmbo=exbo+vpar(34)*vlpadj

      sbo2h=sbo2
      powv=vpar(17)
      if (sbo2.le.0.0) sbo2h=0.0
      if (sbo2.gt.0.0.and.sbo2.le.1.0) sbo2h=sbo2**powv
      if (sbo2.gt.1.0.and.sbo2.lt.2.0) sbo2h=2.0-(2.0-sbo2)**powv
      if (sbo2.gt.2.0) sbo2h=2.0
      thba=th0(ity)
      expsbo=exp(-vpar(18)*(2.0-sbo2h))
      thetao=180.0-thba*(1.0-expsbo)

      thetao=thetao*dgrrdn
      thdif=(thetao-hl)
      thdi2=thdif*thdif
      dthsbo=dgrrdn*thba*vpar(18)*expsbo
      if (sbo2.lt.0.0) dthsbo=zero
      if (sbo2.gt.0.0.and.sbo2.le.1.0) 
     $dthsbo=powv*(sbo2**(powv-1.0))*dgrrdn*thba*vpar(18)*expsbo
      if (sbo2.gt.1.0.and.sbo2.lt.2.0) 
     $dthsbo=powv*((2.0-sbo2)**(powv-1.0))*dgrrdn*thba*vpar(18)*expsbo
      if (sbo2.gt.2.0) dthsbo=zero

      exphu=vka(ity)*exp(-vka3(ity)*thdi2)
      exphu2=vka(ity)-exphu
      if (vka(ity).lt.zero) exphu2=exphu2-vka(ity)             !To avoid linear Me-H-Me angles (6/6/06)
      boap=boa**vval2(ity)
      boap2=boa**(vval2(ity)-1.0)
      bobp=bob**vval2(ity)
      bobp2=bob**(vval2(ity)-1.0)
      exa=exp(-vval1(ity2)*boap)
      exb=exp(-vval1(ity2)*bobp)
      dexadboa=vval2(ity)*vval1(ity2)*exa*boap2
      dexbdbob=vval2(ity)*vval1(ity2)*exb*bobp2
      exa2=(1.0-exa)
      exb2=(1.0-exb)

      evh=evboadj2*evboadj*exa2*exb2*exphu2
      devdlb=evboadj2*evboadj*dexbdbob*exa2*exphu2
      devdla=evboadj2*evboadj*dexadboa*exb2*exphu2
      devdsbo=2.0*evboadj2*evboadj*dthsbo*exa2*exb2*
     $vka3(ity)*thdif*exphu
      devdh=-2.0*evboadj2*evboadj*exa2*exb2*vka3(ity)*thdif*exphu

      devdsbo2=
     $evboadj*exa2*exb2*exphu2*(vval4(ity2)-1.0)*(-vpar(15)*expun2/htun2
     $+htun1*(vpar(15)*expun2-vkac(ity)*expun)/(htun2*htun2))

*     devdsbo2=-evboadj2*exa2*exb2*exphu2*(vpar(13)*expov2/htov2+
*    $htov1*(vka8(ity)*expov-vpar(13)*expov2)/(htov2*htov2))+
*    $evboadj*exa2*exb2*exphu2*(vpar(14)-1.0)*(-vpar(15)*expun2/htun2
*    $+htun1*(vpar(15)*expun2-vkac(ity)*expun)/(htun2*htun2))

      if (j(2) .le. na_local) then
         ev=ev+evh
         estrain(j(2))=estrain(j(2))+evh         !central atom energy
      endif

*     write (64,'(4i8,18f8.2)')mdstep,j(1),j(2),j(3),sbo2,sbo2h,
*    $thetao*rdndgr,hl*rdndgr,bo(la),bo(lb),bopi(la),
*    $vlp(j(2)),exbo,vlpadj,vmbo,evh,ev,vka(ity)
********************************************************************** 
*                                                                    *
*     Calculate penalty for two double bonds in valency angle        *
*                                                                    *
********************************************************************** 
      exbo=abo(j(2))-aval(ia(j(2),1))
      expov=exp(vpar(22)*exbo)
      expov2=exp(-vpar(21)*exbo)
      htov1=2.0+expov2
      htov2=1.0+expov+expov2
      ecsboadj=htov1/htov2
      exphu1=exp(-vpar(20)*(boa-2.0)*(boa-2.0))
      exphu2=exp(-vpar(20)*(bob-2.0)*(bob-2.0))

      epenh=vkap(ity)*ecsboadj*exphu1*exphu2
      estrain(j(2))=estrain(j(2))+epenh
      epen=epen+epenh
      decoadboa=-2.0*vpar(20)*epenh*(boa-2.0)
      decoadbob=-2.0*vpar(20)*epenh*(bob-2.0)

      decdsbo2=-vkap(ity)*exphu1*exphu2*(vpar(21)*expov2/htov2+htov1*
     $(vpar(22)*expov-vpar(21)*expov2)/(htov2*htov2))
**********************************************************************
*                                                                    *
*     Calculate valency angle conjugation energy                     *
*                                                                    *
**********************************************************************
      unda=abo(j(1))-boa
*     ovb=abo(j(2))-valf(ia(j(2),1))
      ovb=abo(j(2))-vval3(ia(j(2),1))    !Modification for Ru  7/6/2004

      undc=abo(j(3))-bob
      ba=(boa-1.50)*(boa-1.50)
      bb=(bob-1.50)*(bob-1.50)
      exphua=exp(-vpar(31)*ba)
      exphub=exp(-vpar(31)*bb)
      exphuua=exp(-vpar(39)*unda*unda)
      exphuob=exp(vpar(3)*ovb)
      exphuuc=exp(-vpar(39)*undc*undc)
      hulpob=1.0/(1.0+exphuob)
      ecoah=vka8(ity)*exphua*exphub*exphuua*exphuuc*hulpob
      decodbola=-2.0*vka8(ity)*(boa-1.50)*vpar(31)*exphua*exphub
     $*exphuua*exphuuc*hulpob+vpar(39)*vka8(ity)*exphua*exphub*
     $exphuua*exphuuc*hulpob*2.0*unda
      decodbolb=-2.0*vka8(ity)*(bob-1.50)*vpar(31)*exphua*exphub
     $*exphuua*exphuuc*hulpob+vpar(39)*vka8(ity)*exphua*exphub*
     $exphuua*exphuuc*hulpob*2.0*undc
      decodboua=-2.0*unda*vka8(ity)*vpar(39)*exphua*exphub
     $*exphuua*exphuuc*hulpob
      decodbouc=-2.0*undc*vka8(ity)*vpar(39)*exphua*exphub
     $*exphuua*exphuuc*hulpob
      decodboob=-vka8(ity)*exphua*exphub*exphuua*exphuuc*hulpob*
     $hulpob*vpar(3)*exphuob
*     decodboob=zero
*     decodboua=zero
*     decodbouc=zero

      ecoa=ecoa+ecoah
      estrain(j(2))=estrain(j(2))+ecoah !central atom energy

********************************************************************** 
*                                                                    *
*     Calculate derivative valency energy to cartesian coordinates   *
*                                                                    *
********************************************************************** 
      if (Lvirial.eq.1) then
         do k1=1,3
         do k2=1,3
            virial_tmp(k1,k2) = 0.0
         end do
         end do
      endif

      do k1=1,3
      do k2=1,3
      ftmp = devdh*dhdc(i1,k1,k2)
      d(k1,j(k2))=d(k1,j(k2))+ftmp

      if (Lvirial.eq.1) then
      do k1p=1,3
      virial_tmp(k1,k1p)=virial_tmp(k1,k1p)+ftmp*c(j(k2),k1p)
      end do
      endif

      end do
      end do
      if (Lvirial.eq.1) then
         virialsym(1) = virial_tmp(1,1)
         virialsym(2) = virial_tmp(2,2)
         virialsym(3) = virial_tmp(3,3)
         virialsym(4) = virial_tmp(1,2)
         virialsym(5) = virial_tmp(1,3)
         virialsym(6) = virial_tmp(2,3)
         do k1 = 1,6
            virial(k1) = virial(k1) + virialsym(k1)
         end do

         if (Latomvirial.eq.1) then
            frac = 1.0d0/3
            do k1 = 1,6
               vtmp = virialsym(k1)*frac
               do k2=1,3
                  ihu=j(k2)
                  atomvirial(k1,ihu) = atomvirial(k1,ihu) + vtmp
               end do
            end do
         endif

      endif

      if (Lvirial.eq.1) then
         do k1=1,3
         do k2=1,3
            virial_tmp(k1,k2) = 0.0
         end do
         end do
      endif

      do i2=1,idbo1(la)
      ihu=idbo(la,i2)
      do k1=1,3
      ftmp = (devdla+decoadboa+decodbola)*
     $dbondc(la,k1,i2)
      d(k1,ihu)=d(k1,ihu)+ftmp

      if (Lvirial.eq.1) then
      do k1p=1,3
      virial_tmp(k1,k1p)=virial_tmp(k1,k1p)+ftmp*c(ihu,k1p)
      end do
      endif

      end do
      end do
      if (Lvirial.eq.1) then
         virialsym(1) = virial_tmp(1,1)
         virialsym(2) = virial_tmp(2,2)
         virialsym(3) = virial_tmp(3,3)
         virialsym(4) = virial_tmp(1,2)
         virialsym(5) = virial_tmp(1,3)
         virialsym(6) = virial_tmp(2,3)
         do k1 = 1,6
            virial(k1) = virial(k1) + virialsym(k1)
         end do

         if (Latomvirial.eq.1) then
            frac = 1.0d0/idbo1(la)
            do k1 = 1,6
               vtmp = virialsym(k1)*frac
               do i2=1,idbo1(la)
                  ihu=idbo(la,i2)
                  atomvirial(k1,ihu) = atomvirial(k1,ihu) + vtmp
               end do
            end do
         endif

      endif

      if (Lvirial.eq.1) then
         do k1=1,3
         do k2=1,3
            virial_tmp(k1,k2) = 0.0
         end do
         end do
      endif

      do i2=1,idbo1(lb)
      ihu=idbo(lb,i2)
      do k1=1,3
      ftmp = (devdlb+decoadbob+decodbolb)*
     $dbondc(lb,k1,i2)
      d(k1,ihu)=d(k1,ihu)+ftmp

      if (Lvirial.eq.1) then
      do k1p=1,3
      virial_tmp(k1,k1p)=virial_tmp(k1,k1p)+ftmp*c(ihu,k1p)
      end do
      endif

      end do
      end do
      if (Lvirial.eq.1) then
         virialsym(1) = virial_tmp(1,1)
         virialsym(2) = virial_tmp(2,2)
         virialsym(3) = virial_tmp(3,3)
         virialsym(4) = virial_tmp(1,2)
         virialsym(5) = virial_tmp(1,3)
         virialsym(6) = virial_tmp(2,3)
         do k1 = 1,6
            virial(k1) = virial(k1) + virialsym(k1)
         end do

         if (Latomvirial.eq.1) then
            frac = 1.0d0/idbo1(lb)
            do k1 = 1,6
               vtmp = virialsym(k1)*frac
               do i2=1,idbo1(lb)
                  ihu=idbo(lb,i2)
                  atomvirial(k1,ihu) = atomvirial(k1,ihu) + vtmp
               end do
            end do
         endif

      endif

      do i2=1,nbocen
      j5=ia(j(2),2+i2)
      ibv=nubon2(j(2),i2)
      if (bo(ibv).gt.0.0) then
      dvmbodbo=-vmbo*8.0*bo(ibv)**7

      if (Lvirial.eq.1) then
         do k1=1,3
         do k2=1,3
            virial_tmp(k1,k2) = 0.0
         end do
         end do
      endif

      do i3=1,idbo1(ibv)
      ihu=idbo(ibv,i3)
      do k1=1,3
      ftmp = (-dsbo2dvlp*devdsbo+devdsbo2+decdsbo2
     $+dvmbodbo*dsbo2dvmbo*devdsbo)*
     $dbondc(ibv,k1,i3)+devdsbo*(dbopindc(ibv,k1,i3)+
     $dbopi2ndc(ibv,k1,i3))
      d(k1,ihu)=d(k1,ihu)+ftmp

      if (Lvirial.eq.1) then
      do k1p=1,3
      virial_tmp(k1,k1p)=virial_tmp(k1,k1p)+ftmp*c(ihu,k1p)
      end do
      endif

      end do
      end do
      if (Lvirial.eq.1) then
         virialsym(1) = virial_tmp(1,1)
         virialsym(2) = virial_tmp(2,2)
         virialsym(3) = virial_tmp(3,3)
         virialsym(4) = virial_tmp(1,2)
         virialsym(5) = virial_tmp(1,3)
         virialsym(6) = virial_tmp(2,3)
         do k1 = 1,6
            virial(k1) = virial(k1) + virialsym(k1)
         end do

         if (Latomvirial.eq.1) then
            frac = 1.0d0/idbo1(ibv)
            do k1 = 1,6
               vtmp = virialsym(k1)*frac
               do i3=1,idbo1(ibv)
                  ihu=idbo(ibv,i3)
                  atomvirial(k1,ihu) = atomvirial(k1,ihu) + vtmp
               end do
            end do
         endif

      endif

      endif
      end do
 
      do i2=1,ia(j(1),2)
      j5=ia(j(1),2+i2)
      ibv=nubon2(j(1),i2)
      if (bo(ibv).gt.0.0) then

      if (Lvirial.eq.1) then
         do k1=1,3
         do k2=1,3
            virial_tmp(k1,k2) = 0.0
         end do
         end do
      endif

      do i3=1,idbo1(ibv)
      ihu=idbo(ibv,i3)
      do k1=1,3
      ftmp = decodboua*dbondc(ibv,k1,i3)
      d(k1,ihu)=d(k1,ihu)+ftmp

      if (Lvirial.eq.1) then
      do k1p=1,3
      virial_tmp(k1,k1p)=virial_tmp(k1,k1p)+ftmp*c(ihu,k1p)
      end do
      endif

      end do
      end do
      if (Lvirial.eq.1) then
         virialsym(1) = virial_tmp(1,1)
         virialsym(2) = virial_tmp(2,2)
         virialsym(3) = virial_tmp(3,3)
         virialsym(4) = virial_tmp(1,2)
         virialsym(5) = virial_tmp(1,3)
         virialsym(6) = virial_tmp(2,3)
         do k1 = 1,6
            virial(k1) = virial(k1) + virialsym(k1)
         end do

         if (Latomvirial.eq.1) then
            frac = 1.0d0/idbo1(ibv)
            do k1 = 1,6
               vtmp = virialsym(k1)*frac
               do i3=1,idbo1(ibv)
                  ihu=idbo(ibv,i3)
                  atomvirial(k1,ihu) = atomvirial(k1,ihu) + vtmp
               end do
            end do
         endif

      endif

      endif
      end do
 
      do i2=1,ia(j(2),2)
      j5=ia(j(2),2+i2)
      ibv=nubon2(j(2),i2)
      if (bo(ibv).gt.0.0) then

      if (Lvirial.eq.1) then
         do k1=1,3
         do k2=1,3
            virial_tmp(k1,k2) = 0.0
         end do
         end do
      endif

      do i3=1,idbo1(ibv)
      ihu=idbo(ibv,i3)
      do k1=1,3
      ftmp = decodboob*dbondc(ibv,k1,i3)
      d(k1,ihu)=d(k1,ihu)+ftmp

      if (Lvirial.eq.1) then
      do k1p=1,3
      virial_tmp(k1,k1p)=virial_tmp(k1,k1p)+ftmp*c(ihu,k1p)
      end do
      endif

      end do
      end do
      if (Lvirial.eq.1) then
         virialsym(1) = virial_tmp(1,1)
         virialsym(2) = virial_tmp(2,2)
         virialsym(3) = virial_tmp(3,3)
         virialsym(4) = virial_tmp(1,2)
         virialsym(5) = virial_tmp(1,3)
         virialsym(6) = virial_tmp(2,3)
         do k1 = 1,6
            virial(k1) = virial(k1) + virialsym(k1)
         end do

         if (Latomvirial.eq.1) then
            frac = 1.0d0/idbo1(ibv)
            do k1 = 1,6
               vtmp = virialsym(k1)*frac
               do i3=1,idbo1(ibv)
                  ihu=idbo(ibv,i3)
                  atomvirial(k1,ihu) = atomvirial(k1,ihu) + vtmp
               end do
            end do
         endif

      endif

      endif
      end do

      do i2=1,ia(j(3),2)
      j5=ia(j(3),2+i2)
      ibv=nubon2(j(3),i2)
      if (bo(ibv).gt.0.0) then

      if (Lvirial.eq.1) then
         do k1=1,3
         do k2=1,3
            virial_tmp(k1,k2) = 0.0
         end do
         end do
      endif

      do i3=1,idbo1(ibv)
      ihu=idbo(ibv,i3)
      do k1=1,3
      ftmp = decodbouc*dbondc(ibv,k1,i3)
      d(k1,ihu)=d(k1,ihu)+ftmp

      if (Lvirial.eq.1) then
      do k1p=1,3
      virial_tmp(k1,k1p)=virial_tmp(k1,k1p)+ftmp*c(ihu,k1p)
      end do
      endif

      end do
      end do
      if (Lvirial.eq.1) then
         virialsym(1) = virial_tmp(1,1)
         virialsym(2) = virial_tmp(2,2)
         virialsym(3) = virial_tmp(3,3)
         virialsym(4) = virial_tmp(1,2)
         virialsym(5) = virial_tmp(1,3)
         virialsym(6) = virial_tmp(2,3)
         do k1 = 1,6
            virial(k1) = virial(k1) + virialsym(k1)
         end do

         if (Latomvirial.eq.1) then
            frac = 1.0d0/idbo1(ibv)
            do k1 = 1,6
               vtmp = virialsym(k1)*frac
               do i3=1,idbo1(ibv)
                  ihu=idbo(ibv,i3)
                  atomvirial(k1,ihu) = atomvirial(k1,ihu) + vtmp
               end do
            end do
         endif

      endif

      endif
      end do

      endif

   10 continue

      return
      end
********************************************************************** 
********************************************************************** 

      subroutine hbond

********************************************************************** 
#include "cbka.blk"
#include "cbkbo.blk"
#include "cbkconst.blk"
#include "cbkc.blk"
#include "cbkd.blk"
#include "cbkdcell.blk"
#include "cbkenergies.blk"
#include "cbkidbo.blk"
#include "cbksrthb.blk"
#include "control.blk"
#include "cbkhbond.blk"
#include "small.blk"
      dimension drda(3),j(3),dvdc(3,3),dargdc(3,3)
      dimension virial_tmp(3,3),virialsym(6)
********************************************************************** 
*                                                                    *
*     Calculate hydrogen bond energies and first derivatives         *
*                                                                    *
********************************************************************** 
c$$$      if (ndebug.eq.1) then
c$$$C      open (65,file='fort.65',status='unknown',access='append')
c$$$      write (65,*) 'In hbond'
c$$$      call timer(65)
c$$$      close (65)
c$$$      end if
      ehb=zero
      do 10 i1=1,nhb
      ityhb=ihb(i1,1)
      j(1)=ihb(i1,2)
      j(2)=ihb(i1,3)
      j(3)=ihb(i1,4)
      la=ihb(i1,5)
      boa=bo(la)
      call dista2(j(2),j(3),rda,dxm,dym,dzm)
      drda(1)=dxm/rda
      drda(2)=dym/rda
      drda(3)=dzm/rda
      call calvalhb(j(1),j(2),j(3),ix,iy,iz,arg,hhb(i1),dvdc,dargdc)
      rhu1=rhb(ityhb)/rda
      rhu2=rda/rhb(ityhb)
      sinhu=sin(hhb(i1)/2.0)
      sin2=sinhu*sinhu
      exphu1=exp(-vhb1(ityhb)*boa)
      exphu2=exp(-vhb2(ityhb)*(rhu1+rhu2-2.0))
      ehbh=(1.0-exphu1)*dehb(ityhb)*exphu2*sin2*sin2*sin2*sin2
      ehb=ehb+ehbh
      estrain(j(2))=estrain(j(2))+ehbh !2nd atom energy

********************************************************************** 
*                                                                    *
*     Calculate first derivatives                                    *
*                                                                    *
********************************************************************** 
      dehbdbo=vhb1(ityhb)*exphu1*dehb(ityhb)*exphu2*sin2*sin2*
     $sin2*sin2
      dehbdv=(1.0-exphu1)*dehb(ityhb)*exphu2*
     $4.0*sin2*sin2*sin2*sinhu*cos(hhb(i1)/2.0)
      dehbdrda=(1.0-exphu1)*dehb(ityhb)*sin2*sin2*sin2*sin2*
     $vhb2(ityhb)*(rhb(ityhb)/(rda*rda)-1.0/rhb(ityhb))*exphu2

      if (Lvirial.eq.1) then
         do k1=1,3
         do k2=1,3
            virial_tmp(k1,k2) = 0.0
         end do
         end do
      endif

      do k1=1,3
      ftmp = dehbdrda*drda(k1)
      d(k1,j(2))=d(k1,j(2))+ftmp
      d(k1,j(3))=d(k1,j(3))-ftmp

      if (Lvirial.eq.1) then
      do k1p=1,3
      virial_tmp(k1,k1p)=virial_tmp(k1,k1p)+
     $        ftmp*c(j(2),k1p)-ftmp*c(j(3),k1p)
      end do
      endif

      end do
      if (Lvirial.eq.1) then
         virialsym(1) = virial_tmp(1,1)
         virialsym(2) = virial_tmp(2,2)
         virialsym(3) = virial_tmp(3,3)
         virialsym(4) = virial_tmp(1,2)
         virialsym(5) = virial_tmp(1,3)
         virialsym(6) = virial_tmp(2,3)
         do k1 = 1,6
            virial(k1) = virial(k1) + virialsym(k1)
         end do

         if (Latomvirial.eq.1) then
            frac = 1.0d0/2
            do k1 = 1,6
               vtmp = virialsym(k1)*frac
               ihu = j(2)
               atomvirial(k1,ihu) = atomvirial(k1,ihu) + vtmp
               ihu = j(3)
               atomvirial(k1,ihu) = atomvirial(k1,ihu) + vtmp
            end do
         endif

      endif

      if (Lvirial.eq.1) then
         do k1=1,3
         do k2=1,3
            virial_tmp(k1,k2) = 0.0
         end do
         end do
      endif

      do k1=1,3
      do k2=1,3
      ftmp = dehbdv*dvdc(k1,k2)
      d(k1,j(k2))=d(k1,j(k2))+ftmp

      if (Lvirial.eq.1) then
      do k1p=1,3
      virial_tmp(k1,k1p)=virial_tmp(k1,k1p)+ftmp*c(j(k2),k1p)
      end do
      endif

      end do
      end do
      if (Lvirial.eq.1) then
         virialsym(1) = virial_tmp(1,1)
         virialsym(2) = virial_tmp(2,2)
         virialsym(3) = virial_tmp(3,3)
         virialsym(4) = virial_tmp(1,2)
         virialsym(5) = virial_tmp(1,3)
         virialsym(6) = virial_tmp(2,3)
         do k1 = 1,6
            virial(k1) = virial(k1) + virialsym(k1)
         end do

         if (Latomvirial.eq.1) then
            frac = 1.0d0/3
            do k1 = 1,6
               vtmp = virialsym(k1)*frac
               do k2=1,3
                  ihu=j(k2)
                  atomvirial(k1,ihu) = atomvirial(k1,ihu) + vtmp
               end do
            end do
         endif

      endif

      if (Lvirial.eq.1) then
         do k1=1,3
         do k2=1,3
            virial_tmp(k1,k2) = 0.0
         end do
         end do
      endif

      do i2=1,idbo1(la)
      ihu=idbo(la,i2)
      do k1=1,3
      ftmp = dehbdbo*dbondc(la,k1,i2)
      d(k1,ihu)=d(k1,ihu)+ftmp

      if (Lvirial.eq.1) then
      do k1p=1,3
      virial_tmp(k1,k1p)=virial_tmp(k1,k1p)+ftmp*c(ihu,k1p)
      end do
      endif

      end do
      end do
      if (Lvirial.eq.1) then
         virialsym(1) = virial_tmp(1,1)
         virialsym(2) = virial_tmp(2,2)
         virialsym(3) = virial_tmp(3,3)
         virialsym(4) = virial_tmp(1,2)
         virialsym(5) = virial_tmp(1,3)
         virialsym(6) = virial_tmp(2,3)
         do k1 = 1,6
            virial(k1) = virial(k1) + virialsym(k1)
         end do

         if (Latomvirial.eq.1) then
            frac = 1.0d0/idbo1(la)
            do k1 = 1,6
               vtmp = virialsym(k1)*frac
               do i2=1,idbo1(la)
                  ihu=idbo(la,i2)
                  atomvirial(k1,ihu) = atomvirial(k1,ihu) + vtmp
               end do
            end do
         endif

      endif

   10 continue
      return
      end 

********************************************************************** 
********************************************************************** 

      subroutine torang

********************************************************************** 
#include "cbka.blk"
#include "cbkabo.blk"
#include "cbkbo.blk"
#include "cbkbopi.blk"
#include "cbkc.blk"
#include "cbkconst.blk"
#include "cbkd.blk"
#include "cbkdbopindc.blk"
#include "cbkdcell.blk"
#include "cbkdhdc.blk"
#include "cbkdrdc.blk"
#include "cbkenergies.blk"
#include "cbkff.blk"
#include "cbkfftorang.blk"
#include "cbkh.blk"
#include "cbkia.blk"
#include "cbkidbo.blk"
#include "cbkinit.blk"
#include "cbknubon2.blk"
#include "cbkrbo.blk"
#include "cbktorang.blk"
#include "cbktorsion.blk"
#include "cbktregime.blk"
#include "cbkvalence.blk"
#include "cellcoord.blk"
#include "control.blk"
#include "small.blk"

      DIMENSION  A(3),DRDA(3),DADC(4),DRADC(3,4),DRBDC(3,4),
     $DRCDC(3,4),DHDDC(3,4),DHEDC(3,4),DRVDC(3,4),DTDC(3,4),
     $DNDC(3,4)
      dimension j(4),dh1rdc(3,3),dh2rdc(3,3),dargdc(3,3)
      dimension virial_tmp(3,3),virialsym(6)
********************************************************************** 
*                                                                    *
*     Calculate torsion angle energies and first derivatives         *
*                                                                    *
********************************************************************** 
c$$$      if (ndebug.eq.1) then
c$$$C      open (65,file='fort.65',status='unknown',access='append')
c$$$      write (65,*) 'In torang'
c$$$      call timer(65)
c$$$      close (65)
c$$$      end if
      do k1=1,3
      do k2=1,4
      dhddc(k1,k2)=0.0
      dhedc(k1,k2)=0.0
      dradc(k1,k2)=0.0
      drbdc(k1,k2)=0.0
      drcdc(k1,k2)=0.0
      end do
      end do
      et=0.0
      eth12=0.0
      eco=0.0
      dadc(1)=1.0
      dadc(2)=0.0
      dadc(3)=0.0
      dadc(4)=-1.0
      if (ntor.eq.0) return

      do 10 i1=1,ntor
      j(1)=it(i1,2)
      j(2)=it(i1,3)
      j(3)=it(i1,4)
      j(4)=it(i1,5)

      ity=it(i1,1)  
      la=it(i1,6)
      lb=it(i1,7)
      lc=it(i1,8)
      call calvalres(j(1),j(2),j(3),arg1,ht1,dh1rdc,dargdc)
      call calvalres(j(2),j(3),j(4),arg2,ht2,dh2rdc,dargdc)
      boa=bo(la)-cutof2
      bob=bo(lb)-cutof2
      boc=bo(lc)-cutof2
      if (boa.lt.zero.or.bob.lt.zero.or.boc.lt.zero) 
     $goto 10
      r42=0.0
      ivl1=ibsym(la)
      ivl2=ibsym(lb)
      ivl3=ibsym(lc)
      isign1=1
      isign2=1
      isign3=1
      rla=rbo(la)
      rlb=rbo(lb)
 
      call dista2(j(1),j(4),r4,a(1),a(2),a(3))
********************************************************************** 
*                                                                    *
*     Determine torsion angle                                        *
*                                                                    *
********************************************************************** 
      d142=r4*r4
      rla=rbo(la)
      rlb=rbo(lb)
      rlc=rbo(lc)
      coshd=cos(ht1)
      coshe=cos(ht2)
      sinhd=sin(ht1)
      sinhe=sin(ht2)
      poem=2.0*rla*rlc*sinhd*sinhe
      poem2=poem*poem
      tel=rla*rla+rlb*rlb+rlc*rlc-d142-2.0*(rla*rlb*coshd-rla*rlc*
     $coshd*coshe+rlb*rlc*coshe)
      if (poem.lt.1e-20) poem=1e-20
      arg=tel/poem
      if (arg.gt.1.0) arg=1.0
      if (arg.lt.-1.0) arg=-1.0
      arg2=arg*arg
      thg(i1)=acos(arg)*rdndgr
      k1=j(1)
      k2=j(2)
      k3=j(3)
      k4=j(4)
      call dista2(k3,k2,dis,x3,y3,z3)
      y32z32=y3*y3+z3*z3
      wort1=sqrt(y32z32)+1e-6
      wort2=sqrt(y32z32+x3*x3)+1e-6
*     if (wort1.lt.1e-6) wort1=1e-6
*     if (wort2.lt.1e-6) wort2=1e-6
      sinalf=y3/wort1
      cosalf=z3/wort1
      sinbet=x3/wort2
      cosbet=wort1/wort2
      call dista2(k1,k2,dis,x1,y1,z1)
      x1=x1*cosbet-y1*sinalf*sinbet-z1*cosalf*sinbet
      y1=y1*cosalf-z1*sinalf
      wort3=sqrt(x1*x1+y1*y1)+1e-6
*     if (wort3.lt.1e-6) wort3=1e-6
      singam=y1/wort3
      cosgam=x1/wort3
      call dista2(k4,k2,dis,x4,y4,z4)
      x4=x4*cosbet-y4*sinalf*sinbet-z4*cosalf*sinbet
      y4=y4*cosalf-z4*sinalf
      y4=x4*singam-y4*cosgam
      if (y4.gt.0.0) thg(i1)=-thg(i1)
      if (thg(i1).lt.-179.999999d0) thg(i1)=-179.999999d0
      if (thg(i1).gt.179.999999d0) thg(i1)=179.999999d0
      th2=thg(i1)*dgrrdn
********************************************************************** 
*                                                                    *
*     Calculate torsion angle energy                                 *
*                                                                    *
********************************************************************** 
      exbo1=abo(j(2))-valf(ia(j(2),1))
      exbo2=abo(j(3))-valf(ia(j(3),1))
      htovt=exbo1+exbo2
      expov=exp(vpar(26)*htovt)
      expov2=exp(-vpar(25)*(htovt))
      htov1=2.0+expov2
      htov2=1.0+expov+expov2
      etboadj=htov1/htov2

      btb2=bopi(lb)-1.0+etboadj
      bo2t=1.0-btb2
      bo2p=bo2t*bo2t
      bocor2=exp(v4(ity)*bo2p)

      hsin=sinhd*sinhe
      ethhulp=0.50*v1(ity)*(1.0+arg)+v2(ity)*bocor2*(1.0-arg2)+
     $v3(ity)*(0.50+2.0*arg2*arg-1.50*arg)

      exphua=exp(-vpar(24)*boa)
      exphub=exp(-vpar(24)*bob)
      exphuc=exp(-vpar(24)*boc)
      bocor4=(1.0-exphua)*(1.0-exphub)*(1.0-exphuc)
      eth=hsin*ethhulp*bocor4

      detdar=hsin*bocor4*(0.50*v1(ity)-2.0*v2(ity)*bocor2*arg+
     $v3(ity)*(6.0*arg2-1.5d0))
      detdhd=coshd*sinhe*bocor4*ethhulp
      detdhe=sinhd*coshe*bocor4*ethhulp

      detdboa=vpar(24)*exphua*(1.0-exphub)*(1.0-exphuc)*ethhulp*hsin
      detdbopib=-bocor4*2.0*v4(ity)*v2(ity)*
     $bo2t*bocor2*(1.0-arg2)*hsin
      detdbob=vpar(24)*exphub*(1.0-exphua)*
     $(1.0-exphuc)*ethhulp*hsin
      detdboc=vpar(24)*exphuc*(1.0-exphua)*
     $(1.0-exphub)*ethhulp*hsin

      detdsbo1=-(detdbopib)*
     $(vpar(25)*expov2/htov2+htov1*
     $(vpar(26)*expov-vpar(25)*expov2)/(htov2*htov2))

      et=et+eth
      estrain(j(2))=estrain(j(2))+0.50*eth !2nd atom energy
      estrain(j(3))=estrain(j(3))+0.50*eth !3rd atom energy

********************************************************************** 
*                                                                    *
*     Calculate conjugation energy                                   *
*                                                                    *
********************************************************************** 
      ba=(boa-1.50)*(boa-1.50)
      bb=(bob-1.50)*(bob-1.50)
      bc=(boc-1.50)*(boc-1.50)
      exphua1=exp(-vpar(28)*ba)
      exphub1=exp(-vpar(28)*bb)
      exphuc1=exp(-vpar(28)*bc)
      sbo=exphua1*exphub1*exphuc1
      dbohua=-2.0*(boa-1.50)*vpar(28)*exphua1*exphub1*exphuc1
      dbohub=-2.0*(bob-1.50)*vpar(28)*exphua1*exphub1*exphuc1
      dbohuc=-2.0*(boc-1.50)*vpar(28)*exphua1*exphub1*exphuc1
      arghu0=(arg2-1.0)*sinhd*sinhe
      ehulp=vconj(ity)*(arghu0+1.0)
      ecoh=ehulp*sbo
      decodar=sbo*vconj(ity)*2.0*arg*sinhd*sinhe
      decodbola=dbohua*ehulp
      decodbolb=dbohub*ehulp
      decodbolc=dbohuc*ehulp
      decodhd=coshd*sinhe*vconj(ity)*sbo*(arg2-1.0)
      decodhe=coshe*sinhd*vconj(ity)*sbo*(arg2-1.0)

      eco=eco+ecoh
      estrain(j(2))=estrain(j(2))+0.50*ecoh !2nd atom energy
      estrain(j(3))=estrain(j(3))+0.50*ecoh !3rd atom energy

    1 continue
********************************************************************** 
*                                                                    *
*     Calculate derivative torsion angle and conjugation energy      *
*     to cartesian coordinates                                       *
*                                                                    *
********************************************************************** 
      SINTH=SIN(THG(i1)*DGRRDN)
      IF (SINTH.GE.0.0.AND.SINTH.LT.1.0D-10) SINTH=1.0D-10
      IF (SINTH.LT.0.0.AND.SINTH.GT.-1.0D-10) SINTH=-1.0D-10
      IF (j(1).EQ.IB(LA,2)) THEN
      DO  K1=1,3
      DRADC(K1,1)=DRDC(LA,K1,1)
      DRADC(K1,2)=DRDC(LA,K1,2)
      end do
      ELSE
      DO  K1=1,3
      DRADC(K1,1)=DRDC(LA,K1,2)
      DRADC(K1,2)=DRDC(LA,K1,1)
      end do
      ENDIF
      IF (j(2).EQ.IB(LB,2)) THEN
      DO  K1=1,3
      DRBDC(K1,2)=DRDC(LB,K1,1)
      DRBDC(K1,3)=DRDC(LB,K1,2)
      end do
      ELSE
      DO K1=1,3
      DRBDC(K1,2)=DRDC(LB,K1,2)
      DRBDC(K1,3)=DRDC(LB,K1,1)
      end do
      ENDIF
      IF (j(3).EQ.IB(LC,2)) THEN
      DO K1=1,3
      DRCDC(K1,3)=DRDC(LC,K1,1)
      DRCDC(K1,4)=DRDC(LC,K1,2)
      end do
      ELSE
      DO K1=1,3
      DRCDC(K1,3)=DRDC(LC,K1,2)
      DRCDC(K1,4)=DRDC(LC,K1,1)
      end do
      ENDIF

      do k1=1,3
      dhddc(1,k1)=dh1rdc(1,k1)
      dhddc(2,k1)=dh1rdc(2,k1)
      dhddc(3,k1)=dh1rdc(3,k1)
      dhedc(1,k1+1)=dh2rdc(1,k1)
      dhedc(2,k1+1)=dh2rdc(2,k1)
      dhedc(3,k1+1)=dh2rdc(3,k1)
      end do

********************************************************************** 
*     write (64,*)j(1),j(2),j(3),j(4)
*     do k1=1,3
*     write (64,'(10f12.4)')(dh1rdc(k1,k2),k2=1,3),
*    $(dhdc(ld,k1,k2),k2=1,3),(dhddc(k1,k2),k2=1,4)
*     write (64,'(10f12.4)')(dh2rdc(k1,k2),k2=1,3),
*    $(dhdc(le,k1,k2),k2=1,3),(dhedc(k1,k2),k2=1,4)
*     end do
*     write (64,*)
********************************************************************** 
      HTRA=RLA+COSHD*(RLC*COSHE-RLB)
      HTRB=RLB-RLA*COSHD-RLC*COSHE
      HTRC=RLC+COSHE*(RLA*COSHD-RLB)
      HTHD=RLA*SINHD*(RLB-RLC*COSHE)
      HTHE=RLC*SINHE*(RLB-RLA*COSHD)
      HNRA=RLC*SINHD*SINHE
      HNRC=RLA*SINHD*SINHE
      HNHD=RLA*RLC*COSHD*SINHE
      HNHE=RLA*RLC*SINHD*COSHE

      if (Lvirial.eq.1) then
         do k1=1,3
         do k2=1,3
            virial_tmp(k1,k2) = 0.0
         end do
         end do
      endif

      DO  K1=1,3
      DRDA(K1)=A(K1)/R4
      DO  K2=1,4
      DRVDC(K1,K2)=DRDA(K1)*DADC(K2)
      DTDC(K1,K2)=2.0*(DRADC(K1,K2)*HTRA+DRBDC(K1,K2)*HTRB+DRCDC(K1,K2
     $)*HTRC-DRVDC(K1,K2)*R4+DHDDC(K1,K2)*HTHD+DHEDC(K1,K2)*HTHE)
      DNDC(K1,K2)=2.0*(DRADC(K1,K2)*HNRA+DRCDC(K1,K2)*HNRC+DHDDC(K1,K2
     $)*HNHD+DHEDC(K1,K2)*HNHE)
      DARGTDC(i1,K1,K2)=(DTDC(K1,K2)-ARG*DNDC(K1,K2))/POEM
 
      ftmp = DARGTDC(i1,K1,K2)*detdar+
     $dargtdc(i1,k1,k2)*decodar+(detdhd+decodhd)*dhddc(k1,k2)+
     $(detdhe+decodhe)*dhedc(k1,k2)
      D(K1,J(K2))=D(K1,J(K2))+ftmp

      if (Lvirial.eq.1) then
      do k1p=1,3
      virial_tmp(k1,k1p)=virial_tmp(k1,k1p)+ftmp*c(j(k2),k1p)
      end do
      endif

      end do
      end do
      if (Lvirial.eq.1) then
         virialsym(1) = virial_tmp(1,1)
         virialsym(2) = virial_tmp(2,2)
         virialsym(3) = virial_tmp(3,3)
         virialsym(4) = virial_tmp(1,2)
         virialsym(5) = virial_tmp(1,3)
         virialsym(6) = virial_tmp(2,3)
         do k1 = 1,6
            virial(k1) = virial(k1) + virialsym(k1)
         end do

         if (Latomvirial.eq.1) then
            frac = 1.0d0/4
            do k1 = 1,6
               vtmp = virialsym(k1)*frac
               do k2=1,4
                  ihu=j(k2)
                  atomvirial(k1,ihu) = atomvirial(k1,ihu) + vtmp
               end do
            end do
         endif

      endif

      if (Lvirial.eq.1) then
         do k1=1,3
         do k2=1,3
            virial_tmp(k1,k2) = 0.0
         end do
         end do
      endif

      do i2=1,idbo1(la)
      ihu=idbo(la,i2)
      do k1=1,3
      ftmp = dbondc(la,k1,i2)*(detdboa+decodbola)
      d(k1,ihu)=d(k1,ihu)+ftmp

      if (Lvirial.eq.1) then
      do k1p=1,3
      virial_tmp(k1,k1p)=virial_tmp(k1,k1p)+ftmp*c(ihu,k1p)
      end do
      endif

      end do
      end do
      if (Lvirial.eq.1) then
         virialsym(1) = virial_tmp(1,1)
         virialsym(2) = virial_tmp(2,2)
         virialsym(3) = virial_tmp(3,3)
         virialsym(4) = virial_tmp(1,2)
         virialsym(5) = virial_tmp(1,3)
         virialsym(6) = virial_tmp(2,3)
         do k1 = 1,6
            virial(k1) = virial(k1) + virialsym(k1)
         end do

         if (Latomvirial.eq.1) then
            frac = 1.0d0/idbo1(la)
            do k1 = 1,6
               vtmp = virialsym(k1)*frac
               do i2=1,idbo1(la)
                  ihu=idbo(la,i2)
                  atomvirial(k1,ihu) = atomvirial(k1,ihu) + vtmp
               end do
            end do
         endif

      endif

      if (Lvirial.eq.1) then
         do k1=1,3
         do k2=1,3
            virial_tmp(k1,k2) = 0.0
         end do
         end do
      endif

      do i2=1,idbo1(lb)
      ihu=idbo(lb,i2)
      do k1=1,3
         ftmp = dbondc(lb,k1,i2)*(detdbob+decodbolb)
     $   +dbopindc(lb,k1,i2)*detdbopib
      d(k1,ihu)=d(k1,ihu)+ftmp

      if (Lvirial.eq.1) then
      do k1p=1,3
      virial_tmp(k1,k1p)=virial_tmp(k1,k1p)+ftmp*c(ihu,k1p)
      end do
      endif

      end do
      end do
      if (Lvirial.eq.1) then
         virialsym(1) = virial_tmp(1,1)
         virialsym(2) = virial_tmp(2,2)
         virialsym(3) = virial_tmp(3,3)
         virialsym(4) = virial_tmp(1,2)
         virialsym(5) = virial_tmp(1,3)
         virialsym(6) = virial_tmp(2,3)
         do k1 = 1,6
            virial(k1) = virial(k1) + virialsym(k1)
         end do

         if (Latomvirial.eq.1) then
            frac = 1.0d0/idbo1(lb)
            do k1 = 1,6
               vtmp = virialsym(k1)*frac
               do i2=1,idbo1(lb)
                  ihu=idbo(lb,i2)
                  atomvirial(k1,ihu) = atomvirial(k1,ihu) + vtmp
               end do
            end do
         endif

      endif

      if (Lvirial.eq.1) then
         do k1=1,3
         do k2=1,3
            virial_tmp(k1,k2) = 0.0
         end do
         end do
      endif

      do i2=1,idbo1(lc)
      ihu=idbo(lc,i2)
      do k1=1,3
      ftmp = dbondc(lc,k1,i2)*(detdboc+decodbolc)
      d(k1,ihu)=d(k1,ihu)+ftmp

      if (Lvirial.eq.1) then
      do k1p=1,3
      virial_tmp(k1,k1p)=virial_tmp(k1,k1p)+ftmp*c(ihu,k1p)
      end do
      endif

      end do
      end do
      if (Lvirial.eq.1) then
         virialsym(1) = virial_tmp(1,1)
         virialsym(2) = virial_tmp(2,2)
         virialsym(3) = virial_tmp(3,3)
         virialsym(4) = virial_tmp(1,2)
         virialsym(5) = virial_tmp(1,3)
         virialsym(6) = virial_tmp(2,3)
         do k1 = 1,6
            virial(k1) = virial(k1) + virialsym(k1)
         end do

         if (Latomvirial.eq.1) then
            frac = 1.0d0/idbo1(lc)
            do k1 = 1,6
               vtmp = virialsym(k1)*frac
               do i2=1,idbo1(lc)
                  ihu=idbo(lc,i2)
                  atomvirial(k1,ihu) = atomvirial(k1,ihu) + vtmp
               end do
            end do
         endif

      endif

      do i2=1,ia(j(2),2)
      iob=ia(j(2),2+i2)
      ncubo=nubon2(j(2),i2)
      if (bo(ncubo).gt.0.0) then

      if (Lvirial.eq.1) then
         do k1=1,3
         do k2=1,3
            virial_tmp(k1,k2) = 0.0
         end do
         end do
      endif

      do i3=1,idbo1(ncubo)
      ihu=idbo(ncubo,i3)
      do k1=1,3
      ftmp = detdsbo1*dbondc(ncubo,k1,i3)
      d(k1,ihu)=d(k1,ihu)+ftmp

      if (Lvirial.eq.1) then
      do k1p=1,3
      virial_tmp(k1,k1p)=virial_tmp(k1,k1p)+ftmp*c(ihu,k1p)
      end do
      endif

      end do
      end do
      if (Lvirial.eq.1) then
         virialsym(1) = virial_tmp(1,1)
         virialsym(2) = virial_tmp(2,2)
         virialsym(3) = virial_tmp(3,3)
         virialsym(4) = virial_tmp(1,2)
         virialsym(5) = virial_tmp(1,3)
         virialsym(6) = virial_tmp(2,3)
         do k1 = 1,6
            virial(k1) = virial(k1) + virialsym(k1)
         end do

         if (Latomvirial.eq.1) then
            frac = 1.0d0/idbo1(ncubo)
            do k1 = 1,6
               vtmp = virialsym(k1)*frac
               do i3=1,idbo1(ncubo)
                  ihu=idbo(ncubo,i3)
                  atomvirial(k1,ihu) = atomvirial(k1,ihu) + vtmp
               end do
            end do
         endif

      endif

      endif
      end do

      do i2=1,ia(j(3),2)
      iob=ia(j(3),2+i2)
      ncubo=nubon2(j(3),i2)
      if (bo(ncubo).gt.0.0) then

      if (Lvirial.eq.1) then
         do k1=1,3
         do k2=1,3
            virial_tmp(k1,k2) = 0.0
         end do
         end do
      endif

      do i3=1,idbo1(ncubo)
      ihu=idbo(ncubo,i3)
      do k1=1,3
      ftmp = detdsbo1*dbondc(ncubo,k1,i3)
      d(k1,ihu)=d(k1,ihu)+ftmp

      if (Lvirial.eq.1) then
      do k1p=1,3
      virial_tmp(k1,k1p)=virial_tmp(k1,k1p)+ftmp*c(ihu,k1p)
      end do
      endif

      end do
      end do

      if (Lvirial.eq.1) then
         virialsym(1) = virial_tmp(1,1)
         virialsym(2) = virial_tmp(2,2)
         virialsym(3) = virial_tmp(3,3)
         virialsym(4) = virial_tmp(1,2)
         virialsym(5) = virial_tmp(1,3)
         virialsym(6) = virial_tmp(2,3)
         do k1 = 1,6
            virial(k1) = virial(k1) + virialsym(k1)
         end do

         if (Latomvirial.eq.1) then
            frac = 1.0d0/idbo1(ncubo)
            do k1 = 1,6
               vtmp = virialsym(k1)*frac
               do i3=1,idbo1(ncubo)
                  ihu=idbo(ncubo,i3)
                  atomvirial(k1,ihu) = atomvirial(k1,ihu) + vtmp
               end do
            end do
         endif

      endif

      endif
      end do

   10 continue 

      return
      end 
********************************************************************** 
********************************************************************** 

      subroutine nonbon

********************************************************************** 
#include "cbka.blk"
#include "cbkc.blk"
#include "cbkch.blk"
#include "cbkconst.blk"
#include "cbkd.blk"
#include "cbkdcell.blk"
#include "cbkenergies.blk"
#include "cbkff.blk"
#include "cbkia.blk"
#include "cbknonbon.blk"
#include "cbkpairs.blk"
#include "cbknvlown.blk"
#include "cellcoord.blk"
#include "control.blk"
#include "small.blk"

      dimension a(3),da(6)
      dimension virial_tmp(3,3),virialsym(6)
********************************************************************** 
*                                                                    *
*     Calculate vdWaals and Coulomb energies and derivatives         *
*                                                                    *
********************************************************************** 
c$$$      if (ndebug.eq.1) then
c$$$C      open (65,file='fort.65',status='unknown',access='append')
c$$$      write (65,*) 'In nonbon'
c$$$      call timer(65)
c$$$      end if

      ew=0.0
      ep=0.0

      c1c=332.0638
      third=one/three
      fothird=4.0/3.0
      twothird=2.0/3.0
      h15=(vpar(29)-1.0)/vpar(29)

      nptmp=0
      nstmp=0
      do 10 ivl=1,nvpair-nvlself
c Use precomputed midpoint criterion to decide if interaction is owned.
      if (nvlown(ivl).eq.1) then

      i1=nvl1(ivl)
      i2=nvl2(ivl)

      call dista2(i1,i2,rr,a(1),a(2),a(3))
      if (rr.gt.swb.or.rr.lt.0.001) goto 10

      ity1=ia(i1,1)
      ity2=ia(i2,1)
      imol1=iag(i1,3+mbond)
      imol2=iag(i2,3+mbond)
      rr2=rr*rr

      sw=1.0
      sw1=0.0
      call taper(rr,rr2)
**********************************************************************
*                                                                    *
*     Calculate vdWaals energy                                       *
*                                                                    *
**********************************************************************
      p1=p1co(ity1,ity2)
      p2=p2co(ity1,ity2)
      p3=p3co(ity1,ity2)
      hulpw=(rr**vpar(29)+gamwco(ity1,ity2))
      rrw=hulpw**(1.0/vpar(29))
      h1=exp(p3*(1.0-rrw/p1))
      h2=exp(0.50*p3*(1.0-rrw/p1))

      ewh=p2*(h1-2.0*h2)
      rrhuw=rr**(vpar(29)-1.0)
      dewdr=(p2*p3/p1)*(h2-h1)*rrhuw*(hulpw**(-h15))

**********************************************************************
*                                                                    *
*     Calculate Coulomb energy                                       *
*                                                                    *
**********************************************************************
      q1q2=ch(i1)*ch(i2)
      hulp1=(rr2*rr+gamcco(ity1,ity2))
      eph=c1c*q1q2/(hulp1**third)
      depdr=-c1c*q1q2*rr2/(hulp1**fothird)
**********************************************************************
*                                                                    *
*     Taper correction                                               *
*                                                                    *
**********************************************************************
      ephtap=eph*sw
      depdrtap=depdr*sw+eph*sw1
      ewhtap=ewh*sw
      dewdrtap=dewdr*sw+ewh*sw1

*     write (64,*)i1,i2,p1,p2,p3,gamwco(ity1,ity2),vpar(29),ewh,ew
      ew=ew+ewhtap
      ep=ep+ephtap
      estrain(i1)=estrain(i1)+0.50*(ewhtap+ephtap) !1st atom energy
      estrain(i2)=estrain(i2)+0.50*(ewhtap+ephtap) !2nd atom energy

**********************************************************************
*                                                                    *
*     Calculate derivatives vdWaals energy to cartesian              *
*     coordinates                                                    *
*                                                                    *
**********************************************************************

      if (Lvirial.eq.1) then
         do k1=1,3
         do k2=1,3
            virial_tmp(k1,k2) = 0.0
         end do
         end do
      endif

      do k4=1,3
         ftmp = (dewdrtap+depdrtap)*(a(k4)/rr)
         d(k4,i1)=d(k4,i1)+ftmp
         d(k4,i2)=d(k4,i2)-ftmp
         if (Lvirial.eq.1) then
            do k1p=1,3
               virial_tmp(k4,k1p)=virial_tmp(k4,k1p)+
     $              ftmp*c(i1,k1p)-ftmp*c(i2,k1p)
            end do
         endif
      end do

      if (Lvirial.eq.1) then
         virialsym(1) = virial_tmp(1,1)
         virialsym(2) = virial_tmp(2,2)
         virialsym(3) = virial_tmp(3,3)
         virialsym(4) = virial_tmp(1,2)
         virialsym(5) = virial_tmp(1,3)
         virialsym(6) = virial_tmp(2,3)
         do k1 = 1,6
            virial(k1) = virial(k1) + virialsym(k1)
         end do

         if (Latomvirial.eq.1) then
            frac = 1.0d0/2
            do k1 = 1,6
               vtmp = virialsym(k1)*frac
               ihu=i1
               atomvirial(k1,ihu) = atomvirial(k1,ihu) + vtmp
               ihu=i2
               atomvirial(k1,ihu) = atomvirial(k1,ihu) + vtmp
            end do
         endif

      endif

      endif

   10 continue

      return
      end

********************************************************************** 
**********************************************************************
 
      subroutine efield
 
**********************************************************************
#include "cbka.blk"
#include "cbkc.blk"
#include "cbkch.blk"
#include "cbkcha.blk"
#include "cbkd.blk"
#include "cbkefield.blk"
#include "cbkenergies.blk"
#include "cbktregime.blk"
#include "control.blk"
#include "small.blk"
c$$$      if (ndebug.eq.1) then
c$$$C      open (65,file='fort.65',status='unknown',access='append')
c$$$      write (65,*) 'In efield'
c$$$      call timer(65)
c$$$      close (65)
c$$$      end if
**********************************************************************
*                                                                    *
*     Electric field                                                 *
*                                                                    *
**********************************************************************
      efi=0.0
      efix=0.0
      efiy=0.0
      efiz=0.0
      c1c=332.0638       !Coulomb energy conversion
      c1=23.02           !conversion from kcal to eV
 
      if (ifieldx.eq.1) then
      do i1=1,na
      efih=vfieldx*c1*c1c*ch(i1)*c(i1,1)
      efix=efix+efih
      estrain(i1)=estrain(i1)+efih               !atom energy

      defidc=c1*c1c*vfieldx*ch(i1)
      d(1,i1)=d(1,i1)+defidc
      end do
      end if
 
      if (ifieldy.eq.1) then
      do i1=1,na
      efih=vfieldy*c1*c1c*ch(i1)*c(i1,2)
      efiy=efiy+efih
      estrain(i1)=estrain(i1)+efih               !atom energy

      defidc=c1*c1c*vfieldy*ch(i1)
      d(2,i1)=d(2,i1)+defidc
      end do
      end if
 
      if (ifieldz.eq.1) then
      do i1=1,na
      efih=vfieldz*c1*c1c*ch(i1)*c(i1,3)
      efiz=efiz+efih
      estrain(i1)=estrain(i1)+efih               !atom energy

      defidc=c1*c1c*vfieldz*ch(i1)
      d(3,i1)=d(3,i1)+defidc
      end do
      end if
 
      efi=efix+efiy+efiz
      return
      end
**********************************************************************
********************************************************************** 

      subroutine restraint

********************************************************************** 
#include "cbka.blk"
#include "cbkatomcoord.blk"
#include "cbkc.blk"
#include "cbkconst.blk"
#include "cbkd.blk"
#include "cbkenergies.blk"
#include "cbkrestr.blk"
#include "cbktorang.blk"
#include "cbktorsion.blk"
#include "cbktregime.blk"
#include "control.blk"
#include "small.blk"
#include "cbkinit.blk"
      dimension drda(3),j(4),dhrdc(3,3),dargdc(3,3)
********************************************************************** 
*                                                                    *
*     Calculate distance restraint energy                            *
*                                                                    *
********************************************************************** 
c$$$      if (ndebug.eq.1) then
c$$$C      open (65,file='fort.65',status='unknown',access='append')
c$$$      write (65,*) 'In restraint'
c$$$      call timer(65)
c$$$      close (65)
c$$$      end if
      do i1=1,nrestra
      ih1=irstra(i1,1)
      ih2=irstra(i1,2)
      if (itend(i1).eq.0.or.(mdstep.gt.itstart(i1).and.mdstep.lt.
     $itend(i1))) then
      call dista2(ih1,ih2,rr,dx,dy,dz)
      diffr=rr-rrstra(i1)
*     diffr=rrstra(i1)
      exphu=exp(-vkrst2(i1)*(diffr*diffr))
      erh=vkrstr(i1)*(1.0-exphu)
      deresdr=2.0*vkrst2(i1)*diffr*vkrstr(i1)*exphu
*     deresdr=-2.0*vkrst2(i1)*diffr*vkrstr(i1)*exphu
      eres=eres+erh
      drda(1)=dx/rr
      drda(2)=dy/rr
      drda(3)=dz/rr
      do k1=1,3
      d(k1,ih1)=d(k1,ih1)+deresdr*drda(k1)
      d(k1,ih2)=d(k1,ih2)-deresdr*drda(k1)
      end do
      end if
      end do
      
**********************************************************************
*                                                                    *
*     Calculate angle restraint energy                               *
*                                                                    *
**********************************************************************
      do i1=1,nrestrav
      j(1)=irstrav(i1,1)
      j(2)=irstrav(i1,2)
      j(3)=irstrav(i1,3)
      ittr=0
*     do i2=1,nval
*     if (j(1).eq.iv(i2,2).and.j(2).eq.iv(i2,3).and.j(3).eq.iv(i2,4))
*    $ittr=i2
*     end do
*     if (ittr.eq.0) stop 'Wrong valence angle restraint'
      call calvalres(j(1),j(2),j(3),arg,hr,dhrdc,dargdc)
      vaval=hr*rdndgr
      diffv=-(vaval-vrstra(i1))*dgrrdn
      exphu=exp(-vkr2v(i1)*(diffv*diffv))
      erh=vkrv(i1)*(1.0-exphu)
      deresdv=-2.0*vkr2v(i1)*diffv*vkrv(i1)*exphu
      eres=eres+erh
      do k1=1,3
      do k2=1,3
      d(k1,j(k2))=d(k1,j(k2))+deresdv*dhrdc(k1,k2)
      end do
      end do

      end do

********************************************************************** 
*                                                                    *
*     Calculate torsion restraint energy                             *
*                                                                    *
********************************************************************** 
      do i1=1,nrestrat
      j(1)=irstrat(i1,1)
      j(2)=irstrat(i1,2)
      j(3)=irstrat(i1,3)
      j(4)=irstrat(i1,4)
      ittr=0
      do i2=1,ntor
      if (j(1).eq.it(i2,2).and.j(2).eq.it(i2,3).and.j(3).eq.it(i2,4)
     $.and.j(4).eq.it(i2,5)) ittr=i2
      if (j(4).eq.it(i2,2).and.j(3).eq.it(i2,3).and.j(2).eq.it(i2,4)
     $.and.j(1).eq.it(i2,5)) ittr=i2
      end do
      if (ittr.eq.0) then
      write (*,*)'Wrong torsion restraint'
      write (*,*)i1,j(1),j(2),j(3),j(4)
      stop 'Wrong torsion restraint'
      end if
      vtor=thg(ittr)
      difft=-(vtor-trstra(i1))*dgrrdn
      exphu=exp(-vkr2t(i1)*(difft*difft))
      erh=vkrt(i1)*(1.0-exphu)
      deresdt=2.0*vkr2t(i1)*difft*vkrt(i1)*exphu
      if (vtor.lt.zero) deresdt=-deresdt
      eres=eres+erh
      do k1=1,3
      do k2=1,4
      d(k1,j(k2))=d(k1,j(k2))+deresdt*dargtdc(ittr,k1,k2)
      end do
      end do

      end do
********************************************************************** 
*                                                                    *
*     Calculate mass centre restraint energy                         *
*                                                                    *
********************************************************************** 
      do i1=1,nrestram
      j1=irstram(i1,2)
      j2=irstram(i1,3)
      j3=irstram(i1,4)
      j4=irstram(i1,5)
      kdir=irstram(i1,1)
      cmx1=0.0 
      cmy1=0.0 
      cmz1=0.0 
      cmx2=0.0 
      cmy2=0.0 
      cmz2=0.0 
      summas1=0.0
      summas2=0.0
      do i2=j1,j2
      cmx1=cmx1+c(i2,1)*xmasat(i2)
      cmy1=cmy1+c(i2,2)*xmasat(i2)
      cmz1=cmz1+c(i2,3)*xmasat(i2)
      summas1=summas1+xmasat(i2)
      end do
      cmx1=cmx1/summas1
      cmy1=cmy1/summas1
      cmz1=cmz1/summas1
      if (mdstep.lt.2) then
      rmstrax(i1)=cmx1
      rmstray(i1)=cmy1
      rmstraz(i1)=cmz1
      end if
      if (kdir.le.3) then
      do i2=j3,j4
      cmx2=cmx2+c(i2,1)*xmasat(i2)
      cmy2=cmy2+c(i2,2)*xmasat(i2)
      cmz2=cmz2+c(i2,3)*xmasat(i2)
      summas2=summas2+xmasat(i2)
      end do
      cmx2=cmx2/summas2
      cmy2=cmy2/summas2
      cmz2=cmz2/summas2
      end if
      if (kdir.eq.1) dist=cmx1-cmx2
      if (kdir.eq.2) dist=cmy1-cmy2
      if (kdir.eq.3) dist=cmz1-cmz2
      if (kdir.eq.4) then
      distx=cmx1-rmstrax(i1)
      disty=cmy1-rmstray(i1)
      distz=cmz1-rmstraz(i1)
      dist=sqrt(distx*distx+disty*disty+distz*distz)
      end if
      dismacen(i1)=dist
      dist=dist-rmstra1(i1)
      erh=rmstra2(i1)*dist*dist
      deresdr=2.0*dist*rmstra2(i1)
*     exphu=exp(-rmstra3(i1)*(dist*dist))
*     erh=rmstra2(i1)*(1.0-exphu)
*     deresdr=2.0*rmstra3(i1)*dist*rmstra2(i1)*exphu
      eres=eres+erh
      if (kdir.le.3) then
      do i2=j1,j2
      d(kdir,i2)=d(kdir,i2)+deresdr*xmasat(i2)/summas1
      end do
      do i2=j3,j4
      d(kdir,i2)=d(kdir,i2)-deresdr*xmasat(i2)/summas2
      end do
      end if
      if (kdir.eq.4.and.mdstep.gt.5) then
      do i2=j1,j2
      d(1,i2)=d(1,i2)+deresdr*(distx/dist)*(xmasat(i2)/summas1)
      d(2,i2)=d(2,i2)+deresdr*(disty/dist)*(xmasat(i2)/summas1)
      d(3,i2)=d(3,i2)+deresdr*(distz/dist)*(xmasat(i2)/summas1)
      end do
      end if
      end do
********************************************************************** 
*                                                                    *
*     Calculate morphing energy                                      *
*                                                                    *
********************************************************************** 
      if (imorph.eq.1) then
      distot=zero
      do i1=1,na
      dmx=c(i1,1)-cmo(i1,1)
      dmy=c(i1,2)-cmo(i1,2)
      dmz=c(i1,3)-cmo(i1,3)
      dism=sqrt(dmx*dmx+dmy*dmy+dmz*dmz)
      distot=distot+dism
*     exphu=exp(-vmo2(i1)*(dism*dism))
*     erh=vmo1(i1)*(1.0-exphu)
      erh=vmo1(i1)*dism
      eres=eres+erh
*     deresddis=2.0*vmo2(i1)*dism*vmo1(i1)*exphu
      deresddis=vmo1(i1)
      drda1=dmx/dism
      drda2=dmy/dism
      drda3=dmz/dism
      d(1,i1)=d(1,i1)+deresddis*drda1
      d(2,i1)=d(2,i1)+deresddis*drda2
      d(3,i1)=d(3,i1)+deresddis*drda3
      end do
  
      end if
      
      
      return
      end
********************************************************************** 
******************************************************************** 

      subroutine calvalres (ja1,ja2,ja3,arg,hr,dhrdc,dargdc)

********************************************************************** 
#include "cbka.blk"
#include "cbkc.blk"
      dimension a(3),b(3),j(3),dradc(3,3),drbdc(3,3),dtdc(3,3),
     $dargdc(3,3),dndc(3,3),dadc(3),dbdc(3),dhrdc(3,3)
********************************************************************** 
*                                                                    *
*     Calculate valency angles and their derivatives to cartesian    *
*     coordinates  for restraint calculations                        *
*                                                                    *
********************************************************************** 
c$$$*     if (ndebug.eq.1) then
c$$$C*     open (65,file='fort.65',status='unknown',access='append')
c$$$*     write (65,*) 'In calvalres'
c$$$*     call timer(65)
c$$$*     close (65)
c$$$*     end if

      dadc(1)=-1.0
      dadc(2)=1.0
      dadc(3)=0.0
      dbdc(1)=0.0
      dbdc(2)=1.0
      dbdc(3)=-1.0
      do k1=1,3
      do k2=1,3
      dradc(k1,k2)=0.0
      drbdc(k1,k2)=0.0
      end do
      end do
**********************************************************************
*                                                                    *
*     Determine valency angle                                        *
*                                                                    *
**********************************************************************
      call dista2(ja1,ja2,rla,dx1,dy1,dz1)
      call dista2(ja2,ja3,rlb,dx2,dy2,dz2)
 
      a(1)=-dx1
      a(2)=-dy1
      a(3)=-dz1
      b(1)=dx2
      b(2)=dy2
      b(3)=dz2
      poem=rla*rlb
      tel=a(1)*b(1)+a(2)*b(2)+a(3)*b(3)
      arg=tel/poem
      arg2=arg*arg
      s1ma22=1.0-arg2
      if (s1ma22.lt.1.0d-10) s1ma22=1.0d-10
      s1ma2=sqrt(s1ma22)
      if (arg.gt.1.0) arg=1.0
      if (arg.lt.-1.0) arg=-1.0
      hr=acos(arg)
**********************************************************************
*                                                                    *
*     Calculate derivative valency angle to cartesian coordinates    *
*                                                                    *
**********************************************************************
      do k1=1,3
      dradc(k1,1)=-a(k1)/rla
      dradc(k1,2)=a(k1)/rla
      end do

      do k1=1,3
      drbdc(k1,2)=b(k1)/rlb
      drbdc(k1,3)=-b(k1)/rlb
      end do

      do k1=1,3
      do k2=1,3
      dndc(k1,k2)=rla*drbdc(k1,k2)+rlb*dradc(k1,k2)
      dtdc(k1,k2)=a(k1)*dbdc(k2)+b(k1)*dadc(k2)
      dargdc(k1,k2)=(dtdc(k1,k2)-arg*dndc(k1,k2))/poem
      dhrdc(k1,k2)=-dargdc(k1,k2)/s1ma2
      end do
      end do
      
   10 continue

      return
      end
********************************************************************** 
******************************************************************** 

      subroutine calvalhb (ja1,ja2,ja3,ix,iy,iz,arg,hr,dhrdc,dargdc)

********************************************************************** 
#include "cbka.blk"
#include "cbkc.blk"
      dimension a(3),b(3),j(3),dradc(3,3),drbdc(3,3),dtdc(3,3),
     $dargdc(3,3),dndc(3,3),dadc(3),dbdc(3),dhrdc(3,3)
********************************************************************** 
*                                                                    *
*     Calculate valency angles and their derivatives to cartesian    *
*     coordinates  for hydrogen bond calculations                    *
*                                                                    *
********************************************************************** 
c$$$*     if (ndebug.eq.1) then
c$$$*     open (65,file='fort.65',status='unknown',access='append')
c$$$*     write (65,*) 'In calvalhb'
c$$$*     call timer(65)
c$$$*     close (65)
c$$$*     end if

      dadc(1)=-1.0
      dadc(2)=1.0
      dadc(3)=0.0
      dbdc(1)=0.0
      dbdc(2)=1.0
      dbdc(3)=-1.0
      do k1=1,3
      do k2=1,3
      dradc(k1,k2)=0.0
      drbdc(k1,k2)=0.0
      end do
      end do
**********************************************************************
*                                                                    *
*     Determine valency angle                                        *
*                                                                    *
**********************************************************************
      call dista2(ja1,ja2,rla,dx1,dy1,dz1)
      call dista2(ja2,ja3,rlb,dx2,dy2,dz2)

      a(1)=-dx1
      a(2)=-dy1
      a(3)=-dz1
      b(1)=dx2
      b(2)=dy2
      b(3)=dz2
      poem=rla*rlb
      tel=a(1)*b(1)+a(2)*b(2)+a(3)*b(3)
      arg=tel/poem
      arg2=arg*arg
      s1ma22=1.0-arg2
      if (s1ma22.lt.1.0d-10) s1ma22=1.0d-10
      s1ma2=sqrt(s1ma22)
      if (arg.gt.1.0) arg=1.0
      if (arg.lt.-1.0) arg=-1.0
      hr=acos(arg)
**********************************************************************
*                                                                    *
*     Calculate derivative valency angle to cartesian coordinates    *
*                                                                    *
**********************************************************************
      do k1=1,3
      dradc(k1,1)=-a(k1)/rla
      dradc(k1,2)=a(k1)/rla
      end do

      do k1=1,3
      drbdc(k1,2)=b(k1)/rlb
      drbdc(k1,3)=-b(k1)/rlb
      end do

      do k1=1,3
      do k2=1,3
      dndc(k1,k2)=rla*drbdc(k1,k2)+rlb*dradc(k1,k2)
      dtdc(k1,k2)=a(k1)*dbdc(k2)+b(k1)*dadc(k2)
      dargdc(k1,k2)=(dtdc(k1,k2)-arg*dndc(k1,k2))/poem
      dhrdc(k1,k2)=-dargdc(k1,k2)/s1ma2
      end do
      end do
      
   10 continue

      return
      end
********************************************************************** 
********************************************************************** 

      subroutine caltor(ja1,ja2,ja3,ja4,ht)

********************************************************************** 
#include "cbka.blk"
#include "cbkenergies.blk"
#include "cbktregime.blk"
#include "control.blk"
#include "cbkinit.blk"
      DIMENSION  A(3),DRDA(3),DADC(4),DRADC(3,4),DRBDC(3,4),
     $DRCDC(3,4),DHDDC(3,4),DHEDC(3,4),DRVDC(3,4),DTDC(3,4),
     $DNDC(3,4)
      dimension j(4),dvdc1(3,3),dargdc1(3,3),dvdc2(3,3),dargdc2(3,3)
********************************************************************** 
*                                                                    *
*     Calculate torsion angle (for internal coordinates output)      *
*                                                                    *
********************************************************************** 
c$$$      if (ndebug.eq.1) then
c$$$C      open (65,file='fort.65',status='unknown',access='append')
c$$$      write (65,*) 'In caltor'
c$$$      call timer(65)
c$$$      close (65)
c$$$      end if
      do k1=1,3
      do k2=1,4
      dhddc(k1,k2)=0.0
      dhedc(k1,k2)=0.0
      dradc(k1,k2)=0.0
      drbdc(k1,k2)=0.0
      drcdc(k1,k2)=0.0
      end do
      end do
      et=0.0
      eco=0.0
      dadc(1)=1.0
      dadc(2)=0.0
      dadc(3)=0.0
      dadc(4)=-1.0
      call dista2(ja1,ja2,rla,dx1,dy1,dz1)
      call dista2(ja2,ja3,rlb,dx2,dy2,dz2)
      call dista2(ja3,ja4,rlc,dx2,dy2,dz2)
      call dista2(ja1,ja4,r4,dx2,dy2,dz2)
      call calvalres(ja1,ja2,ja3,arg1,h1,dvdc1,dargdc1)
      call calvalres(ja2,ja3,ja4,arg2,h2,dvdc2,dargdc2)
********************************************************************** 
*                                                                    *
*     Determine torsion angle                                        *
*                                                                    *
********************************************************************** 
      d142=r4*r4
      coshd=cos(h1)
      coshe=cos(h2)
      sinhd=sin(h1)
      sinhe=sin(h2)
      poem=2.0*rla*rlc*sinhd*sinhe
      poem2=poem*poem
      tel=rla*rla+rlb*rlb+rlc*rlc-d142-2.0*(rla*rlb*coshd-rla*rlc*
     $coshd*coshe+rlb*rlc*coshe)
      arg=tel/poem
      if (arg.gt.1.0) arg=1.0
      if (arg.lt.-1.0) arg=-1.0
      arg2=arg*arg
      ht=acos(arg)*rdndgr
      k1=ja1
      k2=ja2
      k3=ja3
      k4=ja4
      call dista2(k3,k2,dis,x3,y3,z3)
      y32z32=y3*y3+z3*z3
      wort1=sqrt(y32z32)+1e-6
      wort2=sqrt(y32z32+x3*x3)+1e-6
      sinalf=y3/wort1
      cosalf=z3/wort1
      sinbet=x3/wort2
      cosbet=wort1/wort2
      call dista2(k1,k2,dis,x1,y1,z1)
      x1=x1*cosbet-y1*sinalf*sinbet-z1*cosalf*sinbet
      y1=y1*cosalf-z1*sinalf
      wort3=sqrt(x1*x1+y1*y1)+1e-6
      singam=y1/wort3
      cosgam=x1/wort3
      call dista2(k4,k2,dis,x4,y4,z4)
      x4=x4*cosbet-y4*sinalf*sinbet-z4*cosalf*sinbet
      y4=y4*cosalf-z4*sinalf
      y4=x4*singam-y4*cosgam
      if (y4.gt.0.0) ht=-ht
      if (ht.lt.-179.999999d0) ht=-179.999999d0
      if (ht.gt.179.999999d0) ht=179.999999d0

      return
      end 
********************************************************************** 
@


4.11
log
@removed some unnecessary dynamic_casts and fixed problems with self-interactions
@
text
@a17 1

a697 2
c$$$c     Verified that this sums to zero
c$$$      write(6,*) 'elp forcesum = ',sumf
a852 2
c$$$c     Verified that this sums to zero
c$$$      write(6,*) 'eb forcesum = ',sumf
d883 3
a885 2
      if ((qa(j1).eq.'C '.and.qa(j2).eq.'O ').or.
     $(qa(j1).eq.'O '.and.qa(j2).eq.'C ')) then
a931 2
c$$$c     Verified that this sums to zero
c$$$      write(6,*) 'eb2 forcesum = ',sumf
a981 2
c$$$c     Verified that this sums to zero
c$$$      write(6,*) 'eb3 forcesum = ',sumf
a1031 2
c$$$c     Verified that this sums to zero
c$$$      write(6,*) 'eb4 forcesum = ',sumf
d1058 1
a1058 1
      endif
a1201 2
c$$$c     Verified that this sums to zero
c$$$      write(6,*) 'ea forcesum = ',sumf
a1263 2
c$$$c     Verified that this sums to zero
c$$$      write(6,*) 'ea2 forcesum = ',sumf
a1314 2
c$$$c     Verified that this sums to zero
c$$$      write(6,*) 'ea3 forcesum = ',sumf
a1406 2
c$$$c     Verified that this sums to zero
c$$$      write(6,*) 'ea4 forcesum = ',sumf
a1470 2
c$$$c     Verified that this sums to zero
c$$$      write(6,*) 'ea5 forcesum = ',sumf
a1522 2
c$$$c     Verified that this sums to zero
c$$$      write(6,*) 'ea6 forcesum = ',sumf
a1608 2
c$$$c     Not yet verified that this sums to zero
c$$$      write(6,*) 'elp2 forcesum = ',sumf
a1659 2
c$$$c     Not yet verified that this sums to zero
c$$$      write(6,*) 'elp3 forcesum = ',sumf
a1787 2
c$$$c     Not yet verified that this sums to zero
c$$$      write(6,*) 'emol forcesum = ',sumf
a2081 2
c$$$c     Verified that this sums to zero
c$$$      write(6,*) 'eval forcesum = ',sumf
a2128 2
c$$$c     Verified that this sums to zero
c$$$      write(6,*) 'eval2 forcesum = ',sumf
a2175 2
c$$$c     Verified that this sums to zero
c$$$      write(6,*) 'eval3 forcesum = ',sumf
a2230 2
c$$$c     Verified that this sums to zero
c$$$      write(6,*) 'eval4 forcesum = ',sumf
a2284 2
c$$$c     Verified that this sums to zero
c$$$      write(6,*) 'eval5 forcesum = ',sumf
a2338 2
c$$$c     Verified that this sums to zero
c$$$      write(6,*) 'eval6 forcesum = ',sumf
a2392 2
c$$$c     Verified that this sums to zero
c$$$      write(6,*) 'eval7 forcesum = ',sumf
a2512 2
c$$$c     Verified that this sums to zero
c$$$      write(6,*) 'ehb forcesum = ',sumf
a2557 2
c$$$c     Verified that this sums to zero
c$$$      write(6,*) 'ehb2 forcesum = ',sumf
a2603 2
c$$$c     Verified that this sums to zero
c$$$      write(6,*) 'ehb3 forcesum = ',sumf
a2807 2
      estrain(j(2))=estrain(j(2))+0.50*eth
      estrain(j(3))=estrain(j(3))+0.50*eth
a2962 2
c$$$c     Verified that this sums to zero
c$$$      write(6,*) 'etor forcesum = ',sumf
a3008 2
c$$$c     Verified that this sums to zero
c$$$      write(6,*) 'etor2 forcesum = ',sumf
a3055 2
c$$$c     Verified that this sums to zero
c$$$      write(6,*) 'etor3 forcesum = ',sumf
a3101 2
c$$$c     Verified that this sums to zero
c$$$      write(6,*) 'etor4 forcesum = ',sumf
a3152 2
c$$$c     Verified that this sums to zero
c$$$      write(6,*) 'etor5 forcesum = ',sumf
d3207 1
a3207 2
c$$$c     Verified that this sums to zero
c$$$      write(6,*) 'etor6 forcesum = ',sumf
a3372 2
c$$$c     Verified that this sums to zero
c$$$      write(6,*) 'enonbon forcesum = ',sumf
a3971 1
********************************************************************** 
@


4.10
log
@Implemented midpoint method for ReaxFF
@
text
@d792 13
a804 5
c     are local or else flip a coin
      if ((j1 .le. na_local)) then
      if ((j2 .le. na_local) .or. 
     $     (itag(j1) .lt. itag(j2))) then

a1069 12
C This is a sanity test
      else

         if (j2 .le. na_local) then
            write(6,*) 'Ooops!'
            stop
         endif

      endif

      endif

@


4.9
log
@Fixed some FORTRAN lapses and changed dump timestep to write timestep
@
text
@d3321 1
d3351 3
a3354 1
      if (i1 .le. na_local) then
a3356 6

c     Only compute interaction if both atoms
c     are local or else flip a coin
      if ((i2 .le. na_local) .or. 
     $     (itag(i1) .lt. itag(i2))) then

a3465 2
      endif

@


4.8
log
@Added nstep_prev command.
@
text
@d100 6
a105 6
      if (ndebug.eq.1) then
C      open (65,file='fort.65',status='unknown',access='append')
      write (65,*) 'In calval'
      call timer(65)
      close (65)
      end if
d222 6
a227 6
      if (ndebug.eq.1) then
C      open (65,file='fort.65',status='unknown',access='append')
      write (65,*) 'In boncor'
      call timer(65)
      close (65)
      end if
d613 6
a618 6
      if (ndebug.eq.1) then
C      open (65,file='fort.65',status='unknown',access='append')
      write (65,*) 'In lonpar'
      call timer(65)
      close (65)
      end if
d765 6
a770 6
      if (ndebug.eq.1) then
C      open (65,file='fort.65',status='unknown',access='append')
      write (65,*) 'In covbon'
      call timer(65)
      close (65)
      end if
d778 5
a782 5
      if (ndebug.eq.1) then
C      open (65,file='fort.65',status='unknown',access='append')
      write(65,*) 'Bond forces'
      write(65,*) 'nbon = ',nbon
      endif
a822 4
      if (ndebug.eq.1) then
         write(65,*) 'debdbo = ',debdbo,idbo1(i1)
      endif

a1075 4
      if (ndebug.eq.1) then
      close (65)
      endif

d1112 6
a1117 6
      if (ndebug.eq.1) then
C      open (65,file='fort.65',status='unknown',access='append')
      write (65,*) 'In ovcor'
      call timer(65)
      close (65)
      end if
d1751 6
a1756 6
      if (ndebug.eq.1) then
C      open (65,file='fort.65',status='unknown',access='append')
      write (65,*) 'In molen'
      call timer(65)
      close (65)
      end if
d1889 6
a1894 6
      if (ndebug.eq.1) then
C      open (65,file='fort.65',status='unknown',access='append')
      write (65,*) 'In valang'
      call timer(65)
      close (65)
      end if
d2497 6
a2502 6
      if (ndebug.eq.1) then
C      open (65,file='fort.65',status='unknown',access='append')
      write (65,*) 'In hbond'
      call timer(65)
      close (65)
      end if
d2728 6
a2733 6
      if (ndebug.eq.1) then
C      open (65,file='fort.65',status='unknown',access='append')
      write (65,*) 'In torang'
      call timer(65)
      close (65)
      end if
d3332 5
a3336 5
      if (ndebug.eq.1) then
C      open (65,file='fort.65',status='unknown',access='append')
      write (65,*) 'In nonbon'
      call timer(65)
      end if
a3472 7
      if (ndebug.eq.1) then
      write (65,*) 'nptmp = ',nptmp
      write (65,*) 'nstmp = ',nstmp
      call timer(65)
      close (65)
      end if

d3492 6
a3497 6
      if (ndebug.eq.1) then
C      open (65,file='fort.65',status='unknown',access='append')
      write (65,*) 'In efield'
      call timer(65)
      close (65)
      end if
d3571 6
a3576 6
      if (ndebug.eq.1) then
C      open (65,file='fort.65',status='unknown',access='append')
      write (65,*) 'In restraint'
      call timer(65)
      close (65)
      end if
a3768 1
      write (65,'(i6,6f12.4)')mdstep,distot,eres
d3791 6
a3796 6
*     if (ndebug.eq.1) then
C*     open (65,file='fort.65',status='unknown',access='append')
*     write (65,*) 'In calvalres'
*     call timer(65)
*     close (65)
*     end if
d3878 6
a3883 6
*     if (ndebug.eq.1) then
*     open (65,file='fort.65',status='unknown',access='append')
*     write (65,*) 'In calvalhb'
*     call timer(65)
*     close (65)
*     end if
d3969 6
a3974 6
      if (ndebug.eq.1) then
C      open (65,file='fort.65',status='unknown',access='append')
      write (65,*) 'In caltor'
      call timer(65)
      close (65)
      end if
@


4.7
log
@Upgraded ReaxFF in Grasp to latest version
@
text
@d718 1
a718 1
                  atomvirial(k1,ihu) = atomvirial(k1,ihu) + vtmp;
d871 1
a871 1
                  atomvirial(k1,ihu) = atomvirial(k1,ihu) + vtmp;
d951 1
a951 1
                  atomvirial(k1,ihu) = atomvirial(k1,ihu) + vtmp;
d1003 1
a1003 1
                  atomvirial(k1,ihu) = atomvirial(k1,ihu) + vtmp;
d1055 1
a1055 1
                  atomvirial(k1,ihu) = atomvirial(k1,ihu) + vtmp;
d1243 1
a1243 1
                  atomvirial(k1,ihu) = atomvirial(k1,ihu) + vtmp;
d1307 1
a1307 1
                  atomvirial(k1,ihu) = atomvirial(k1,ihu) + vtmp;
d1360 1
a1360 1
                  atomvirial(k1,ihu) = atomvirial(k1,ihu) + vtmp;
d1454 1
a1454 1
                  atomvirial(k1,ihu) = atomvirial(k1,ihu) + vtmp;
d1520 1
a1520 1
                  atomvirial(k1,ihu) = atomvirial(k1,ihu) + vtmp;
d1574 1
a1574 1
                  atomvirial(k1,ihu) = atomvirial(k1,ihu) + vtmp;
d1662 1
a1662 1
                  atomvirial(k1,ihu) = atomvirial(k1,ihu) + vtmp;
d1715 1
a1715 1
                  atomvirial(k1,ihu) = atomvirial(k1,ihu) + vtmp;
d1845 1
a1845 1
                  atomvirial(k1,ihu) = atomvirial(k1,ihu) + vtmp;
d2141 1
a2141 1
                  atomvirial(k1,ihu) = atomvirial(k1,ihu) + vtmp;
d2190 1
a2190 1
                  atomvirial(k1,ihu) = atomvirial(k1,ihu) + vtmp;
d2239 1
a2239 1
                  atomvirial(k1,ihu) = atomvirial(k1,ihu) + vtmp;
d2296 1
a2296 1
                  atomvirial(k1,ihu) = atomvirial(k1,ihu) + vtmp;
d2352 1
a2352 1
                  atomvirial(k1,ihu) = atomvirial(k1,ihu) + vtmp;
d2408 1
a2408 1
                  atomvirial(k1,ihu) = atomvirial(k1,ihu) + vtmp;
d2464 1
a2464 1
                  atomvirial(k1,ihu) = atomvirial(k1,ihu) + vtmp;
d2585 1
a2585 1
               atomvirial(k1,ihu) = atomvirial(k1,ihu) + vtmp;
d2587 1
a2587 1
               atomvirial(k1,ihu) = atomvirial(k1,ihu) + vtmp;
d2633 1
a2633 1
                  atomvirial(k1,ihu) = atomvirial(k1,ihu) + vtmp;
d2681 1
a2681 1
                  atomvirial(k1,ihu) = atomvirial(k1,ihu) + vtmp;
d3044 1
a3044 1
                  atomvirial(k1,ihu) = atomvirial(k1,ihu) + vtmp;
d3092 1
a3092 1
                  atomvirial(k1,ihu) = atomvirial(k1,ihu) + vtmp;
d3141 1
a3141 1
                  atomvirial(k1,ihu) = atomvirial(k1,ihu) + vtmp;
d3189 1
a3189 1
                  atomvirial(k1,ihu) = atomvirial(k1,ihu) + vtmp;
d3242 1
a3242 1
                  atomvirial(k1,ihu) = atomvirial(k1,ihu) + vtmp;
d3298 1
a3298 1
                  atomvirial(k1,ihu) = atomvirial(k1,ihu) + vtmp;
d3467 1
a3467 1
               atomvirial(k1,ihu) = atomvirial(k1,ihu) + vtmp;
d3469 1
a3469 1
               atomvirial(k1,ihu) = atomvirial(k1,ihu) + vtmp;
@


4.6
log
@Added atom energy and bonding output for ReaxFF
@
text
@d142 2
a143 8
*     call dista2(j(2),j(1),dis,a(1),a(2),a(3))
*     call dista2(j(2),j(3),dis,b(1),b(2),b(3))
      a(1)=c(j(2),1)-c(j(1),1)
      a(2)=c(j(2),2)-c(j(1),2)
      a(3)=c(j(2),3)-c(j(1),3)
      b(1)=c(j(2),1)-c(j(3),1)
      b(2)=c(j(2),2)-c(j(3),2)
      b(3)=c(j(2),3)-c(j(3),3)
d412 4
a415 2
      huli=((1.0/ovc(ibt))*aval(iti)+exp11+exp21)
      hulj=((1.0/ovc(ibt))*aval(itj)+exp11+exp21)
d447 4
a450 2
      exphu3=v13cor(ibt)*exp(-vp132*cor1+vp133)
      exphu4=v13cor(ibt)*exp(-vp132*cor2+vp133)
d755 1
d880 1
a880 1
*     Stabilisation terminal triple bond                             *
d883 3
a885 1
      if (boa.lt.1.50.or.abs(vpar(11)).lt.0.01) goto 20
d1076 2
d1134 1
d1884 1
d1966 6
a1971 4
      expvlp=exp(-vpar(16)*(2.0+exlp)*(2.0+exlp))
      vlpadj=expvlp-int(exlp1/2.0)
      dsbo2dvlp=(1.0-vmbo)*(1.0-vpar(34)*2.0*
     $(2.0+exlp)*vpar(16)*expvlp)
a1975 1
*     sbo2=sbo2-exbo-vpar(34)*vlpadj
d2000 1
d2035 1
a2035 1
*    $vlp(j(2)),exbo,vlpadj,vmbo,evh,ev
a2048 1
      ecoah=vkap(ity)*ecsboadj*exphu1*exphu2
d2050 5
a2054 2
      ecoa=ecoa+ecoah
      estrain(j(2))=estrain(j(2))+ecoah !central atom energy
a2055 2
      decoadboa=-2.0*vpar(20)*ecoah*(boa-2.0)
      decoadbob=-2.0*vpar(20)*ecoah*(bob-2.0)
d2064 3
a2066 1
      ovb=abo(j(2))-valf(ia(j(2),1))
a2515 2
c$$$* Only need to compute bonds where j(2) is local
c$$$      if (j(2) .le. na_local) then
d2523 1
a2523 1
      call calvalres (j(1),j(2),j(3),arg,hhb(i1),dvdc,dargdc)
d2729 1
a2729 1
      dimension j(4)
d2770 2
a2771 2
      ld=it(i1,9)
      le=it(i1,10)
d2787 1
a2787 4
      a(1)=c(j(1),1)-c(j(4),1)
      a(2)=c(j(1),2)-c(j(4),2)
      a(3)=c(j(1),3)-c(j(4),3)
      r4=sqrt(a(1)*a(1)+a(2)*a(2)+a(3)*a(3))
d2797 4
a2800 4
      coshd=cos(h(ld))
      coshe=cos(h(le))
      sinhd=sin(h(ld))
      sinhe=sin(h(le))
d2805 1
a2805 1
*     if (poem.lt.1e-20) poem=1e-20
a2844 2
*     exbo1=abo(j(2))-aval(ia(j(2),1))
*     exbo2=abo(j(3))-aval(ia(j(3),1))
a2853 3
      bta=boa
      btb=bob
*     btb2=bob-1.0+etboadj
a2854 2
      btc=boc
*     bo2t=2.0-btb2
a2856 2
*     bo12=(2.0-bta)*(2.0-bta)
*     bo32=(2.0-btc)*(2.0-btc)
a2857 1
*     bocort=bocor1+bocor2+bocor3
d2863 3
a2865 3
      exphua=exp(-vpar(24)*bta)
      exphub=exp(-vpar(24)*btb)
      exphuc=exp(-vpar(24)*btc)
d2868 2
d2876 1
a2876 3
      detdboa=vpar(24)*exphua*(1.0-exphub)*
     $(1.0-exphuc)*ethhulp*hsin
*    $-bocor4*2.0*(2.0-bta)*v2(ity)*v4(ity)*bocor1*(1.0-arg2)*hsin
a2880 1
*     detdbob=detdbob1+detdbob2
a2882 1
*    $-bocor4*2.0*(2.0-btc)*v2(ity)*v4(ity)*bocor3*(1.0-arg2)*hsin
d2964 8
a2971 3
      DO K1=1,3
      DHDDC(K1,2)=DHDC(LD,K1,2)
      DHEDC(K1,3)=DHDC(LE,K1,2)
d2973 11
a2983 22
      IF (j(1).EQ.IV(LD,2)) THEN
      DO K1=1,3
      DHDDC(K1,1)=DHDC(LD,K1,1)
      DHDDC(K1,3)=DHDC(LD,K1,3)
      end do
      ELSE
      DO K1=1,3
      DHDDC(K1,1)=DHDC(LD,K1,3)
      DHDDC(K1,3)=DHDC(LD,K1,1)
      end do
      ENDIF
      IF (j(2).EQ.IV(LE,2)) THEN
      DO K1=1,3
      DHEDC(K1,2)=DHDC(LE,K1,1)
      DHEDC(K1,4)=DHDC(LE,K1,3)
      end do
      ELSE
      DO K1=1,3
      DHEDC(K1,2)=DHDC(LE,K1,3)
      DHEDC(K1,4)=DHDC(LE,K1,1)
      end do
      ENDIF
d3368 1
a3368 9
      a(1)=c(i1,1)-c(i2,1)
      a(2)=c(i1,2)-c(i2,2)
      a(3)=c(i1,3)-c(i2,3)
**********************************************************************
*                                                                    *
*     Construct periodic images for each interaction                 *
*                                                                    *
**********************************************************************
      rr=sqrt(a(1)*a(1)+a(2)*a(2)+a(3)*a(3))
d3522 1
a3523 1
      c1c=332.0638       !Coulomb energy conversion
d3798 1
d3879 87
@


4.5
log
@Merged ReverseComm_branch back into main branch
@
text
@d666 1
d821 2
d898 2
d1183 1
d1391 1
d1615 1
a1615 1

d2023 1
d2045 1
d2085 1
d2525 1
d2897 2
d2926 2
d3441 2
d3551 2
d3562 2
d3573 2
@


4.4
log
@Added some new barostats and thermostats.
@
text
@d210 1
d603 1
d614 1
d655 2
d665 1
a665 3
      if (i1 .le. na_local) then
         elp=elp+elph
      endif
a673 1
      if (icpres.eq.0) then
d677 9
d689 9
a697 1
      d(k1,ihu)=d(k1,ihu)+delpdsbo*dbondc(ncubo,k1,i4)
d700 25
d726 1
a726 18
      else
      do i3=1,ia(i1,2)
      iob=ia(i1,2+i3)
      ncubo=nubon2(i1,i3)
      do i4=1,idbo1(ncubo)
      ihu=idbo(ncubo,i4)
c$$$      ix=nmpx(i1,ihu)
c$$$      iy=nmpy(i1,ihu)
c$$$      iz=nmpz(i1,ihu)
c$$$      kcell=14+ix+3*iy+9*iz
      kcell = 14
      do k1=1,3
      dcell(k1,ihu,kcell)=dcell(k1,ihu,kcell)+
     $delpdsbo*dbondc(ncubo,k1,i4)
      end do
      end do
      end do
      end if
d739 1
d759 1
d790 7
d819 1
a819 7
      if (j1 .le. na_local) then
         if (j2 .le. na_local) then
            eb=eb+ebh
         else
            eb=eb+0.5*ebh
         endif
      endif
d824 9
a832 1
      if (icpres.eq.0) then
d836 1
a836 1
      d(k1,ihu)=d(k1,ihu)+debdbo*(dbondc(i1,k1,i2)-dbopindc(i1,k1,i2)-
d840 5
d846 1
a846 1
      end do
a847 13
      else
      do i2=1,idbo1(i1)
      ihu=idbo(i1,i2)
c$$$      ix=nmpx(j1,ihu)
c$$$      iy=nmpy(j1,ihu)
c$$$      iz=nmpz(j1,ihu)
c$$$      kcell=14+ix+3*iy+9*iz
      kcell = 14
      do k1=1,3
      dcell(k1,ihu,kcell)=dcell(k1,ihu,kcell)+debdbo*
     $(dbondc(i1,k1,i2)-dbopindc(i1,k1,i2)-dbopi2ndc(i1,k1,i2))+
     $debdbopi*dbopindc(i1,k1,i2)+
     $debdbopi2*dbopi2ndc(i1,k1,i2)
d850 26
a875 1
      end if
a892 7
      if (j1 .le. na_local) then
         if (j2 .le. na_local) then
            eb=eb+estriph
         else
            eb=eb+0.5*estriph
         endif
      endif
d894 1
d904 7
a910 1
      if (icpres.eq.0) then
d915 9
a923 1
      d(k1,ihu)=d(k1,ihu)+decobdbo*dbondc(i1,k1,i2)
d926 25
d955 9
d967 9
a975 1
      d(k1,ihu)=d(k1,ihu)+decobdboua*dbondc(ncubo,k1,i4)
d978 26
d1009 7
d1019 6
a1024 1
      d(k1,ihu)=d(k1,ihu)+decobdboub*dbondc(ncubo,k1,i4)
d1026 1
a1026 4
      end do
      end do

      else
a1027 10
      do i2=1,idbo1(i1)
      ihu=idbo(i1,i2)
c$$$      ix=nmpx(j1,ihu)
c$$$      iy=nmpy(j1,ihu)
c$$$      iz=nmpz(j1,ihu)
c$$$      kcell=14+ix+3*iy+9*iz
      kcell = 14
      do k1=1,3
      dcell(k1,ihu,kcell)=dcell(k1,ihu,kcell)+
     $decobdbo*dbondc(i1,k1,i2)
d1030 23
d1054 1
a1054 16
      do i3=1,ia(j1,2)
      iob=ia(j1,2+i3)
      ncubo=nubon2(j1,i3)
      do i4=1,idbo1(ncubo)
      ihu=idbo(ncubo,i4)
c$$$      ix=nmpx(j1,ihu)
c$$$      iy=nmpy(j1,ihu)
c$$$      iz=nmpz(j1,ihu)
c$$$      kcell=14+ix+3*iy+9*iz
      kcell = 14
      do k1=1,3
      dcell(k1,ihu,kcell)=dcell(k1,ihu,kcell)+
     $decobdboua*dbondc(ncubo,k1,i4)
      end do
      end do
      end do
a1055 15
      do i3=1,ia(j2,2)
      iob=ia(j2,2+i3)
      ncubo=nubon2(j2,i3)
      do i4=1,idbo1(ncubo)
      ihu=idbo(ncubo,i4)
c$$$      ix=nmpx(j1,ihu)
c$$$      iy=nmpy(j1,ihu)
c$$$      iz=nmpz(j1,ihu)
c$$$      kcell=14+ix+3*iy+9*iz
      kcell = 14
      do k1=1,3
      dcell(k1,ihu,kcell)=dcell(k1,ihu,kcell)+
     $decobdboub*dbondc(ncubo,k1,i4)
      end do
      end do
d1058 1
a1058 15
      end if
********************************************************************** 
*                                                                    *
*     Calculate penalty for lone pairs sharing a bond                *
*                                                                    *
********************************************************************** 
*     elpbh=de2(ibt)*(2.0-boa)*boa*vlp(j1)*vlp(j2)
*     write (65,'(2i4,8f12.4)')j1,j2,boa,vlp(j1),vlp(j2),elpbh
*     delpbdbo=-de2(ibt)*vlp(j1)*vlp(j2)*boa+de2(ibt)*vlp(j1)*
*    $vlp(j2)*(2.0-boa)
*     delpbdvlp1=de2(ibt)*(2.0-boa)*boa*vlp(j2)
*     delpbdvlp2=de2(ibt)*(2.0-boa)*boa*vlp(j1)
*     delpbdsbo1=delpbdvlp1*dvlpdsbo(j1)
*     delpbdsbo2=delpbdvlp2*dvlpdsbo(j2)
*     eb=eb+elpbh
d1060 2
a1061 6
*     do i2=1,idbo1(i1)
*     ihu=idbo(i1,i2)
*     do k1=1,3
*     d(k1,ihu)=d(k1,ihu)+delpbdbo*dbondc(i1,k1,i2)
*     end do
*     end do
d1063 4
a1066 10
*     do i3=1,ia(j1,2)
*     iob=ia(j1,2+i3)
*     ncubo=nubon2(j1,i3)
*     do i4=1,idbo1(ncubo)
*     ihu=idbo(ncubo,i4)
*     do k1=1,3
*     d(k1,ihu)=d(k1,ihu)+delpbdsbo1*dbondc(ncubo,k1,i4)
*     end do
*     end do
*     end do
d1068 1
a1068 10
*     do i3=1,ia(j2,2)
*     iob=ia(j2,2+i3)
*     ncubo=nubon2(j2,i3)
*     do i4=1,idbo1(ncubo)
*     ihu=idbo(ncubo,i4)
*     do k1=1,3
*     d(k1,ihu)=d(k1,ihu)+delpbdsbo2*dbondc(ncubo,k1,i4)
*     end do
*     end do
*     end do
d1111 1
d1127 1
a1127 1
      do 30 i1=1,na
d1177 1
a1177 4
      if (i1 .le. na_local) then
         ea=ea+eah
      endif

a1183 2
      if (icpres.eq.0) then

d1190 9
d1202 1
a1202 1
      d(k1,ihu)=d(k1,ihu)+deadvov1*(1.0+dfvl*vho*dvlpdsbo(i1))*
d1204 8
d1214 26
d1255 8
d1266 1
a1266 1
      d(k1,ihu)=d(k1,ihu)+deadpibo*(dbopindc(nbosa,k1,i4)+
d1268 8
d1278 24
a1306 9
      do i4=1,idbo1(ncubo)
      ihu=idbo(ncubo,i4)
      do k1=1,3
      d(k1,ihu)=d(k1,ihu)+deadvov2*(1.0+dfvl*dvlpdsbo(iat2))*
     $dbondc(ncubo,k1,i4)
      end do
      end do
      endif
      end do
d1308 6
a1315 10
      end do

      else

      do i3=1,ia(i1,2)
      iob=ia(i1,2+i3)
      ncubo=nubon2(i1,i3)
      if (bo(ncubo).gt.0.0) then
      ibt=ib(ncubo,1)
      deadbo=vover(ibt)*de1(ibt)*hulpp*hulpo*vov1
a1317 5
c$$$      ix=nmpx(i1,ihu)
c$$$      iy=nmpy(i1,ihu)
c$$$      iz=nmpz(i1,ihu)
c$$$      kcell=14+ix+3*iy+9*iz
      kcell = 14
d1319 7
a1325 4
      dcell(k1,ihu,kcell)=dcell(k1,ihu,kcell)+deadvov1*
     $(1.0+dfvl*vho*dvlpdsbo(i1))*
     $dbondc(ncubo,k1,i4)+deadbo*dbondc(ncubo,k1,i4)
      end do
a1327 13
      end do

      do i2=1,ia(i1,2)

      iat2=ia(i1,2+i2)
      ity2=ia(iat2,1)
      nbosa=nubon2(i1,i2)
      if (bo(nbosa).gt.0.0) then
      deadvov2=deadvov1*dvov1dsumov*(bopi(nbosa)+bopi2(nbosa))

      voptlp2=0.50*(stlp(ity2)-aval(ity2))
      diffvlp2=dfvl*(voptlp2-vlptemp(iat2))
      deadpibo=deadvov1*dvov1dsumov*(abo(iat2)-aval(ity2)-diffvlp2)
a1328 10
      do i4=1,idbo1(nbosa)
      ihu=idbo(nbosa,i4)
c$$$      ix=nmpx(i1,ihu)
c$$$      iy=nmpy(i1,ihu)
c$$$      iz=nmpz(i1,ihu)
c$$$      kcell=14+ix+3*iy+9*iz
      kcell = 14
      do k1=1,3
      dcell(k1,ihu,kcell)=dcell(k1,ihu,kcell)+deadpibo*
     $(dbopindc(nbosa,k1,i4)+dbopi2ndc(nbosa,k1,i4))
d1331 25
a1356 16
      do i3=1,ia(iat2,2)
      iob=ia(iat2,2+i3)
      ncubo=nubon2(iat2,i3)
      if (bo(ncubo).gt.0.0) then
      do i4=1,idbo1(ncubo)
      ihu=idbo(ncubo,i4)
c$$$      ix=nmpx(i1,ihu)
c$$$      iy=nmpy(i1,ihu)
c$$$      iz=nmpz(i1,ihu)
c$$$      kcell=14+ix+3*iy+9*iz
      kcell = 14
      do k1=1,3
      dcell(k1,ihu,kcell)=dcell(k1,ihu,kcell)+deadvov2*
     $(1.0+dfvl*dvlpdsbo(iat2))*dbondc(ncubo,k1,i4)
      end do
      end do
a1362 1
      end if
d1384 1
a1384 3
      if (i1 .le. na_local) then
         ea=ea+eahu
      endif
a1394 1
      if (icpres.eq.0) then
d1400 9
d1412 1
a1412 1
      d(k1,ihu)=d(k1,ihu)+deaudvov1*(1.0+dfvl*vho*dvlpdsbo(i1))*
d1414 5
d1420 2
d1423 27
d1467 8
d1478 1
a1478 1
      d(k1,ihu)=d(k1,ihu)+deadpibo1*
d1480 8
d1490 25
d1520 9
d1532 1
a1532 1
      d(k1,ihu)=d(k1,ihu)+deadvov2*(1.0+dfvl*dvlpdsbo(iat2))*
d1534 5
d1540 2
d1543 27
a1576 20
      else

      do i3=1,ia(i1,2)
      iob=ia(i1,2+i3)
      ncubo=nubon2(i1,i3)
      if (bo(ncubo).gt.0.0) then
      do i4=1,idbo1(ncubo)
      ihu=idbo(ncubo,i4)
c$$$      ix=nmpx(i1,ihu)
c$$$      iy=nmpy(i1,ihu)
c$$$      iz=nmpz(i1,ihu)
c$$$      kcell=14+ix+3*iy+9*iz
      kcell = 14
      do k1=1,3
      dcell(k1,ihu,kcell)=dcell(k1,ihu,kcell)+deaudvov1*
     $(1.0+dfvl*vho*dvlpdsbo(i1))*dbondc(ncubo,k1,i4)
      end do
      end do
      endif
      end do
d1578 12
a1590 1

d1592 4
a1595 117
      ity2=ia(iat2,1)
      nbosa=nubon2(i1,i2)
      if (bo(nbosa).gt.0.0) then
      deadvov2=(deaudsumov+dvov1dsumov*deaudvov1)*
     $(bopi(nbosa)+bopi2(nbosa))

      voptlp2=0.50*(stlp(ity2)-aval(ity2))
      diffvlp2=dfvl*(voptlp2-vlptemp(iat2))
      deadpibo1=(dvov1dsumov*deaudvov1+deaudsumov)*
     $(abo(iat2)-aval(ity2)-diffvlp2)

      do i4=1,idbo1(nbosa)
      ihu=idbo(nbosa,i4)
c$$$      ix=nmpx(i1,ihu)
c$$$      iy=nmpy(i1,ihu)
c$$$      iz=nmpz(i1,ihu)
c$$$      kcell=14+ix+3*iy+9*iz
      kcell = 14
      do k1=1,3
      dcell(k1,ihu,kcell)=dcell(k1,ihu,kcell)+deadpibo1*
     $(dbopindc(nbosa,k1,i4)+dbopi2ndc(nbosa,k1,i4))
      end do
      end do

      do i3=1,ia(iat2,2)
      iob=ia(iat2,2+i3)
      ncubo=nubon2(iat2,i3)
      if (bo(ncubo).gt.0.0) then
      do i4=1,idbo1(ncubo)
      ihu=idbo(ncubo,i4)
c$$$      ix=nmpx(i1,ihu)
c$$$      iy=nmpy(i1,ihu)
c$$$      iz=nmpz(i1,ihu)
c$$$      kcell=14+ix+3*iy+9*iz
      kcell = 14
      do k1=1,3
      dcell(k1,ihu,kcell)=dcell(k1,ihu,kcell)+deadvov2*
     $(1.0+dfvl*dvlpdsbo(iat2))*dbondc(ncubo,k1,i4)
      end do
      end do
      endif
      end do

      endif

      end do

      end if

   30 continue
 
**********************************************************************
*                                                                    *
*     Calculate correction for MgH                                   *
*                                                                    *
**********************************************************************
*     elp=zero
*     do 39 i1=1,na
*     ity1=ia(i1,1)
*     vov4=abo(i1)-aval(ity1)
*
*     do i2=1,ia(i1,2)
*     iat2=ia(i1,2+i2)
*     nbohu=nubon2(i1,i2)
*
*     ibt=ib(nbohu,1)
*     vc2=vuncor(ibt)
*     elph=zero
*     deahu2dbo=zero
*     deahu2dsbo=zero
*     vov3=bo(nbohu)-vov4-vpar(14)*(vov4**4)
*     if (vov3.gt.1.0) then
*     elph=vc2*(vov3-1.0)*(vov3-1.0)
*     deahu2dbo=2.0*vc2*(vov3-1.0)
*     deahu2dsbo=2.0*vc2*(vov3-1.0)*(-1.0-
*    $4.0*vpar(14)*(vov4**3))
*     end if
*
*     elp=elp+elph
*
*     do i3=1,idbo1(nbohu)
*     ihu=idbo(nbohu,i3)
*     do k1=1,3
*     d(k1,ihu)=d(k1,ihu)+deahu2dbo*dbondc(nbohu,k1,i3)
*     end do
*     end do
*
*     do i3=1,ia(i1,2)
*     iob=ia(i1,2+i3)
*     ncubo=nubon2(i1,i3)
*     do i4=1,idbo1(ncubo)
*     ihu=idbo(ncubo,i4)
*     do k1=1,3
*     d(k1,ihu)=d(k1,ihu)+deahu2dsbo*dbondc(ncubo,k1,i4)
*     end do
*     end do
*     end do
*
*     end do
*
*  39 continue
**********************************************************************
*                                                                    *
*     Calculate correction for C2                                    *
*                                                                    *
**********************************************************************
      if (abs(vpar(6)).gt.0.001) then
      do 40 i1=1,na
      ity1=ia(i1,1)
      vov4=abo(i1)-aval(ity1)
 
      do i2=1,ia(i1,2)
      iat2=ia(i1,2+i2)
      nbohu=nubon2(i1,i2)
      if (bo(nbohu).gt.0.0) then
 
      ibt=ib(nbohu,1)
d1607 9
a1615 2
      if (i1 .le. na_local) then
         elp=elp+elph
a1617 1
      if (icpres.eq.0) then
d1621 9
a1629 1
      d(k1,ihu)=d(k1,ihu)+deahu2dbo*dbondc(nbohu,k1,i3)
d1632 26
a1657 1
 
d1662 9
d1674 6
a1679 2
      d(k1,ihu)=d(k1,ihu)+deahu2dsbo*dbondc(ncubo,k1,i4)
      end do
a1681 1
      end do
a1682 29
      else

      do i3=1,idbo1(nbohu)
      ihu=idbo(nbohu,i3)
c$$$      ix=nmpx(i1,ihu)
c$$$      iy=nmpy(i1,ihu)
c$$$      iz=nmpz(i1,ihu)
c$$$      kcell=14+ix+3*iy+9*iz
      kcell = 14
      do k1=1,3
      dcell(k1,ihu,kcell)=dcell(k1,ihu,kcell)+
     $deahu2dbo*dbondc(nbohu,k1,i3)
      end do
      end do
 
      do i3=1,ia(i1,2)
      iob=ia(i1,2+i3)
      ncubo=nubon2(i1,i3)
      if (bo(ncubo).gt.0.0) then
      do i4=1,idbo1(ncubo)
      ihu=idbo(ncubo,i4)
c$$$      ix=nmpx(i1,ihu)
c$$$      iy=nmpy(i1,ihu)
c$$$      iz=nmpz(i1,ihu)
c$$$      kcell=14+ix+3*iy+9*iz
      kcell = 14
      do k1=1,3
      dcell(k1,ihu,kcell)=dcell(k1,ihu,kcell)+
     $deahu2dsbo*dbondc(ncubo,k1,i4)
d1685 24
d1710 2
a1714 3
 
      endif

d1731 1
d1741 1
a1741 1

d1792 9
d1804 9
a1812 1
      d(k1,ihu)=d(k1,ihu)+demoldsbo*dbondc(ncubo,k1,i4)
d1815 26
d1862 1
d1879 1
d1902 2
d2036 1
a2036 3
      if (j(2) .le. na_local) then
         ecoa=ecoa+ecoah
      endif
d2075 1
a2075 3
      if (j(2) .le. na_local) then
         ecoa=ecoa+ecoah
      endif
d2082 7
a2088 1
      if (icpres.eq.0) then
d2092 6
a2097 1
      d(k1,j(k2))=d(k1,j(k2))+devdh*dhdc(i1,k1,k2)
d2099 2
d2102 35
a2136 1
 
d2140 1
a2140 1
      d(k1,ihu)=d(k1,ihu)+(devdla+decoadboa+decodbola)*
d2142 5
d2148 2
d2151 35
a2185 1
 
d2189 1
a2189 1
      d(k1,ihu)=d(k1,ihu)+(devdlb+decoadbob+decodbolb)*
d2191 5
d2197 2
d2200 27
a2226 1
 
d2232 9
d2244 1
a2244 1
      d(k1,ihu)=d(k1,ihu)+(-dsbo2dvlp*devdsbo+devdsbo2+decdsbo2
d2248 8
d2258 26
d2291 9
d2303 6
a2308 1
      d(k1,ihu)=d(k1,ihu)+decodboua*dbondc(ibv,k1,i3)
d2310 2
d2313 27
d2347 7
a2353 6
      do i3=1,idbo1(ibv)
      ihu=idbo(ibv,i3)
      do k1=1,3
      d(k1,ihu)=d(k1,ihu)+decodboob*dbondc(ibv,k1,i3)
      end do
      end do
a2354 1
      end do
a2355 4
      do i2=1,ia(j(3),2)
      j5=ia(j(3),2+i2)
      ibv=nubon2(j(3),i2)
      if (bo(ibv).gt.0.0) then
d2359 6
a2364 2
      d(k1,ihu)=d(k1,ihu)+decodbouc*dbondc(ibv,k1,i3)
      end do
a2366 3
      end do

      else
a2367 8
      do k1=1,3
      do k2=1,3
c$$$      ix=nmpx(j(2),j(k2))
c$$$      iy=nmpy(j(2),j(k2))
c$$$      iz=nmpz(j(2),j(k2))
c$$$      kcell=14+ix+3*iy+9*iz
      kcell = 14
      dcell(k1,j(k2),kcell)=dcell(k1,j(k2),kcell)+devdh*dhdc(i1,k1,k2)
d2370 23
d2394 1
a2394 12
      do i2=1,idbo1(la)
      ihu=idbo(la,i2)
c$$$      ix=nmpx(j(2),ihu)
c$$$      iy=nmpy(j(2),ihu)
c$$$      iz=nmpz(j(2),ihu)
c$$$      kcell=14+ix+3*iy+9*iz
      kcell = 14
      do k1=1,3
      dcell(k1,ihu,kcell)=dcell(k1,ihu,kcell)+
     $(devdla+decoadboa+decodbola)*dbondc(la,k1,i2)
      end do
      end do
d2396 1
a2396 11
      do i2=1,idbo1(lb)
      ihu=idbo(lb,i2)
c$$$      ix=nmpx(j(2),ihu)
c$$$      iy=nmpy(j(2),ihu)
c$$$      iz=nmpz(j(2),ihu)
c$$$      kcell=14+ix+3*iy+9*iz
      kcell = 14
      do k1=1,3
      dcell(k1,ihu,kcell)=dcell(k1,ihu,kcell)+
     $(devdlb+decoadbob+decodbolb)*dbondc(lb,k1,i2)
      end do
d2399 3
a2401 3
      do i2=1,nbocen
      j5=ia(j(2),2+i2)
      ibv=nubon2(j(2),i2)
d2403 7
a2409 16
      dvmbodbo=-vmbo*8.0*bo(ibv)**7
      do i3=1,idbo1(ibv)
      ihu=idbo(ibv,i3)
c$$$      ix=nmpx(j(2),ihu)
c$$$      iy=nmpy(j(2),ihu)
c$$$      iz=nmpz(j(2),ihu)
c$$$      kcell=14+ix+3*iy+9*iz
      kcell = 14
      do k1=1,3
      dcell(k1,ihu,kcell)=dcell(k1,ihu,kcell)+
     $(-dsbo2dvlp*devdsbo+devdsbo2+decdsbo2+
     $dvmbodbo*dsbo2dvmbo*devdsbo)*
     $dbondc(ibv,k1,i3)+devdsbo*(dbopindc(ibv,k1,i3)+
     $dbopi2ndc(ibv,k1,i3))
      end do
      end do
a2410 1
      end do
a2411 4
      do i2=1,ia(j(1),2)
      j5=ia(j(1),2+i2)
      ibv=nubon2(j(1),i2)
      if (bo(ibv).gt.0.0) then
a2413 5
c$$$      ix=nmpx(j(2),ihu)
c$$$      iy=nmpy(j(2),ihu)
c$$$      iz=nmpz(j(2),ihu)
c$$$      kcell=14+ix+3*iy+9*iz
      kcell = 14
d2415 6
a2420 3
      dcell(k1,ihu,kcell)=dcell(k1,ihu,kcell)+
     $decodboua*dbondc(ibv,k1,i3)
      end do
a2422 1
      end do
a2423 14
      do i2=1,ia(j(2),2)
      j5=ia(j(2),2+i2)
      ibv=nubon2(j(2),i2)
      if (bo(ibv).gt.0.0) then
      do i3=1,idbo1(ibv)
      ihu=idbo(ibv,i3)
c$$$      ix=nmpx(j(2),ihu)
c$$$      iy=nmpy(j(2),ihu)
c$$$      iz=nmpz(j(2),ihu)
c$$$      kcell=14+ix+3*iy+9*iz
      kcell = 14
      do k1=1,3
      dcell(k1,ihu,kcell)=dcell(k1,ihu,kcell)+
     $decodboob*dbondc(ibv,k1,i3)
d2426 24
a2450 1
      end do
a2451 16
      do i2=1,ia(j(3),2)
      j5=ia(j(3),2+i2)
      ibv=nubon2(j(3),i2)
      if (bo(ibv).gt.0.0) then
      do i3=1,idbo1(ibv)
      ihu=idbo(ibv,i3)
c$$$      ix=nmpx(j(2),ihu)
c$$$      iy=nmpy(j(2),ihu)
c$$$      iz=nmpz(j(2),ihu)
c$$$      kcell=14+ix+3*iy+9*iz
      kcell = 14
      do k1=1,3
      dcell(k1,ihu,kcell)=dcell(k1,ihu,kcell)+
     $decodbouc*dbondc(ibv,k1,i3)
      end do
      end do
d2455 1
a2455 1
      end if
d2470 1
d2480 1
a2480 4
      virial=zero
      virx=zero
      viry=zero
      virz=zero
d2497 2
d2514 1
a2514 3
      if (j(2) .le. na_local) then
            ehb=ehb+ehbh
      endif
a2515 3
*     write (65,'(6i4,10f12.4)')i1,ityhb,j(1),j(2),j(3),la,boa,rda,
*    $rdndgr*hhb(i1),1.0-exphu1,exphu2,sin2*sin2,
*    $ehbh,ehb
d2528 7
a2534 1
      if (icpres.eq.0) then
d2537 11
a2547 2
      d(k1,j(2))=d(k1,j(2))+dehbdrda*drda(k1)
      d(k1,j(3))=d(k1,j(3))-dehbdrda*drda(k1)
d2549 34
a2582 1
 
d2585 6
a2590 1
      d(k1,j(k2))=d(k1,j(k2))+dehbdv*dvdc(k1,k2)
d2592 2
a2593 6
      end do
 
      do i2=1,idbo1(la)
      ihu=idbo(la,i2)
      do k1=1,3
      d(k1,ihu)=d(k1,ihu)+dehbdbo*dbondc(la,k1,i2)
d2596 25
d2622 7
a2628 1
      else
a2629 21
c$$$      ix=nmpx(j(2),j(3))
c$$$      iy=nmpy(j(2),j(3))
c$$$      iz=nmpz(j(2),j(3))
c$$$      kcell=14+ix+3*iy+9*iz
      kcell = 14
      do k1=1,3
      dcell(k1,j(2),kcell)=dcell(k1,j(2),kcell)+dehbdrda*drda(k1)
      dcell(k1,j(3),kcell)=dcell(k1,j(3),kcell)-dehbdrda*drda(k1)
      end do
     
      do k1=1,3
      do k2=1,3
c$$$      ix=nmpx(j(2),j(k2))
c$$$      iy=nmpy(j(2),j(k2))
c$$$      iz=nmpz(j(2),j(k2))
c$$$      kcell=14+ix+3*iy+9*iz
      kcell = 14
      dcell(k1,j(k2),kcell)=dcell(k1,j(k2),kcell)+dehbdv*dvdc(k1,k2)
      end do
      end do
  
a2631 5
c$$$      ix=nmpx(j(2),ihu)
c$$$      iy=nmpy(j(2),ihu)
c$$$      iz=nmpz(j(2),ihu)
c$$$      kcell=14+ix+3*iy+9*iz
      kcell = 14
d2633 9
a2641 2
      dcell(k1,ihu,kcell)=dcell(k1,ihu,kcell)+
     $dehbdbo*dbondc(la,k1,i2)
d2644 23
d2668 1
a2668 1
      end if
a2669 1
   
d2712 1
d2747 1
a2772 12
*     call dista2(j(1),j(4),r4h,a1h,a2h,a3h)
*     if (abs(r4h-r4).gt.0.01) then
*     write (64,'(5i4,10f12.4)')j(1),j(4),
*    $ix1,iy1,iz1,r4,a(1),a(2),a(3),r4h,a1h,a2h,a3h
*     write (64,'(6f12.4)')c(j(1),1),c(j(1),2),c(j(1),3)
*     write (64,'(6f12.4)')c(j(2),1),c(j(2),2),c(j(2),3)
*     write (64,'(6f12.4)')c(j(3),1),c(j(3),2),c(j(3),3)
*     write (64,'(6f12.4)')c(j(4),1),c(j(4),2),c(j(4),3)
*     write (64,'(4i4)')nvlx(ivl1),nvly(ivl1),nvlz(ivl1),isign1
*     write (64,'(4i4)')nvlx(ivl2),nvly(ivl2),nvlz(ivl2),isign2
*     write (64,'(4i4)')nvlx(ivl3),nvly(ivl3),nvlz(ivl3),isign3
*     end if
d2885 1
a2885 9
      if (j(2) .le. na_local) then
         if (j(3) .le. na_local) then
            et=et+eth
         else
            et=et+0.5*eth
         endif
      else if (j(3) .le. na_local) then
         et=et+0.5*eth
      endif
a2886 5
*     if ((j(2).eq.1.and.j(3).eq.2).or.(j(2).eq.2.and.j(3).eq.1)) then
*     eth12=eth12+eth
*     write (64,'(4i4,20f12.4)')j(1),j(2),j(3),j(4),eth12,eth,et,
*    $thg(i1)
*     end if
d2912 1
a2912 9
      if (j(2) .le. na_local) then
         if (j(3) .le. na_local) then
            eco=eco+ecoh
         else
            eco=eco+0.5*ecoh
         endif
      else if (j(3) .le. na_local) then
         eco=eco+0.5*ecoh
      endif
d2993 7
a2999 1
      if (icpres.eq.0) then
d3011 1
a3011 1
      D(K1,J(K2))=D(K1,J(K2))+DARGTDC(i1,K1,K2)*detdar+
d3014 5
d3020 2
d3023 35
a3057 1
 
d3061 9
a3069 1
      d(k1,ihu)=d(k1,ihu)+dbondc(la,k1,i2)*(detdboa+decodbola)
d3072 34
a3105 1
 
d3109 10
a3118 2
      d(k1,ihu)=d(k1,ihu)+dbondc(lb,k1,i2)*(detdbob+decodbolb)
      d(k1,ihu)=d(k1,ihu)+dbopindc(lb,k1,i2)*detdbopib
d3121 34
a3154 1
 
d3158 6
a3163 1
      d(k1,ihu)=d(k1,ihu)+dbondc(lc,k1,i2)*(detdboc+decodbolc)
d3165 2
d3168 27
a3194 1
 
d3199 9
d3211 9
a3219 1
      d(k1,ihu)=d(k1,ihu)+detdsbo1*dbondc(ncubo,k1,i3)
d3222 26
d3255 9
d3267 6
a3272 2
      d(k1,ihu)=d(k1,ihu)+detdsbo1*dbondc(ncubo,k1,i3)
      end do
a3274 24
      end do

      else

      DO  K1=1,3
      DRDA(K1)=A(K1)/R4
      DO  K2=1,4
      DRVDC(K1,K2)=DRDA(K1)*DADC(K2)
      DTDC(K1,K2)=2.0*(DRADC(K1,K2)*HTRA+DRBDC(K1,K2)*HTRB+DRCDC(K1,K2
     $)*HTRC-DRVDC(K1,K2)*R4+DHDDC(K1,K2)*HTHD+DHEDC(K1,K2)*HTHE)
      DNDC(K1,K2)=2.0*(DRADC(K1,K2)*HNRA+DRCDC(K1,K2)*HNRC+DHDDC(K1,K2
     $)*HNHD+DHEDC(K1,K2)*HNHE)
      DARGTDC(i1,K1,K2)=(DTDC(K1,K2)-ARG*DNDC(K1,K2))/POEM
c$$$      ix=nmpx(j(2),j(k2))
c$$$      iy=nmpy(j(2),j(k2))
c$$$      iz=nmpz(j(2),j(k2))
c$$$      kcell=14+ix+3*iy+9*iz
      kcell = 14
      dcell(k1,j(k2),kcell)=dcell(k1,j(k2),kcell)
     $+dargtdc(i1,K1,K2)*detdar+
     $dargtdc(i1,k1,k2)*decodar+(detdhd+decodhd)*dhddc(k1,k2)+
     $(detdhe+decodhe)*dhedc(k1,k2)
      end do
      end do
a3275 10
      do i2=1,idbo1(la)  
      ihu=idbo(la,i2)
c$$$      ix=nmpx(j(2),ihu)
c$$$      iy=nmpy(j(2),ihu)
c$$$      iz=nmpz(j(2),ihu)
c$$$      kcell=14+ix+3*iy+9*iz
      kcell = 14
      do k1=1,3
      dcell(k1,ihu,kcell)=dcell(k1,ihu,kcell)+
     $dbondc(la,k1,i2)*(detdboa+decodbola)
d3278 23
a3301 44
      do i2=1,idbo1(lb)  
      ihu=idbo(lb,i2)
c$$$      ix=nmpx(j(2),ihu)
c$$$      iy=nmpy(j(2),ihu)
c$$$      iz=nmpz(j(2),ihu)
c$$$      kcell=14+ix+3*iy+9*iz
      kcell = 14
      do k1=1,3
      dcell(k1,ihu,kcell)=dcell(k1,ihu,kcell)+
     $dbondc(lb,k1,i2)*(detdbob+decodbolb)
      dcell(k1,ihu,kcell)=dcell(k1,ihu,kcell)+
     $dbopindc(lb,k1,i2)*detdbopib
      end do
      end do

      do i2=1,idbo1(lc)  
      ihu=idbo(lc,i2)
c$$$      ix=nmpx(j(2),ihu)
c$$$      iy=nmpy(j(2),ihu)
c$$$      iz=nmpz(j(2),ihu)
c$$$      kcell=14+ix+3*iy+9*iz
      kcell = 14
      do k1=1,3
      dcell(k1,ihu,kcell)=dcell(k1,ihu,kcell)+
     $dbondc(lc,k1,i2)*(detdboc+decodbolc)
      end do
      end do

      do i2=1,ia(j(2),2)
      iob=ia(j(2),2+i2)
      ncubo=nubon2(j(2),i2)
      if (bo(ncubo).gt.0.0) then
      do i3=1,idbo1(ncubo)  
      ihu=idbo(ncubo,i3)
c$$$      ix=nmpx(j(2),ihu)
c$$$      iy=nmpy(j(2),ihu)
c$$$      iz=nmpz(j(2),ihu)
c$$$      kcell=14+ix+3*iy+9*iz
      kcell = 14
      do k1=1,3
      dcell(k1,ihu,kcell)=dcell(k1,ihu,kcell)+
     $detdsbo1*dbondc(ncubo,k1,i3)
      end do
      end do
a3302 1
      end do
a3303 16
      do i2=1,ia(j(3),2)
      iob=ia(j(3),2+i2)
      ncubo=nubon2(j(3),i2)
      if (bo(ncubo).gt.0.0) then
      do i3=1,idbo1(ncubo)  
      ihu=idbo(ncubo,i3)
c$$$      ix=nmpx(j(2),ihu)
c$$$      iy=nmpy(j(2),ihu)
c$$$      iz=nmpz(j(2),ihu)
c$$$      kcell=14+ix+3*iy+9*iz
      kcell = 14
      do k1=1,3
      dcell(k1,ihu,kcell)=dcell(k1,ihu,kcell)+
     $detdsbo1*dbondc(ncubo,k1,i3)
      end do
      end do
a3306 2
      end if

d3333 1
d3360 7
a3376 5
      if (ndebug.eq.1) then
         if (i1.le.21) then
            nptmp = nptmp+1
         endif
      endif
d3424 2
a3425 7
      if (i2 .le. na_local) then
         ew=ew+ewhtap
         ep=ep+ephtap
      else
         ew=ew+0.5*ewhtap
         ep=ep+0.5*ephtap
      endif
a3432 4
      if (icpres.eq.0) then

      do k4=1,3
      d(k4,i1)=d(k4,i1)+(dewdrtap+depdrtap)*(a(k4)/rr)
d3434 6
a3439 2
      if (i2 .le. na_local) then
         d(k4,i2)=d(k4,i2)-(dewdrtap+depdrtap)*(a(k4)/rr)
d3442 10
d3454 23
a3476 1
      else
d3478 1
a3478 7
      kcell=14+ix+3*iy+9*iz
      do k4=1,3
      dcell(k4,i1,14)=dcell(k4,i1,14)+
     $(dewdrtap+depdrtap)*(a(k4)/rr)
      dcell(k4,i2,kcell)=dcell(k4,i2,kcell)-
     $(dewdrtap+depdrtap)*(a(k4)/rr)
      end do
d3480 1
a3480 1
      end if
a3484 74
c$$$**********************************************************************
c$$$*                                                                    *
c$$$*     Add interaction of atoms with the corresponding atom           *
c$$$*     in the surrounding periodic cells                              *
c$$$*                                                                    *
c$$$**********************************************************************
c$$$      do 20 ivl=nvpair-nvlself,nvpair
c$$$      i1=nvl1(ivl)
c$$$      ix=nvlx(ivl)
c$$$      iy=nvly(ivl)
c$$$      iz=nvlz(ivl)
c$$$      kcell=14+ix+3*iy+9*iz
c$$$      a(1)=ix*tm11
c$$$      a(2)=ix*tm21+iy*tm22
c$$$      a(3)=ix*tm31+iy*tm32+iz*tm33
c$$$      rr=sqrt(a(1)*a(1)+a(2)*a(2)+a(3)*a(3))
c$$$
c$$$      if (rr.gt.swb.or.rr.lt.0.001) goto 20
c$$$      nstmp = nstmp+1
c$$$      ity1=ia(i1,1)
c$$$      rr2=rr*rr
c$$$
c$$$      sw=1.0
c$$$      sw1=0.0
c$$$      call taper(rr,rr2)
c$$$**********************************************************************
c$$$*                                                                    *
c$$$*     Calculate vdWaals energy                                       *
c$$$*                                                                    *
c$$$**********************************************************************
c$$$      p1=p1co(ity1,ity1)
c$$$      p2=p2co(ity1,ity1)
c$$$      p3=p3co(ity1,ity1)
c$$$
c$$$      hulpw=(rr**vpar(29)+gamwco(ity1,ity1))
c$$$      rrw=hulpw**(1.0/vpar(29))
c$$$      h1=exp(p3*(1.0-rrw/p1))
c$$$      h2=exp(0.50*p3*(1.0-rrw/p1))
c$$$
c$$$      ewh=0.50*p2*(h1-2.0*h2)
c$$$      rrhuw=rr**(vpar(29)-1.0)
c$$$      dewdr=0.50*(p2*p3/p1)*(h2-h1)*rrhuw*(hulpw**-h15)
c$$$**********************************************************************
c$$$*                                                                    *
c$$$*     Calculate Coulomb energy                                       *
c$$$*                                                                    *
c$$$**********************************************************************
c$$$      q1q2=ch(i1)*ch(i1)
c$$$      hulp1=(rr*rr2+gamcco(ity1,ity1))
c$$$      eph=0.50*c1c*q1q2/(hulp1**third)
c$$$      depdr=-0.50*c1c*q1q2*rr2/(hulp1**fothird)
c$$$**********************************************************************
c$$$*                                                                    *
c$$$*     Taper correction                                               *
c$$$*                                                                    *
c$$$**********************************************************************
c$$$      ephtap=eph*sw
c$$$      depdrtap=depdr*sw+eph*sw1
c$$$      ewhtap=ewh*sw
c$$$      dewdrtap=dewdr*sw+ewh*sw1
c$$$
c$$$      ew=ew+ewhtap
c$$$      ep=ep+ephtap
c$$$
c$$$      if (icpres.eq.1) then
c$$$      do k4=1,3
c$$$      dcell(k4,i1,14)=dcell(k4,i1,14)+
c$$$     $(dewdrtap+depdrtap)*(a(k4)/rr)
c$$$      dcell(k4,i1,kcell)=dcell(k4,i1,kcell)-
c$$$     $(dewdrtap+depdrtap)*(a(k4)/rr)
c$$$      end do
c$$$      end if
c$$$
c$$$   20 continue
a3492 29
**********************************************************************
*                                                                    *
*     Calculate derivatives Coulomb energy to cartesian              *
*     coordinates                                                    *
*                                                                    *
**********************************************************************

*     do i1=1,na
*     do k1=1,3
*     sum=0.0
*     do 20 i2=1,na

*     do 20 i3=i2+1,na
*     if (dqdc(i3,i1,k1).le.zero.and.dqdc(i2,i1,k1).le.zero)
*    $goto 20
*     rr=rrs(i2,i3)
*     ity1=ia(i2,1)
*     ity2=ia(i3,1)
*     gamt=sqrt(gam(ity1)*gam(ity2))
*     hulp1=(rr**3+(1.0/(gamt**3)))
*     depdq1=-c1c*ch(i3)/(hulp1**third)
*     depdq2=-c1c*ch(i2)/(hulp1**third)
*     sum=sum+depdq1*dqdc(i2,i1,k1)+depdq2*dqdc(i3,i1,k1)
*  20 continue
*     d(i1,k1)=d(i1,k1)+sum

*     end do
*     end do

a3562 103
      subroutine radbo

********************************************************************** 
#include "cbka.blk"
#include "control.blk"
      dimension a1(3)
********************************************************************** 
*                                                                    *
*     Calculate radical/double bond energy (to increase reaction     *
*     rates)                                                         *
*                                                                    *
********************************************************************** 
      if (ndebug.eq.1) then
C      open (65,file='fort.65',status='unknown',access='append')
      write (65,*) 'In radbo'
      call timer(65)
      close (65)
      end if
*     eradbo=zero
*     do i1=1,na
*     if (xmasat(i1).gt.2.0) qa(i1)='C '
*     end do
*     nradcount=nradcount+1
*     if (nradcount.lt.nrddf) return
*     if (nradcount.gt.2*nrddf) nradcount=0

*     do i1=1,nmolo5
*     if (elmol(i1).gt.2*int(elmol(i1)*0.50)) then
*     vlpmax=0.0
*     do i2=1,nmolat2(i1,1)
*     eradmin=50.0
*     ihu=nmolat2(i1,i2+1)
*     if (xmasat(ihu).gt.2.0.and.vlp(ihu).gt.zero) then !no H-atoms
*     vlps=vlp(ihu)

*     do 10 i3=1,na
*     if (xmasat(i3).lt.2.0) goto 10       !no H-atoms
*     imol2=iag(i3,3+mbond)
*     if (i1.eq.imol2) goto 10            !no intermolecular reactions
*     bopisum=zero
*     do i4=1,ia(i3,2)
*     ihu2=nubon2(i3,i4)
*     bopisum=bopisum+bopi(ihu2)
*     end do
*     if (bopisum.lt.0.25) goto 10        !only atoms in double bonds
*     dirb1=dista(ihu,i3)
*     hu1=vpar(22)-dirb1
*     expvl=exp(-5.0*vlps)
*     hexp=1.0-expvl
*     if (hu1.ge.zero) then
*     exphu1=exp(-vpar(25)*hu1*hu1)
*     eradboh1=hexp*vpar(24)*exphu1
*     else
*     exphu1=exp(-vpar(26)*hu1*hu1)
*     eradboh1=hexp*vpar(24)*exphu1
*     end if
*     
*     if (eradboh1.lt.eradmin) then
*     i3s=i3
*     disrmin=dirb1
*     eradmin=eradboh1
*     end if

*  10 continue     

*     qa(ihu)='S '
*     qa(i3s)='N '
*     hu1=vpar(22)-disrmin
*     eradboh1=zero
*     expvl=exp(-5.0*vlps)
*     hexp=1.0-expvl
*     if (hu1.ge.zero) then
*     exphu1=exp(-vpar(25)*hu1*hu1)
*     eradboh1=hexp*vpar(24)*exphu1
*     deradbodr1=hexp*vpar(24)*vpar(25)*2.0*hu1*exphu1
*     else
*     exphu1=exp(-vpar(26)*hu1*hu1)
*     eradboh1=hexp*vpar(24)*exphu1
*     deradbodr1=hexp*vpar(24)*vpar(26)*2.0*hu1*exphu1
*     end if
*     eradbo=eradbo+eradboh1

*     a1(1)=dxm(ihu,i3s)
*     a1(2)=dym(ihu,i3s)
*     a1(3)=dzm(ihu,i3s)

*     do k1=1,3
*     d(k1,ihu)=d(k1,ihu)+deradbodr1*(a1(k1)/disrmin)
*     d(k1,i3s)=d(k1,i3s)-deradbodr1*(a1(k1)/disrmin)
*     end do

*     end if
*     end do

*     end if
*     end do


      return
      end
********************************************************************** 
********************************************************************** 

@


4.4.4.1
log
@Reverse comm seems to be working for ReaxFF
@
text
@a209 1
#include "cbkc.blk"
a651 2
      if (i1 .le. na_local) then

d660 3
a662 1
      elp=elp+elph
a700 2
      endif

a711 1
#include "cbkc.blk"
a760 7

c     Only compute interaction if both atoms
c     are local or else flip a coin
      if ((j1 .le. na_local)) then
      if ((j2 .le. na_local) .or. 
     $     (itag(j1) .lt. itag(j2))) then

d783 7
a789 1
      eb=eb+ebh
d838 7
a845 1
      eb=eb+estriph
a979 12
      endif

C This is a sanity test
      else

         if (j2 .le. na_local) then
            write(6,*) 'Ooops!'
            stop
         endif

      endif

d1036 1
a1036 1
      do 30 i1=1,na_local
d1086 4
a1089 1
      ea=ea+eah
d1245 3
a1247 1
      ea=ea+eahu
d1445 1
a1445 1
      do 40 i1=1,na_local
d1466 3
a1468 1
      elp=elp+elph
a1669 2
      if (j(2) .le. na_local) then

d1802 3
a1804 1
      ecoa=ecoa+ecoah
d1843 3
a1845 1
      ecoa=ecoa+ecoah
a2052 2
      endif

d2111 1
a2111 1
         ehb=ehb+ehbh
a2263 14

c     Only compute interaction if both center atoms
c     are local or else flip a coin
c     ********** WARNING: This may break for np > 1 ********
c     ********** Possible fix: enforce j(2) to be local ****
c     ********** as in vlist construction ******************

      if (j(2) .gt. na_local .and. j(3) .gt. na_local) go to 10
      if (j(3) .gt. na_local .and. 
     $     (itag(j(2)) .gt. itag(j(3)))) go to 10
      if (j(2) .gt. na_local .and. 
     $     (itag(j(3)) .gt. itag(j(2)))) go to 10


d2413 9
a2421 1
      et=et+eth
d2453 9
a2461 1
      eco=eco+ecoh
a2763 7


c     Only compute interaction if both atoms
c     are local or else flip a coin
      if ((i2 .le. na_local) .or. 
     $     (itag(i1) .lt. itag(i2))) then

d2774 5
d2826 7
a2832 2
      ew=ew+ewhtap
      ep=ep+ephtap
d2843 6
a2848 3
         ftmp = (dewdrtap+depdrtap)*(a(k4)/rr)
         d(k4,i1)=d(k4,i1)+ftmp
         d(k4,i2)=d(k4,i2)-ftmp
a2864 2
      endif

@


4.4.4.2
log
@Implemented ri*Fi pressure calc
@
text
@a2098 2
c$$$* Only need to compute bonds where j(2) is local
c$$$      if (j(2) .le. na_local) then
d2114 3
a2116 1
      ehb=ehb+ehbh
d2191 1
a2191 2
c$$$      endif

@


4.4.4.3
log
@Optimized speed and memory footprint of ReaxFF by eliminating angles and torsions made redundant by reverse communication. Also set Lprune=4 and Lhb=0 without missing and force terms.
@
text
@d2270 13
d2713 1
a2713 1
      endif
@


4.4.4.4
log
@Added atom stress for ReaxFF
@
text
@a602 1
#include "cbkc.blk"
a612 1
      dimension virial_tmp(3,3),virialsym(6)
d672 12
a686 9

      if (Latomvirial) then
         do k1=1,3
         do k2=1,3
            virial_tmp(k1,k2) = 0.0
         end do
         end do
      endif

d689 5
d695 3
a697 9
      ftmp = delpdsbo*dbondc(ncubo,k1,i4)
      d(k1,ihu)=d(k1,ihu)+ftmp

      if (Latomvirial) then
         do k1p=1,3
            virial_tmp(k1,k1p)=virial_tmp(k1,k1p)+ftmp*c(ihu,k1p)
         end do
      endif

d700 1
a700 22
c$$$c     Verified that this sums to zero
c$$$      write(6,*) 'elp forcesum = ',sumf
      if (Latomvirial) then
         virialsym(1) = virial_tmp(1,1)
         virialsym(2) = virial_tmp(2,2)
         virialsym(3) = virial_tmp(3,3)
         virialsym(4) = virial_tmp(1,2)
         virialsym(5) = virial_tmp(1,3)
         virialsym(6) = virial_tmp(2,3)
         do k1 = 1,6
            virial(k1) = virial(k1) + virialsym(k1)
         end do

         frac = 1.0d0/idbo1(ncubo)
         do k1 = 1,6
            vtmp = virialsym(k1)*frac
            do i4=1,idbo1(ncubo)
               ihu=idbo(ncubo,i4)
               atomvirial(k1,ihu) = atomvirial(k1,ihu) + vtmp;
            end do
         end do
      endif
a701 1
      end do
a734 1
      dimension virial_tmp(3,3),virialsym(6)
d799 1
a799 9

      if (Latomvirial) then
         do k1=1,3
         do k2=1,3
            virial_tmp(k1,k2) = 0.0
         end do
         end do
      endif

d803 1
a803 1
      ftmp = debdbo*(dbondc(i1,k1,i2)-dbopindc(i1,k1,i2)-
a806 5
      d(k1,ihu)=d(k1,ihu)+ftmp

      if (Latomvirial) then
      do k1p=1,3
      virial_tmp(k1,k1p)=virial_tmp(k1,k1p)+ftmp*c(ihu,k1p)
d808 1
a808 1
      endif
d810 13
d825 1
a825 24
c$$$c     Verified that this sums to zero
c$$$      write(6,*) 'eb forcesum = ',sumf
      if (Latomvirial) then
         virialsym(1) = virial_tmp(1,1)
         virialsym(2) = virial_tmp(2,2)
         virialsym(3) = virial_tmp(3,3)
         virialsym(4) = virial_tmp(1,2)
         virialsym(5) = virial_tmp(1,3)
         virialsym(6) = virial_tmp(2,3)
         do k1 = 1,6
            virial(k1) = virial(k1) + virialsym(k1)
         end do

         frac = 1.0d0/idbo1(i1)
         do k1 = 1,6
            vtmp = virialsym(k1)*frac
            do i2=1,idbo1(i1)
               ihu=idbo(i1,i2)
               atomvirial(k1,ihu) = atomvirial(k1,ihu) + vtmp;
            end do
         end do

      endif

d854 1
a854 7
      if (Latomvirial) then
         do k1=1,3
         do k2=1,3
            virial_tmp(k1,k2) = 0.0
         end do
         end do
      endif
d859 3
a861 2
      ftmp = decobdbo*dbondc(i1,k1,i2)
      d(k1,ihu)=d(k1,ihu)+ftmp
d863 9
a871 3
      if (Latomvirial) then
      do k1p=1,3
      virial_tmp(k1,k1p)=virial_tmp(k1,k1p)+ftmp*c(ihu,k1p)
a872 1
      endif
d874 8
a883 21
c$$$c     Verified that this sums to zero
c$$$      write(6,*) 'eb2 forcesum = ',sumf
      if (Latomvirial) then
         virialsym(1) = virial_tmp(1,1)
         virialsym(2) = virial_tmp(2,2)
         virialsym(3) = virial_tmp(3,3)
         virialsym(4) = virial_tmp(1,2)
         virialsym(5) = virial_tmp(1,3)
         virialsym(6) = virial_tmp(2,3)
         do k1 = 1,6
            virial(k1) = virial(k1) + virialsym(k1)
         end do

         frac = 1.0d0/idbo1(i1)
         do k1 = 1,6
            vtmp = virialsym(k1)*frac
            do i2=1,idbo1(i1)
               ihu=idbo(i1,i2)
               atomvirial(k1,ihu) = atomvirial(k1,ihu) + vtmp;
            end do
         end do
d885 14
a898 1
      endif
a902 9

      if (Latomvirial) then
         do k1=1,3
         do k2=1,3
            virial_tmp(k1,k2) = 0.0
         end do
         end do
      endif

d905 5
d911 2
a912 9
      ftmp = decobdboua*dbondc(ncubo,k1,i4)
      d(k1,ihu)=d(k1,ihu)+ftmp

      if (Latomvirial) then
      do k1p=1,3
      virial_tmp(k1,k1p)=virial_tmp(k1,k1p)+ftmp*c(ihu,k1p)
      end do
      endif

a914 24
c$$$c     Verified that this sums to zero
c$$$      write(6,*) 'eb3 forcesum = ',sumf
      if (Latomvirial) then
         virialsym(1) = virial_tmp(1,1)
         virialsym(2) = virial_tmp(2,2)
         virialsym(3) = virial_tmp(3,3)
         virialsym(4) = virial_tmp(1,2)
         virialsym(5) = virial_tmp(1,3)
         virialsym(6) = virial_tmp(2,3)
         do k1 = 1,6
            virial(k1) = virial(k1) + virialsym(k1)
         end do

         frac = 1.0d0/idbo1(ncubo)
         do k1 = 1,6
            vtmp = virialsym(k1)*frac
            do i4=1,idbo1(ncubo)
               ihu=idbo(ncubo,i4)
               atomvirial(k1,ihu) = atomvirial(k1,ihu) + vtmp;
            end do
         end do

      endif

a919 7
      if (Latomvirial) then
         do k1=1,3
         do k2=1,3
            virial_tmp(k1,k2) = 0.0
         end do
         end do
      endif
d922 5
d928 2
a929 6
      ftmp = decobdboub*dbondc(ncubo,k1,i4)
      d(k1,ihu)=d(k1,ihu)+ftmp

      if (Latomvirial) then
      do k1p=1,3
      virial_tmp(k1,k1p)=virial_tmp(k1,k1p)+ftmp*c(ihu,k1p)
a930 2
      endif

a932 21
c$$$c     Verified that this sums to zero
c$$$      write(6,*) 'eb4 forcesum = ',sumf
      if (Latomvirial) then
         virialsym(1) = virial_tmp(1,1)
         virialsym(2) = virial_tmp(2,2)
         virialsym(3) = virial_tmp(3,3)
         virialsym(4) = virial_tmp(1,2)
         virialsym(5) = virial_tmp(1,3)
         virialsym(6) = virial_tmp(2,3)
         do k1 = 1,6
            virial(k1) = virial(k1) + virialsym(k1)
         end do

         frac = 1.0d0/idbo1(ncubo)
         do k1 = 1,6
            vtmp = virialsym(k1)*frac
            do i4=1,idbo1(ncubo)
               ihu=idbo(ncubo,i4)
               atomvirial(k1,ihu) = atomvirial(k1,ihu) + vtmp;
            end do
         end do
d934 33
a966 1
      endif
d968 10
a977 1
      end do
a1031 1
      dimension virial_tmp(3,3),virialsym(6)
d1104 2
a1111 9

      if (Latomvirial) then
         do k1=1,3
         do k2=1,3
            virial_tmp(k1,k2) = 0.0
         end do
         end do
      endif

d1115 1
a1115 1
      ftmp = deadvov1*(1.0+dfvl*vho*dvlpdsbo(i1))*
a1116 8
      d(k1,ihu)=d(k1,ihu)+ftmp

      if (Latomvirial) then
      do k1p=1,3
      virial_tmp(k1,k1p)=virial_tmp(k1,k1p)+ftmp*c(ihu,k1p)
      end do
      endif

a1118 24
c$$$c     Verified that this sums to zero
c$$$      write(6,*) 'ea forcesum = ',sumf
      if (Latomvirial) then
         virialsym(1) = virial_tmp(1,1)
         virialsym(2) = virial_tmp(2,2)
         virialsym(3) = virial_tmp(3,3)
         virialsym(4) = virial_tmp(1,2)
         virialsym(5) = virial_tmp(1,3)
         virialsym(6) = virial_tmp(2,3)
         do k1 = 1,6
            virial(k1) = virial(k1) + virialsym(k1)
         end do

         frac = 1.0d0/idbo1(ncubo)
         do k1 = 1,6
            vtmp = virialsym(k1)*frac
            do i4=1,idbo1(ncubo)
               ihu=idbo(ncubo,i4)
               atomvirial(k1,ihu) = atomvirial(k1,ihu) + vtmp;
            end do
         end do

      endif

a1133 8
      if (Latomvirial) then
         do k1=1,3
         do k2=1,3
            virial_tmp(k1,k2) = 0.0
         end do
         end do
      endif

d1137 1
a1137 1
      ftmp = deadpibo*(dbopindc(nbosa,k1,i4)+
a1138 8
      d(k1,ihu)=d(k1,ihu)+ftmp

      if (Latomvirial) then
      do k1p=1,3
      virial_tmp(k1,k1p)=virial_tmp(k1,k1p)+ftmp*c(ihu,k1p)
      end do
      endif

a1140 22
c$$$c     Verified that this sums to zero
c$$$      write(6,*) 'ea2 forcesum = ',sumf
      if (Latomvirial) then
         virialsym(1) = virial_tmp(1,1)
         virialsym(2) = virial_tmp(2,2)
         virialsym(3) = virial_tmp(3,3)
         virialsym(4) = virial_tmp(1,2)
         virialsym(5) = virial_tmp(1,3)
         virialsym(6) = virial_tmp(2,3)
         do k1 = 1,6
            virial(k1) = virial(k1) + virialsym(k1)
         end do

         frac = 1.0d0/idbo1(nbosa)
         do k1 = 1,6
            vtmp = virialsym(k1)*frac
            do i4=1,idbo1(nbosa)
               ihu=idbo(nbosa,i4)
               atomvirial(k1,ihu) = atomvirial(k1,ihu) + vtmp;
            end do
         end do
      endif
d1146 9
a1155 6
      if (Latomvirial) then
         do k1=1,3
         do k2=1,3
            virial_tmp(k1,k2) = 0.0
         end do
         end do
d1158 10
d1170 5
d1176 4
a1179 7
      ftmp = deadvov2*(1.0+dfvl*dvlpdsbo(iat2))*
     $dbondc(ncubo,k1,i4)
      d(k1,ihu)=d(k1,ihu)+ftmp
 
      if (Latomvirial) then
      do k1p=1,3
      virial_tmp(k1,k1p)=virial_tmp(k1,k1p)+ftmp*c(ihu,k1p)
d1182 3
d1186 20
a1207 23
c$$$c     Verified that this sums to zero
c$$$      write(6,*) 'ea3 forcesum = ',sumf
      if (Latomvirial) then
         virialsym(1) = virial_tmp(1,1)
         virialsym(2) = virial_tmp(2,2)
         virialsym(3) = virial_tmp(3,3)
         virialsym(4) = virial_tmp(1,2)
         virialsym(5) = virial_tmp(1,3)
         virialsym(6) = virial_tmp(2,3)
         do k1 = 1,6
            virial(k1) = virial(k1) + virialsym(k1)
         end do

         frac = 1.0d0/idbo1(ncubo)
         do k1 = 1,6
            vtmp = virialsym(k1)*frac
            do i4=1,idbo1(ncubo)
               ihu=idbo(ncubo,i4)
               atomvirial(k1,ihu) = atomvirial(k1,ihu) + vtmp;
            end do
         end do

      endif
d1209 16
d1231 1
d1264 1
a1269 9

      if (Latomvirial) then
         do k1=1,3
         do k2=1,3
            virial_tmp(k1,k2) = 0.0
         end do
         end do
      endif

d1273 1
a1273 1
      ftmp = deaudvov1*(1.0+dfvl*vho*dvlpdsbo(i1))*
a1274 8
      d(k1,ihu)=d(k1,ihu)+ftmp

      if (Latomvirial) then
      do k1p=1,3
      virial_tmp(k1,k1p)=virial_tmp(k1,k1p)+ftmp*c(ihu,k1p)
      end do
      endif

a1276 24
c$$$c     Verified that this sums to zero
c$$$      write(6,*) 'ea4 forcesum = ',sumf
      if (Latomvirial) then
         virialsym(1) = virial_tmp(1,1)
         virialsym(2) = virial_tmp(2,2)
         virialsym(3) = virial_tmp(3,3)
         virialsym(4) = virial_tmp(1,2)
         virialsym(5) = virial_tmp(1,3)
         virialsym(6) = virial_tmp(2,3)
         do k1 = 1,6
            virial(k1) = virial(k1) + virialsym(k1)
         end do

         frac = 1.0d0/idbo1(ncubo)
         do k1 = 1,6
            vtmp = virialsym(k1)*frac
            do i4=1,idbo1(ncubo)
               ihu=idbo(ncubo,i4)
               atomvirial(k1,ihu) = atomvirial(k1,ihu) + vtmp;
            end do
         end do

      endif

a1293 8
      if (Latomvirial) then
         do k1=1,3
         do k2=1,3
            virial_tmp(k1,k2) = 0.0
         end do
         end do
      endif

d1297 1
a1297 1
      ftmp = deadpibo1*
a1298 8
      d(k1,ihu)=d(k1,ihu)+ftmp

      if (Latomvirial) then
      do k1p=1,3
      virial_tmp(k1,k1p)=virial_tmp(k1,k1p)+ftmp*c(ihu,k1p)
      end do
      endif

a1300 23
c$$$c     Verified that this sums to zero
c$$$      write(6,*) 'ea5 forcesum = ',sumf
      if (Latomvirial) then
         virialsym(1) = virial_tmp(1,1)
         virialsym(2) = virial_tmp(2,2)
         virialsym(3) = virial_tmp(3,3)
         virialsym(4) = virial_tmp(1,2)
         virialsym(5) = virial_tmp(1,3)
         virialsym(6) = virial_tmp(2,3)
         do k1 = 1,6
            virial(k1) = virial(k1) + virialsym(k1)
         end do

         frac = 1.0d0/idbo1(nbosa)
         do k1 = 1,6
            vtmp = virialsym(k1)*frac
            do i4=1,idbo1(nbosa)
               ihu=idbo(nbosa,i4)
               atomvirial(k1,ihu) = atomvirial(k1,ihu) + vtmp;
            end do
         end do

      endif
d1306 11
d1318 3
a1320 7
      if (Latomvirial) then
         do k1=1,3
         do k2=1,3
            virial_tmp(k1,k2) = 0.0
         end do
         end do
      endif
d1322 4
d1328 5
d1334 3
a1336 7
      ftmp = deadvov2*(1.0+dfvl*dvlpdsbo(iat2))*
     $dbondc(ncubo,k1,i4)
      d(k1,ihu)=d(k1,ihu)+ftmp

      if (Latomvirial) then
      do k1p=1,3
      virial_tmp(k1,k1p)=virial_tmp(k1,k1p)+ftmp*c(ihu,k1p)
d1339 1
d1341 24
a1366 21
c$$$c     Verified that this sums to zero
c$$$      write(6,*) 'ea6 forcesum = ',sumf
      if (Latomvirial) then
         virialsym(1) = virial_tmp(1,1)
         virialsym(2) = virial_tmp(2,2)
         virialsym(3) = virial_tmp(3,3)
         virialsym(4) = virial_tmp(1,2)
         virialsym(5) = virial_tmp(1,3)
         virialsym(6) = virial_tmp(2,3)
         do k1 = 1,6
            virial(k1) = virial(k1) + virialsym(k1)
         end do

         frac = 1.0d0/idbo1(ncubo)
         do k1 = 1,6
            vtmp = virialsym(k1)*frac
            do i4=1,idbo1(ncubo)
               ihu=idbo(ncubo,i4)
               atomvirial(k1,ihu) = atomvirial(k1,ihu) + vtmp;
            end do
         end do
d1368 16
d1385 1
a1387 3
      end do
 
      endif
d1391 1
d1397 50
d1474 1
a1474 9

      if (Latomvirial) then
         do k1=1,3
         do k2=1,3
            virial_tmp(k1,k2) = 0.0
         end do
         end do
      endif

d1478 13
a1490 6
      ftmp = deahu2dbo*dbondc(nbohu,k1,i3)
      d(k1,ihu)=d(k1,ihu)+ftmp

      if (Latomvirial) then
      do k1p=1,3
      virial_tmp(k1,k1p)=virial_tmp(k1,k1p)+ftmp*c(ihu,k1p)
d1493 3
d1497 10
d1509 1
a1509 24
c$$$c     Not yet verified that this sums to zero
c$$$      write(6,*) 'elp2 forcesum = ',sumf
      if (Latomvirial) then
         virialsym(1) = virial_tmp(1,1)
         virialsym(2) = virial_tmp(2,2)
         virialsym(3) = virial_tmp(3,3)
         virialsym(4) = virial_tmp(1,2)
         virialsym(5) = virial_tmp(1,3)
         virialsym(6) = virial_tmp(2,3)
         do k1 = 1,6
            virial(k1) = virial(k1) + virialsym(k1)
         end do

         frac = 1.0d0/idbo1(nbohu)
         do k1 = 1,6
            vtmp = virialsym(k1)*frac
            do i3=1,idbo1(nbohu)
               ihu=idbo(nbohu,i3)
               atomvirial(k1,ihu) = atomvirial(k1,ihu) + vtmp;
            end do
         end do

      endif

a1513 9

      if (Latomvirial) then
         do k1=1,3
         do k2=1,3
            virial_tmp(k1,k2) = 0.0
         end do
         end do
      endif

d1516 5
d1522 3
a1524 6
      ftmp = deahu2dsbo*dbondc(ncubo,k1,i4)
      d(k1,ihu)=d(k1,ihu)+ftmp

      if (Latomvirial) then
      do k1p=1,3
      virial_tmp(k1,k1p)=virial_tmp(k1,k1p)+ftmp*c(ihu,k1p)
a1526 2

      end do
a1527 21
c$$$c     Not yet verified that this sums to zero
c$$$      write(6,*) 'elp3 forcesum = ',sumf
      if (Latomvirial) then
         virialsym(1) = virial_tmp(1,1)
         virialsym(2) = virial_tmp(2,2)
         virialsym(3) = virial_tmp(3,3)
         virialsym(4) = virial_tmp(1,2)
         virialsym(5) = virial_tmp(1,3)
         virialsym(6) = virial_tmp(2,3)
         do k1 = 1,6
            virial(k1) = virial(k1) + virialsym(k1)
         end do

         frac = 1.0d0/idbo1(ncubo)
         do k1 = 1,6
            vtmp = virialsym(k1)*frac
            do i4=1,idbo1(ncubo)
               ihu=idbo(ncubo,i4)
               atomvirial(k1,ihu) = atomvirial(k1,ihu) + vtmp;
            end do
         end do
d1529 2
a1532 4
      end if
      end do

      end if
a1548 1
#include "cbkc.blk"
d1558 1
a1558 1
      dimension virial_tmp(3,3),virialsym(6)
a1608 9

      if (Latomvirial) then
         do k1=1,3
         do k2=1,3
            virial_tmp(k1,k2) = 0.0
         end do
         end do
      endif

d1612 1
a1612 9
      ftmp = demoldsbo*dbondc(ncubo,k1,i4)
      d(k1,ihu)=d(k1,ihu)+ftmp

      if (Latomvirial) then
      do k1p=1,3
      virial_tmp(k1,k1p)=virial_tmp(k1,k1p)+ftmp*c(ihu,k1p)
      end do
      endif

a1614 24
c$$$c     Not yet verified that this sums to zero
c$$$      write(6,*) 'emol forcesum = ',sumf
      if (Latomvirial) then
         virialsym(1) = virial_tmp(1,1)
         virialsym(2) = virial_tmp(2,2)
         virialsym(3) = virial_tmp(3,3)
         virialsym(4) = virial_tmp(1,2)
         virialsym(5) = virial_tmp(1,3)
         virialsym(6) = virial_tmp(2,3)
         do k1 = 1,6
            virial(k1) = virial(k1) + virialsym(k1)
         end do

         frac = 1.0d0/idbo1(ncubo)
         do k1 = 1,6
            vtmp = virialsym(k1)*frac
            do i4=1,idbo1(ncubo)
               ihu=idbo(ncubo,i4)
               atomvirial(k1,ihu) = atomvirial(k1,ihu) + vtmp;
            end do
         end do

      endif

a1635 1
#include "cbkc.blk"
a1651 1
      dimension virial_tmp(3,3),virialsym(6)
d1854 1
a1854 7
      if (Latomvirial) then
         do k1=1,3
         do k2=1,3
            virial_tmp(k1,k2) = 0.0
         end do
         end do
      endif
d1858 59
a1916 6
      ftmp = devdh*dhdc(i1,k1,k2)
      d(k1,j(k2))=d(k1,j(k2))+ftmp

      if (Latomvirial) then
      do k1p=1,3
      virial_tmp(k1,k1p)=virial_tmp(k1,k1p)+ftmp*c(j(k2),k1p)
d1919 1
d1921 8
a1930 22
c$$$c     Verified that this sums to zero
c$$$      write(6,*) 'eval forcesum = ',sumf
      if (Latomvirial) then
         virialsym(1) = virial_tmp(1,1)
         virialsym(2) = virial_tmp(2,2)
         virialsym(3) = virial_tmp(3,3)
         virialsym(4) = virial_tmp(1,2)
         virialsym(5) = virial_tmp(1,3)
         virialsym(6) = virial_tmp(2,3)
         do k1 = 1,6
            virial(k1) = virial(k1) + virialsym(k1)
         end do

         frac = 1.0d0/3
         do k1 = 1,6
            vtmp = virialsym(k1)*frac
            do k2=1,3
               ihu=j(k2)
               atomvirial(k1,ihu) = atomvirial(k1,ihu) + vtmp;
            end do
         end do

d1932 1
d1934 1
a1934 7
      if (Latomvirial) then
         do k1=1,3
         do k2=1,3
            virial_tmp(k1,k2) = 0.0
         end do
         end do
      endif
a1935 2
      do i2=1,idbo1(la)
      ihu=idbo(la,i2)
d1937 8
a1944 7
      ftmp = (devdla+decoadboa+decodbola)*
     $dbondc(la,k1,i2)
      d(k1,ihu)=d(k1,ihu)+ftmp

      if (Latomvirial) then
      do k1p=1,3
      virial_tmp(k1,k1p)=virial_tmp(k1,k1p)+ftmp*c(ihu,k1p)
a1945 1
      endif
d1947 10
a1958 31
c$$$c     Verified that this sums to zero
c$$$      write(6,*) 'eval2 forcesum = ',sumf
      if (Latomvirial) then
         virialsym(1) = virial_tmp(1,1)
         virialsym(2) = virial_tmp(2,2)
         virialsym(3) = virial_tmp(3,3)
         virialsym(4) = virial_tmp(1,2)
         virialsym(5) = virial_tmp(1,3)
         virialsym(6) = virial_tmp(2,3)
         do k1 = 1,6
            virial(k1) = virial(k1) + virialsym(k1)
         end do

         frac = 1.0d0/idbo1(la)
         do k1 = 1,6
            vtmp = virialsym(k1)*frac
            do i2=1,idbo1(la)
               ihu=idbo(la,i2)
               atomvirial(k1,ihu) = atomvirial(k1,ihu) + vtmp;
            end do
         end do

      endif

      if (Latomvirial) then
         do k1=1,3
         do k2=1,3
            virial_tmp(k1,k2) = 0.0
         end do
         end do
      endif
d1962 5
d1968 2
a1969 10
      ftmp = (devdlb+decoadbob+decodbolb)*
     $dbondc(lb,k1,i2)
      d(k1,ihu)=d(k1,ihu)+ftmp

      if (Latomvirial) then
      do k1p=1,3
      virial_tmp(k1,k1p)=virial_tmp(k1,k1p)+ftmp*c(ihu,k1p)
      end do
      endif

a1971 23
c$$$c     Verified that this sums to zero
c$$$      write(6,*) 'eval3 forcesum = ',sumf
      if (Latomvirial) then
         virialsym(1) = virial_tmp(1,1)
         virialsym(2) = virial_tmp(2,2)
         virialsym(3) = virial_tmp(3,3)
         virialsym(4) = virial_tmp(1,2)
         virialsym(5) = virial_tmp(1,3)
         virialsym(6) = virial_tmp(2,3)
         do k1 = 1,6
            virial(k1) = virial(k1) + virialsym(k1)
         end do

         frac = 1.0d0/idbo1(lb)
         do k1 = 1,6
            vtmp = virialsym(k1)*frac
            do i2=1,idbo1(lb)
               ihu=idbo(lb,i2)
               atomvirial(k1,ihu) = atomvirial(k1,ihu) + vtmp;
            end do
         end do

      endif
a1977 9

      if (Latomvirial) then
         do k1=1,3
         do k2=1,3
            virial_tmp(k1,k2) = 0.0
         end do
         end do
      endif

d1980 9
a1988 3
      do k1=1,3
      ftmp = (-dsbo2dvlp*devdsbo+devdsbo2+decdsbo2
     $+dvmbodbo*dsbo2dvmbo*devdsbo)*
d1991 1
a1991 5
      d(k1,ihu)=d(k1,ihu)+ftmp

      if (Latomvirial) then
      do k1p=1,3
      virial_tmp(k1,k1p)=virial_tmp(k1,k1p)+ftmp*c(ihu,k1p)
a1993 2

      end do
a1994 21
c$$$c     Verified that this sums to zero
c$$$      write(6,*) 'eval4 forcesum = ',sumf
      if (Latomvirial) then
         virialsym(1) = virial_tmp(1,1)
         virialsym(2) = virial_tmp(2,2)
         virialsym(3) = virial_tmp(3,3)
         virialsym(4) = virial_tmp(1,2)
         virialsym(5) = virial_tmp(1,3)
         virialsym(6) = virial_tmp(2,3)
         do k1 = 1,6
            virial(k1) = virial(k1) + virialsym(k1)
         end do

         frac = 1.0d0/idbo1(ibv)
         do k1 = 1,6
            vtmp = virialsym(k1)*frac
            do i3=1,idbo1(ibv)
               ihu=idbo(ibv,i3)
               atomvirial(k1,ihu) = atomvirial(k1,ihu) + vtmp;
            end do
         end do
a1995 5
      endif

      endif
      end do
 
a1999 9

      if (Latomvirial) then
         do k1=1,3
         do k2=1,3
            virial_tmp(k1,k2) = 0.0
         end do
         end do
      endif

d2002 5
d2008 3
a2010 6
      ftmp = decodboua*dbondc(ibv,k1,i3)
      d(k1,ihu)=d(k1,ihu)+ftmp

      if (Latomvirial) then
      do k1p=1,3
      virial_tmp(k1,k1p)=virial_tmp(k1,k1p)+ftmp*c(ihu,k1p)
a2012 2

      end do
a2013 21
c$$$c     Verified that this sums to zero
c$$$      write(6,*) 'eval5 forcesum = ',sumf
      if (Latomvirial) then
         virialsym(1) = virial_tmp(1,1)
         virialsym(2) = virial_tmp(2,2)
         virialsym(3) = virial_tmp(3,3)
         virialsym(4) = virial_tmp(1,2)
         virialsym(5) = virial_tmp(1,3)
         virialsym(6) = virial_tmp(2,3)
         do k1 = 1,6
            virial(k1) = virial(k1) + virialsym(k1)
         end do

         frac = 1.0d0/idbo1(ibv)
         do k1 = 1,6
            vtmp = virialsym(k1)*frac
            do i3=1,idbo1(ibv)
               ihu=idbo(ibv,i3)
               atomvirial(k1,ihu) = atomvirial(k1,ihu) + vtmp;
            end do
         end do
a2014 5
      endif

      endif
      end do
 
a2018 9

      if (Latomvirial) then
         do k1=1,3
         do k2=1,3
            virial_tmp(k1,k2) = 0.0
         end do
         end do
      endif

d2021 5
d2027 2
a2028 9
      ftmp = decodboob*dbondc(ibv,k1,i3)
      d(k1,ihu)=d(k1,ihu)+ftmp

      if (Latomvirial) then
      do k1p=1,3
      virial_tmp(k1,k1p)=virial_tmp(k1,k1p)+ftmp*c(ihu,k1p)
      end do
      endif

a2030 24
c$$$c     Verified that this sums to zero
c$$$      write(6,*) 'eval6 forcesum = ',sumf
      if (Latomvirial) then
         virialsym(1) = virial_tmp(1,1)
         virialsym(2) = virial_tmp(2,2)
         virialsym(3) = virial_tmp(3,3)
         virialsym(4) = virial_tmp(1,2)
         virialsym(5) = virial_tmp(1,3)
         virialsym(6) = virial_tmp(2,3)
         do k1 = 1,6
            virial(k1) = virial(k1) + virialsym(k1)
         end do

         frac = 1.0d0/idbo1(ibv)
         do k1 = 1,6
            vtmp = virialsym(k1)*frac
            do i3=1,idbo1(ibv)
               ihu=idbo(ibv,i3)
               atomvirial(k1,ihu) = atomvirial(k1,ihu) + vtmp;
            end do
         end do

      endif

a2037 9

      if (Latomvirial) then
         do k1=1,3
         do k2=1,3
            virial_tmp(k1,k2) = 0.0
         end do
         end do
      endif

d2040 5
d2046 3
a2048 6
      ftmp = decodbouc*dbondc(ibv,k1,i3)
      d(k1,ihu)=d(k1,ihu)+ftmp

      if (Latomvirial) then
      do k1p=1,3
      virial_tmp(k1,k1p)=virial_tmp(k1,k1p)+ftmp*c(ihu,k1p)
a2050 2

      end do
a2051 21
c$$$c     Verified that this sums to zero
c$$$      write(6,*) 'eval7 forcesum = ',sumf
      if (Latomvirial) then
         virialsym(1) = virial_tmp(1,1)
         virialsym(2) = virial_tmp(2,2)
         virialsym(3) = virial_tmp(3,3)
         virialsym(4) = virial_tmp(1,2)
         virialsym(5) = virial_tmp(1,3)
         virialsym(6) = virial_tmp(2,3)
         do k1 = 1,6
            virial(k1) = virial(k1) + virialsym(k1)
         end do

         frac = 1.0d0/idbo1(ibv)
         do k1 = 1,6
            vtmp = virialsym(k1)*frac
            do i3=1,idbo1(ibv)
               ihu=idbo(ibv,i3)
               atomvirial(k1,ihu) = atomvirial(k1,ihu) + vtmp;
            end do
         end do
d2053 1
a2053 4
      endif

      endif
      end do
a2069 1
#include "cbkc.blk"
d2079 4
a2082 1
      dimension virial_tmp(3,3),virialsym(6)
d2118 3
d2133 1
a2133 7
      if (Latomvirial) then
         do k1=1,3
         do k2=1,3
            virial_tmp(k1,k2) = 0.0
         end do
         end do
      endif
d2136 14
a2149 8
      ftmp = dehbdrda*drda(k1)
      d(k1,j(2))=d(k1,j(2))+ftmp
      d(k1,j(3))=d(k1,j(3))-ftmp

      if (Latomvirial) then
      do k1p=1,3
      virial_tmp(k1,k1p)=virial_tmp(k1,k1p)+
     $        ftmp*c(j(2),k1p)-ftmp*c(j(3),k1p)
a2150 2
      endif

a2151 21
c$$$c     Verified that this sums to zero
c$$$      write(6,*) 'ehb forcesum = ',sumf
      if (Latomvirial) then
         virialsym(1) = virial_tmp(1,1)
         virialsym(2) = virial_tmp(2,2)
         virialsym(3) = virial_tmp(3,3)
         virialsym(4) = virial_tmp(1,2)
         virialsym(5) = virial_tmp(1,3)
         virialsym(6) = virial_tmp(2,3)
         do k1 = 1,6
            virial(k1) = virial(k1) + virialsym(k1)
         end do

         frac = 1.0d0/2
         do k1 = 1,6
            vtmp = virialsym(k1)*frac
            ihu = j(2)
            atomvirial(k1,ihu) = atomvirial(k1,ihu) + vtmp;
            ihu = j(3)
            atomvirial(k1,ihu) = atomvirial(k1,ihu) + vtmp;
         end do
d2153 1
a2153 9
      endif

      if (Latomvirial) then
         do k1=1,3
         do k2=1,3
            virial_tmp(k1,k2) = 0.0
         end do
         end do
      endif
d2155 10
d2167 6
a2172 6
      ftmp = dehbdv*dvdc(k1,k2)
      d(k1,j(k2))=d(k1,j(k2))+ftmp

      if (Latomvirial) then
      do k1p=1,3
      virial_tmp(k1,k1p)=virial_tmp(k1,k1p)+ftmp*c(j(k2),k1p)
a2173 2
      endif

d2175 1
a2175 33
      end do
c$$$c     Verified that this sums to zero
c$$$      write(6,*) 'ehb2 forcesum = ',sumf
      if (Latomvirial) then
         virialsym(1) = virial_tmp(1,1)
         virialsym(2) = virial_tmp(2,2)
         virialsym(3) = virial_tmp(3,3)
         virialsym(4) = virial_tmp(1,2)
         virialsym(5) = virial_tmp(1,3)
         virialsym(6) = virial_tmp(2,3)
         do k1 = 1,6
            virial(k1) = virial(k1) + virialsym(k1)
         end do

         frac = 1.0d0/3
         do k1 = 1,6
            vtmp = virialsym(k1)*frac
            do k2=1,3
               ihu=j(k2)
               atomvirial(k1,ihu) = atomvirial(k1,ihu) + vtmp;
            end do
         end do

      endif

      if (Latomvirial) then
         do k1=1,3
         do k2=1,3
            virial_tmp(k1,k2) = 0.0
         end do
         end do
      endif

d2178 5
d2184 3
a2186 6
      ftmp = dehbdbo*dbondc(la,k1,i2)
      d(k1,ihu)=d(k1,ihu)+ftmp

      if (Latomvirial) then
      do k1p=1,3
      virial_tmp(k1,k1p)=virial_tmp(k1,k1p)+ftmp*c(ihu,k1p)
a2187 1
      endif
d2189 1
a2189 23
      end do
      end do
c$$$c     Verified that this sums to zero
c$$$      write(6,*) 'ehb3 forcesum = ',sumf
      if (Latomvirial) then
         virialsym(1) = virial_tmp(1,1)
         virialsym(2) = virial_tmp(2,2)
         virialsym(3) = virial_tmp(3,3)
         virialsym(4) = virial_tmp(1,2)
         virialsym(5) = virial_tmp(1,3)
         virialsym(6) = virial_tmp(2,3)
         do k1 = 1,6
            virial(k1) = virial(k1) + virialsym(k1)
         end do

         frac = 1.0d0/idbo1(la)
         do k1 = 1,6
            vtmp = virialsym(k1)*frac
            do i2=1,idbo1(la)
               ihu=idbo(la,i2)
               atomvirial(k1,ihu) = atomvirial(k1,ihu) + vtmp;
            end do
         end do
d2191 1
a2191 1
      endif
a2234 1
      dimension virial_tmp(3,3),virialsym(6)
d2295 12
d2421 5
d2532 1
a2532 7
      if (Latomvirial) then
         do k1=1,3
         do k2=1,3
            virial_tmp(k1,k2) = 0.0
         end do
         end do
      endif
d2544 1
a2544 1
      ftmp = DARGTDC(i1,K1,K2)*detdar+
a2546 5
      D(K1,J(K2))=D(K1,J(K2))+ftmp

      if (Latomvirial) then
      do k1p=1,3
      virial_tmp(k1,k1p)=virial_tmp(k1,k1p)+ftmp*c(j(k2),k1p)
a2547 2
      endif

d2549 1
a2549 33
      end do
c$$$c     Verified that this sums to zero
c$$$      write(6,*) 'etor forcesum = ',sumf
      if (Latomvirial) then
         virialsym(1) = virial_tmp(1,1)
         virialsym(2) = virial_tmp(2,2)
         virialsym(3) = virial_tmp(3,3)
         virialsym(4) = virial_tmp(1,2)
         virialsym(5) = virial_tmp(1,3)
         virialsym(6) = virial_tmp(2,3)
         do k1 = 1,6
            virial(k1) = virial(k1) + virialsym(k1)
         end do

         frac = 1.0d0/4
         do k1 = 1,6
            vtmp = virialsym(k1)*frac
            do k2=1,4
               ihu=j(k2)
               atomvirial(k1,ihu) = atomvirial(k1,ihu) + vtmp;
            end do
         end do

      endif

      if (Latomvirial) then
         do k1=1,3
         do k2=1,3
            virial_tmp(k1,k2) = 0.0
         end do
         end do
      endif

d2553 1
a2553 9
      ftmp = dbondc(la,k1,i2)*(detdboa+decodbola)
      d(k1,ihu)=d(k1,ihu)+ftmp

      if (Latomvirial) then
      do k1p=1,3
      virial_tmp(k1,k1p)=virial_tmp(k1,k1p)+ftmp*c(ihu,k1p)
      end do
      endif

d2556 1
a2556 32
c$$$c     Verified that this sums to zero
c$$$      write(6,*) 'etor2 forcesum = ',sumf
      if (Latomvirial) then
         virialsym(1) = virial_tmp(1,1)
         virialsym(2) = virial_tmp(2,2)
         virialsym(3) = virial_tmp(3,3)
         virialsym(4) = virial_tmp(1,2)
         virialsym(5) = virial_tmp(1,3)
         virialsym(6) = virial_tmp(2,3)
         do k1 = 1,6
            virial(k1) = virial(k1) + virialsym(k1)
         end do

         frac = 1.0d0/idbo1(la)
         do k1 = 1,6
            vtmp = virialsym(k1)*frac
            do i2=1,idbo1(la)
               ihu=idbo(la,i2)
               atomvirial(k1,ihu) = atomvirial(k1,ihu) + vtmp;
            end do
         end do

      endif

      if (Latomvirial) then
         do k1=1,3
         do k2=1,3
            virial_tmp(k1,k2) = 0.0
         end do
         end do
      endif

d2560 21
a2580 7
         ftmp = dbondc(lb,k1,i2)*(detdbob+decodbolb)
     $   +dbopindc(lb,k1,i2)*detdbopib
      d(k1,ihu)=d(k1,ihu)+ftmp

      if (Latomvirial) then
      do k1p=1,3
      virial_tmp(k1,k1p)=virial_tmp(k1,k1p)+ftmp*c(ihu,k1p)
d2583 1
d2585 9
d2595 1
a2596 21
c$$$c     Verified that this sums to zero
c$$$      write(6,*) 'etor3 forcesum = ',sumf
      if (Latomvirial) then
         virialsym(1) = virial_tmp(1,1)
         virialsym(2) = virial_tmp(2,2)
         virialsym(3) = virial_tmp(3,3)
         virialsym(4) = virial_tmp(1,2)
         virialsym(5) = virial_tmp(1,3)
         virialsym(6) = virial_tmp(2,3)
         do k1 = 1,6
            virial(k1) = virial(k1) + virialsym(k1)
         end do

         frac = 1.0d0/idbo1(lb)
         do k1 = 1,6
            vtmp = virialsym(k1)*frac
            do i2=1,idbo1(lb)
               ihu=idbo(lb,i2)
               atomvirial(k1,ihu) = atomvirial(k1,ihu) + vtmp;
            end do
         end do
d2598 1
a2598 1
      endif
d2600 20
a2619 7
      if (Latomvirial) then
         do k1=1,3
         do k2=1,3
            virial_tmp(k1,k2) = 0.0
         end do
         end do
      endif
d2621 7
a2627 2
      do i2=1,idbo1(lc)
      ihu=idbo(lc,i2)
d2629 4
a2632 2
      ftmp = dbondc(lc,k1,i2)*(detdboc+decodbolc)
      d(k1,ihu)=d(k1,ihu)+ftmp
d2634 13
a2646 3
      if (Latomvirial) then
      do k1p=1,3
      virial_tmp(k1,k1p)=virial_tmp(k1,k1p)+ftmp*c(ihu,k1p)
a2647 1
      endif
d2649 10
a2660 23
c$$$c     Verified that this sums to zero
c$$$      write(6,*) 'etor4 forcesum = ',sumf
      if (Latomvirial) then
         virialsym(1) = virial_tmp(1,1)
         virialsym(2) = virial_tmp(2,2)
         virialsym(3) = virial_tmp(3,3)
         virialsym(4) = virial_tmp(1,2)
         virialsym(5) = virial_tmp(1,3)
         virialsym(6) = virial_tmp(2,3)
         do k1 = 1,6
            virial(k1) = virial(k1) + virialsym(k1)
         end do

         frac = 1.0d0/idbo1(lc)
         do k1 = 1,6
            vtmp = virialsym(k1)*frac
            do i2=1,idbo1(lc)
               ihu=idbo(lc,i2)
               atomvirial(k1,ihu) = atomvirial(k1,ihu) + vtmp;
            end do
         end do

      endif
d2666 1
a2666 10

      if (Latomvirial) then
         do k1=1,3
         do k2=1,3
            virial_tmp(k1,k2) = 0.0
         end do
         end do
      endif

      do i3=1,idbo1(ncubo)
d2668 5
d2674 2
a2675 9
      ftmp = detdsbo1*dbondc(ncubo,k1,i3)
      d(k1,ihu)=d(k1,ihu)+ftmp

      if (Latomvirial) then
      do k1p=1,3
      virial_tmp(k1,k1p)=virial_tmp(k1,k1p)+ftmp*c(ihu,k1p)
      end do
      endif

a2677 24
c$$$c     Verified that this sums to zero
c$$$      write(6,*) 'etor5 forcesum = ',sumf
      if (Latomvirial) then
         virialsym(1) = virial_tmp(1,1)
         virialsym(2) = virial_tmp(2,2)
         virialsym(3) = virial_tmp(3,3)
         virialsym(4) = virial_tmp(1,2)
         virialsym(5) = virial_tmp(1,3)
         virialsym(6) = virial_tmp(2,3)
         do k1 = 1,6
            virial(k1) = virial(k1) + virialsym(k1)
         end do

         frac = 1.0d0/idbo1(ncubo)
         do k1 = 1,6
            vtmp = virialsym(k1)*frac
            do i3=1,idbo1(ncubo)
               ihu=idbo(ncubo,i3)
               atomvirial(k1,ihu) = atomvirial(k1,ihu) + vtmp;
            end do
         end do

      endif

d2685 1
a2685 10

      if (Latomvirial) then
         do k1=1,3
         do k2=1,3
            virial_tmp(k1,k2) = 0.0
         end do
         end do
      endif

      do i3=1,idbo1(ncubo)
d2687 5
d2693 3
a2695 6
      ftmp = detdsbo1*dbondc(ncubo,k1,i3)
      d(k1,ihu)=d(k1,ihu)+ftmp

      if (Latomvirial) then
      do k1p=1,3
      virial_tmp(k1,k1p)=virial_tmp(k1,k1p)+ftmp*c(ihu,k1p)
a2697 1

a2698 24
      end do
c$$$c     Verified that this sums to zero
c$$$      write(6,*) 'etor6 forcesum = ',sumf
      if (Latomvirial) then
         virialsym(1) = virial_tmp(1,1)
         virialsym(2) = virial_tmp(2,2)
         virialsym(3) = virial_tmp(3,3)
         virialsym(4) = virial_tmp(1,2)
         virialsym(5) = virial_tmp(1,3)
         virialsym(6) = virial_tmp(2,3)
         do k1 = 1,6
            virial(k1) = virial(k1) + virialsym(k1)
         end do

         frac = 1.0d0/idbo1(ncubo)
         do k1 = 1,6
            vtmp = virialsym(k1)*frac
            do i3=1,idbo1(ncubo)
               ihu=idbo(ncubo,i3)
               atomvirial(k1,ihu) = atomvirial(k1,ihu) + vtmp;
            end do
         end do

      endif
a2700 1
      end do
a2727 1
      dimension virial_tmp(3,3),virialsym(6)
d2827 1
a2827 8

      if (Latomvirial) then
         do k1=1,3
         do k2=1,3
            virial_tmp(k1,k2) = 0.0
         end do
         end do
      endif
a2832 6
         if (Latomvirial) then
            do k1p=1,3
               virial_tmp(k4,k1p)=virial_tmp(k4,k1p)+
     $              ftmp*c(i1,k1p)-ftmp*c(i2,k1p)
            end do
         endif
d2835 9
a2843 21
c$$$c     Verified that this sums to zero
c$$$      write(6,*) 'enonbon forcesum = ',sumf
      if (Latomvirial) then
         virialsym(1) = virial_tmp(1,1)
         virialsym(2) = virial_tmp(2,2)
         virialsym(3) = virial_tmp(3,3)
         virialsym(4) = virial_tmp(1,2)
         virialsym(5) = virial_tmp(1,3)
         virialsym(6) = virial_tmp(2,3)
         do k1 = 1,6
            virial(k1) = virial(k1) + virialsym(k1)
         end do

         frac = 1.0d0/2
         do k1 = 1,6
            vtmp = virialsym(k1)*frac
            ihu=i1
            atomvirial(k1,ihu) = atomvirial(k1,ihu) + vtmp;
            ihu=i2
            atomvirial(k1,ihu) = atomvirial(k1,ihu) + vtmp;
         end do
d2845 1
a2845 1
      endif
d2852 74
d2934 29
d3033 103
@


4.4.4.5
log
@Finished adding atomic virial for ReaxFF force field
@
text
@d678 1
a678 1
      if (Lvirial.eq.1) then
d692 1
a692 1
      if (Lvirial.eq.1) then
d702 1
a702 1
      if (Lvirial.eq.1) then
d713 6
a718 8
         if (Latomvirial.eq.1) then
            frac = 1.0d0/idbo1(ncubo)
            do k1 = 1,6
               vtmp = virialsym(k1)*frac
               do i4=1,idbo1(ncubo)
                  ihu=idbo(ncubo,i4)
                  atomvirial(k1,ihu) = atomvirial(k1,ihu) + vtmp;
               end do
d720 1
a720 1
         endif
d823 1
a823 1
      if (Lvirial.eq.1) then
d840 1
a840 1
      if (Lvirial.eq.1) then
d850 1
a850 1
      if (Lvirial.eq.1) then
d861 6
a866 8
         if (Latomvirial.eq.1) then
            frac = 1.0d0/idbo1(i1)
            do k1 = 1,6
               vtmp = virialsym(k1)*frac
               do i2=1,idbo1(i1)
                  ihu=idbo(i1,i2)
                  atomvirial(k1,ihu) = atomvirial(k1,ihu) + vtmp;
               end do
d868 1
a868 1
         endif
d900 1
a900 1
      if (Lvirial.eq.1) then
d914 1
a914 1
      if (Lvirial.eq.1) then
d924 1
a924 1
      if (Lvirial.eq.1) then
d935 6
a940 8
         if (Latomvirial.eq.1) then
            frac = 1.0d0/idbo1(i1)
            do k1 = 1,6
               vtmp = virialsym(k1)*frac
               do i2=1,idbo1(i1)
                  ihu=idbo(i1,i2)
                  atomvirial(k1,ihu) = atomvirial(k1,ihu) + vtmp;
               end do
d942 1
a942 1
         endif
d950 1
a950 1
      if (Lvirial.eq.1) then
d964 1
a964 1
      if (Lvirial.eq.1) then
d974 1
a974 1
      if (Lvirial.eq.1) then
d985 6
a990 8
         if (Latomvirial.eq.1) then
            frac = 1.0d0/idbo1(ncubo)
            do k1 = 1,6
               vtmp = virialsym(k1)*frac
               do i4=1,idbo1(ncubo)
                  ihu=idbo(ncubo,i4)
                  atomvirial(k1,ihu) = atomvirial(k1,ihu) + vtmp;
               end do
d992 1
a992 1
         endif
d1001 1
a1001 1
      if (Lvirial.eq.1) then
d1014 1
a1014 1
      if (Lvirial.eq.1) then
d1024 1
a1024 1
      if (Lvirial.eq.1) then
d1035 6
a1040 8
         if (Latomvirial.eq.1) then
            frac = 1.0d0/idbo1(ncubo)
            do k1 = 1,6
               vtmp = virialsym(k1)*frac
               do i4=1,idbo1(ncubo)
                  ihu=idbo(ncubo,i4)
                  atomvirial(k1,ihu) = atomvirial(k1,ihu) + vtmp;
               end do
d1042 1
a1042 1
         endif
d1181 1
a1181 1
      if (Lvirial.eq.1) then
d1196 1
a1196 1
      if (Lvirial.eq.1) then
d1206 1
a1206 1
      if (Lvirial.eq.1) then
d1217 6
a1222 8
         if (Latomvirial.eq.1) then
            frac = 1.0d0/idbo1(ncubo)
            do k1 = 1,6
               vtmp = virialsym(k1)*frac
               do i4=1,idbo1(ncubo)
                  ihu=idbo(ncubo,i4)
                  atomvirial(k1,ihu) = atomvirial(k1,ihu) + vtmp;
               end do
d1224 1
a1224 1
         endif
d1243 1
a1243 1
      if (Lvirial.eq.1) then
d1258 1
a1258 1
      if (Lvirial.eq.1) then
d1268 1
a1268 1
      if (Lvirial.eq.1) then
d1279 6
a1284 8
         if (Latomvirial.eq.1) then
            frac = 1.0d0/idbo1(nbosa)
            do k1 = 1,6
               vtmp = virialsym(k1)*frac
               do i4=1,idbo1(nbosa)
                  ihu=idbo(nbosa,i4)
                  atomvirial(k1,ihu) = atomvirial(k1,ihu) + vtmp;
               end do
d1286 1
a1286 1
         endif
d1294 1
a1294 1
      if (Lvirial.eq.1) then
d1309 1
a1309 1
      if (Lvirial.eq.1) then
d1319 1
a1319 1
      if (Lvirial.eq.1) then
d1330 6
a1335 8
         if (Latomvirial.eq.1) then
            frac = 1.0d0/idbo1(ncubo)
            do k1 = 1,6
               vtmp = virialsym(k1)*frac
               do i4=1,idbo1(ncubo)
                  ihu=idbo(ncubo,i4)
                  atomvirial(k1,ihu) = atomvirial(k1,ihu) + vtmp;
               end do
d1337 1
a1337 1
         endif
d1385 1
a1385 1
      if (Lvirial.eq.1) then
d1400 1
a1400 1
      if (Lvirial.eq.1) then
d1410 1
a1410 1
      if (Lvirial.eq.1) then
d1421 6
a1426 8
         if (Latomvirial.eq.1) then
            frac = 1.0d0/idbo1(ncubo)
            do k1 = 1,6
               vtmp = virialsym(k1)*frac
               do i4=1,idbo1(ncubo)
                  ihu=idbo(ncubo,i4)
                  atomvirial(k1,ihu) = atomvirial(k1,ihu) + vtmp;
               end do
d1428 1
a1428 1
         endif
d1449 1
a1449 1
      if (Lvirial.eq.1) then
d1464 1
a1464 1
      if (Lvirial.eq.1) then
d1474 1
a1474 1
      if (Lvirial.eq.1) then
d1485 6
a1490 8
         if (Latomvirial.eq.1) then
            frac = 1.0d0/idbo1(nbosa)
            do k1 = 1,6
               vtmp = virialsym(k1)*frac
               do i4=1,idbo1(nbosa)
                  ihu=idbo(nbosa,i4)
                  atomvirial(k1,ihu) = atomvirial(k1,ihu) + vtmp;
               end do
d1492 1
a1492 1
         endif
d1501 1
a1501 1
      if (Lvirial.eq.1) then
d1516 1
a1516 1
      if (Lvirial.eq.1) then
d1526 1
a1526 1
      if (Lvirial.eq.1) then
d1537 6
a1542 8
         if (Latomvirial.eq.1) then
            frac = 1.0d0/idbo1(ncubo)
            do k1 = 1,6
               vtmp = virialsym(k1)*frac
               do i4=1,idbo1(ncubo)
                  ihu=idbo(ncubo,i4)
                  atomvirial(k1,ihu) = atomvirial(k1,ihu) + vtmp;
               end do
d1544 1
a1544 1
         endif
d1588 1
a1588 1
      if (Lvirial.eq.1) then
d1602 1
a1602 1
      if (Lvirial.eq.1) then
d1612 1
a1612 1
      if (Lvirial.eq.1) then
d1623 6
a1628 8
         if (Latomvirial.eq.1) then
            frac = 1.0d0/idbo1(nbohu)
            do k1 = 1,6
               vtmp = virialsym(k1)*frac
               do i3=1,idbo1(nbohu)
                  ihu=idbo(nbohu,i3)
                  atomvirial(k1,ihu) = atomvirial(k1,ihu) + vtmp;
               end do
d1630 1
a1630 1
         endif
d1639 1
a1639 1
      if (Lvirial.eq.1) then
d1653 1
a1653 1
      if (Lvirial.eq.1) then
d1663 1
a1663 1
      if (Lvirial.eq.1) then
d1674 6
a1679 8
         if (Latomvirial.eq.1) then
            frac = 1.0d0/idbo1(ncubo)
            do k1 = 1,6
               vtmp = virialsym(k1)*frac
               do i4=1,idbo1(ncubo)
                  ihu=idbo(ncubo,i4)
                  atomvirial(k1,ihu) = atomvirial(k1,ihu) + vtmp;
               end do
d1681 1
a1681 1
         endif
d1767 1
a1767 1
      if (Lvirial.eq.1) then
d1781 1
a1781 1
      if (Lvirial.eq.1) then
d1791 1
a1791 1
      if (Lvirial.eq.1) then
d1802 6
a1807 8
         if (Latomvirial.eq.1) then
            frac = 1.0d0/idbo1(ncubo)
            do k1 = 1,6
               vtmp = virialsym(k1)*frac
               do i4=1,idbo1(ncubo)
                  ihu=idbo(ncubo,i4)
                  atomvirial(k1,ihu) = atomvirial(k1,ihu) + vtmp;
               end do
d1809 1
a1809 1
         endif
d2054 1
a2054 1
      if (Lvirial.eq.1) then
d2067 1
a2067 1
      if (Lvirial.eq.1) then
d2077 1
a2077 1
      if (Lvirial.eq.1) then
d2088 6
a2093 8
         if (Latomvirial.eq.1) then
            frac = 1.0d0/3
            do k1 = 1,6
               vtmp = virialsym(k1)*frac
               do k2=1,3
                  ihu=j(k2)
                  atomvirial(k1,ihu) = atomvirial(k1,ihu) + vtmp;
               end do
d2095 1
a2095 1
         endif
d2099 1
a2099 1
      if (Lvirial.eq.1) then
d2114 1
a2114 1
      if (Lvirial.eq.1) then
d2124 1
a2124 1
      if (Lvirial.eq.1) then
d2135 6
a2140 8
         if (Latomvirial.eq.1) then
            frac = 1.0d0/idbo1(la)
            do k1 = 1,6
               vtmp = virialsym(k1)*frac
               do i2=1,idbo1(la)
                  ihu=idbo(la,i2)
                  atomvirial(k1,ihu) = atomvirial(k1,ihu) + vtmp;
               end do
d2142 1
a2142 1
         endif
d2146 1
a2146 1
      if (Lvirial.eq.1) then
d2161 1
a2161 1
      if (Lvirial.eq.1) then
d2171 1
a2171 1
      if (Lvirial.eq.1) then
d2182 6
a2187 8
         if (Latomvirial.eq.1) then
            frac = 1.0d0/idbo1(lb)
            do k1 = 1,6
               vtmp = virialsym(k1)*frac
               do i2=1,idbo1(lb)
                  ihu=idbo(lb,i2)
                  atomvirial(k1,ihu) = atomvirial(k1,ihu) + vtmp;
               end do
d2189 1
a2189 1
         endif
d2199 1
a2199 1
      if (Lvirial.eq.1) then
d2216 1
a2216 1
      if (Lvirial.eq.1) then
d2226 1
a2226 1
      if (Lvirial.eq.1) then
d2237 6
a2242 8
         if (Latomvirial.eq.1) then
            frac = 1.0d0/idbo1(ibv)
            do k1 = 1,6
               vtmp = virialsym(k1)*frac
               do i3=1,idbo1(ibv)
                  ihu=idbo(ibv,i3)
                  atomvirial(k1,ihu) = atomvirial(k1,ihu) + vtmp;
               end do
d2244 1
a2244 1
         endif
d2256 1
a2256 1
      if (Lvirial.eq.1) then
d2270 1
a2270 1
      if (Lvirial.eq.1) then
d2280 1
a2280 1
      if (Lvirial.eq.1) then
d2291 6
a2296 8
         if (Latomvirial.eq.1) then
            frac = 1.0d0/idbo1(ibv)
            do k1 = 1,6
               vtmp = virialsym(k1)*frac
               do i3=1,idbo1(ibv)
                  ihu=idbo(ibv,i3)
                  atomvirial(k1,ihu) = atomvirial(k1,ihu) + vtmp;
               end do
d2298 1
a2298 1
         endif
d2310 1
a2310 1
      if (Lvirial.eq.1) then
d2324 1
a2324 1
      if (Lvirial.eq.1) then
d2334 1
a2334 1
      if (Lvirial.eq.1) then
d2345 6
a2350 8
         if (Latomvirial.eq.1) then
            frac = 1.0d0/idbo1(ibv)
            do k1 = 1,6
               vtmp = virialsym(k1)*frac
               do i3=1,idbo1(ibv)
                  ihu=idbo(ibv,i3)
                  atomvirial(k1,ihu) = atomvirial(k1,ihu) + vtmp;
               end do
d2352 1
a2352 1
         endif
d2364 1
a2364 1
      if (Lvirial.eq.1) then
d2378 1
a2378 1
      if (Lvirial.eq.1) then
d2388 1
a2388 1
      if (Lvirial.eq.1) then
d2399 6
a2404 8
         if (Latomvirial.eq.1) then
            frac = 1.0d0/idbo1(ibv)
            do k1 = 1,6
               vtmp = virialsym(k1)*frac
               do i3=1,idbo1(ibv)
                  ihu=idbo(ibv,i3)
                  atomvirial(k1,ihu) = atomvirial(k1,ihu) + vtmp;
               end do
d2406 1
a2406 1
         endif
d2486 1
a2486 1
      if (Lvirial.eq.1) then
d2499 1
a2499 1
      if (Lvirial.eq.1) then
d2509 1
a2509 1
      if (Lvirial.eq.1) then
d2520 8
a2527 10
         if (Latomvirial.eq.1) then
            frac = 1.0d0/2
            do k1 = 1,6
               vtmp = virialsym(k1)*frac
               ihu = j(2)
               atomvirial(k1,ihu) = atomvirial(k1,ihu) + vtmp;
               ihu = j(3)
               atomvirial(k1,ihu) = atomvirial(k1,ihu) + vtmp;
            end do
         endif
d2531 1
a2531 1
      if (Lvirial.eq.1) then
d2544 1
a2544 1
      if (Lvirial.eq.1) then
d2554 1
a2554 1
      if (Lvirial.eq.1) then
d2565 6
a2570 8
         if (Latomvirial.eq.1) then
            frac = 1.0d0/3
            do k1 = 1,6
               vtmp = virialsym(k1)*frac
               do k2=1,3
                  ihu=j(k2)
                  atomvirial(k1,ihu) = atomvirial(k1,ihu) + vtmp;
               end do
d2572 1
a2572 1
         endif
d2576 1
a2576 1
      if (Lvirial.eq.1) then
d2590 1
a2590 1
      if (Lvirial.eq.1) then
d2600 1
a2600 1
      if (Lvirial.eq.1) then
d2611 6
a2616 8
         if (Latomvirial.eq.1) then
            frac = 1.0d0/idbo1(la)
            do k1 = 1,6
               vtmp = virialsym(k1)*frac
               do i2=1,idbo1(la)
                  ihu=idbo(la,i2)
                  atomvirial(k1,ihu) = atomvirial(k1,ihu) + vtmp;
               end do
d2618 1
a2618 1
         endif
d2945 1
a2945 1
      if (Lvirial.eq.1) then
d2968 1
a2968 1
      if (Lvirial.eq.1) then
d2978 1
a2978 1
      if (Lvirial.eq.1) then
d2989 6
a2994 8
         if (Latomvirial.eq.1) then
            frac = 1.0d0/4
            do k1 = 1,6
               vtmp = virialsym(k1)*frac
               do k2=1,4
                  ihu=j(k2)
                  atomvirial(k1,ihu) = atomvirial(k1,ihu) + vtmp;
               end do
d2996 1
a2996 1
         endif
d3000 1
a3000 1
      if (Lvirial.eq.1) then
d3014 1
a3014 1
      if (Lvirial.eq.1) then
d3024 1
a3024 1
      if (Lvirial.eq.1) then
d3035 6
a3040 8
         if (Latomvirial.eq.1) then
            frac = 1.0d0/idbo1(la)
            do k1 = 1,6
               vtmp = virialsym(k1)*frac
               do i2=1,idbo1(la)
                  ihu=idbo(la,i2)
                  atomvirial(k1,ihu) = atomvirial(k1,ihu) + vtmp;
               end do
d3042 1
a3042 1
         endif
d3046 1
a3046 1
      if (Lvirial.eq.1) then
d3061 1
a3061 1
      if (Lvirial.eq.1) then
d3071 1
a3071 1
      if (Lvirial.eq.1) then
d3082 6
a3087 8
         if (Latomvirial.eq.1) then
            frac = 1.0d0/idbo1(lb)
            do k1 = 1,6
               vtmp = virialsym(k1)*frac
               do i2=1,idbo1(lb)
                  ihu=idbo(lb,i2)
                  atomvirial(k1,ihu) = atomvirial(k1,ihu) + vtmp;
               end do
d3089 1
a3089 1
         endif
d3093 1
a3093 1
      if (Lvirial.eq.1) then
d3107 1
a3107 1
      if (Lvirial.eq.1) then
d3117 1
a3117 1
      if (Lvirial.eq.1) then
d3128 6
a3133 8
         if (Latomvirial.eq.1) then
            frac = 1.0d0/idbo1(lc)
            do k1 = 1,6
               vtmp = virialsym(k1)*frac
               do i2=1,idbo1(lc)
                  ihu=idbo(lc,i2)
                  atomvirial(k1,ihu) = atomvirial(k1,ihu) + vtmp;
               end do
d3135 1
a3135 1
         endif
d3144 1
a3144 1
      if (Lvirial.eq.1) then
d3158 1
a3158 1
      if (Lvirial.eq.1) then
d3168 1
a3168 1
      if (Lvirial.eq.1) then
d3179 6
a3184 8
         if (Latomvirial.eq.1) then
            frac = 1.0d0/idbo1(ncubo)
            do k1 = 1,6
               vtmp = virialsym(k1)*frac
               do i3=1,idbo1(ncubo)
                  ihu=idbo(ncubo,i3)
                  atomvirial(k1,ihu) = atomvirial(k1,ihu) + vtmp;
               end do
d3186 1
a3186 1
         endif
d3198 1
a3198 1
      if (Lvirial.eq.1) then
d3212 1
a3212 1
      if (Lvirial.eq.1) then
d3222 1
a3222 1
      if (Lvirial.eq.1) then
d3233 6
a3238 8
         if (Latomvirial.eq.1) then
            frac = 1.0d0/idbo1(ncubo)
            do k1 = 1,6
               vtmp = virialsym(k1)*frac
               do i3=1,idbo1(ncubo)
                  ihu=idbo(ncubo,i3)
                  atomvirial(k1,ihu) = atomvirial(k1,ihu) + vtmp;
               end do
d3240 1
a3240 1
         endif
d3374 1
a3374 1
      if (Lvirial.eq.1) then
d3386 1
a3386 1
         if (Lvirial.eq.1) then
d3396 1
a3396 1
      if (Lvirial.eq.1) then
d3407 8
a3414 10
         if (Latomvirial.eq.1) then
            frac = 1.0d0/2
            do k1 = 1,6
               vtmp = virialsym(k1)*frac
               ihu=i1
               atomvirial(k1,ihu) = atomvirial(k1,ihu) + vtmp;
               ihu=i2
               atomvirial(k1,ihu) = atomvirial(k1,ihu) + vtmp;
            end do
         endif
@


4.3
log
@Optimized subroutine nonbon.
@
text
@a2110 1
         if (j(3) .le. na_local) then
a2111 3
         else
            ehb=ehb+0.5*ehbh
         endif
@


4.2
log
@Upgraded ReaxFF force field
@
text
@d2766 1
a2818 4
      if (ndebug.eq.1) then
         write(65,'("Force pair",6e15.6)') rr,
     $        q1q2,rr2,hulpw,sw,sw1
      endif
d2830 6
a2835 8
      if (i1 .le. na_local) then
         if (i2 .le. na_local) then
            ew=ew+ewhtap
            ep=ep+ephtap
         else
            ew=ew+0.5*ewhtap
            ep=ep+0.5*ephtap
         endif
d2848 5
a2852 1
      d(k4,i2)=d(k4,i2)-(dewdrtap+depdrtap)*(a(k4)/rr)
d2867 2
@


4.1
log
@reaxFF: Added 1-5 neighbors of local atoms to bond list; needed for over-coordination forces.
@
text
@d442 4
a445 2
      ovi2=aboi-valf(iti)
      ovj2=aboj-valf(itj)
@


4.0
log
@This is version 4.0
@
text
@a799 8
      if (ndebug.eq.1) then
         if (k1.eq.1) then
            write(65,'(f10.4,f12.8,6f10.4)') 
     $           debdbo,dbondc(i1,k1,i2),dbopindc(i1,k1,i2),
     $           dbopi2ndc(i1,k1,i2),debdbopi,dbopindc(i1,k1,i2),
     $           debdbopi2,dbopi2ndc(i1,k1,i2)
         endif
      endif
d802 1
d993 1
a2853 1

@


1.1
log
@Merged REAX version with main version
@
text
@@

