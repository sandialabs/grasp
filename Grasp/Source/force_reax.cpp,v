head	4.18;
access;
symbols
	ReverseComm_branch:4.8.0.4
	ADTools_branch:4.8.0.2
	Monaco_Aidan:4.1.0.4
	Root-of-Monaco_Aidan:4.1
	PPPM_Crozier2:4.2.0.2
	PPPM_Crozier:4.2
	Root-of-PPPM_Crozier:4.2
	Monaco:4.1.0.2
	PreMonaco:4.1
	Recovery-2004-04-12:4.0
	BRANCH:4.0.0.6
	PMONACO:4.0.0.4
	ROOT:4.0
	initial:4.0.0.2
	pmonaco:4.0
	Version_4_0:4.0
	REAX-2:3.2.2.16
	REAXFF:3.2.0.2;
locks; strict;
comment	@// @;


4.18
date	2007.10.23.22.05.56;	author athomps;	state Exp;
branches;
next	4.17;

4.17
date	2007.09.09.20.58.36;	author athomps;	state Exp;
branches;
next	4.16;

4.16
date	2007.09.05.22.43.34;	author athomps;	state Exp;
branches;
next	4.15;

4.15
date	2007.06.02.03.27.21;	author athomps;	state Exp;
branches;
next	4.14;

4.14
date	2007.05.31.16.52.01;	author athomps;	state Exp;
branches;
next	4.13;

4.13
date	2007.05.31.00.50.12;	author athomps;	state Exp;
branches;
next	4.12;

4.12
date	2007.05.30.05.41.46;	author athomps;	state Exp;
branches;
next	4.11;

4.11
date	2006.12.12.06.57.32;	author athomps;	state Exp;
branches;
next	4.10;

4.10
date	2006.11.28.06.24.21;	author athomps;	state Exp;
branches;
next	4.9;

4.9
date	2006.11.09.20.13.52;	author athomps;	state Exp;
branches;
next	4.8;

4.8
date	2006.04.05.22.52.02;	author athomps;	state Exp;
branches
	4.8.4.1;
next	4.7;

4.7
date	2006.03.20.20.56.03;	author athomps;	state Exp;
branches;
next	4.6;

4.6
date	2006.01.25.21.40.12;	author athomps;	state Exp;
branches;
next	4.5;

4.5
date	2005.10.11.01.40.34;	author athomps;	state Exp;
branches;
next	4.4;

4.4
date	2005.08.03.17.58.35;	author athomps;	state Exp;
branches;
next	4.3;

4.3
date	2005.07.29.00.13.55;	author athomps;	state Exp;
branches;
next	4.2;

4.2
date	2005.06.08.20.08.48;	author athomps;	state Exp;
branches
	4.2.2.1;
next	4.1;

4.1
date	2005.05.03.16.28.27;	author athomps;	state Exp;
branches
	4.1.4.1;
next	4.0;

4.0
date	2005.04.05.16.43.30;	author athomps;	state Exp;
branches;
next	3.3;

3.3
date	2005.04.02.00.37.56;	author athomps;	state Exp;
branches;
next	3.2;

3.2
date	2004.12.16.23.40.44;	author athomps;	state dead;
branches
	3.2.2.1;
next	3.1;

3.1
date	2004.12.16.23.07.39;	author athomps;	state Exp;
branches;
next	;

3.2.2.1
date	2004.12.16.23.57.12;	author athomps;	state Exp;
branches;
next	3.2.2.2;

3.2.2.2
date	2004.12.22.22.59.07;	author athomps;	state Exp;
branches;
next	3.2.2.3;

3.2.2.3
date	2005.01.03.00.29.17;	author athomps;	state Exp;
branches;
next	3.2.2.4;

3.2.2.4
date	2005.01.04.00.23.00;	author athomps;	state Exp;
branches;
next	3.2.2.5;

3.2.2.5
date	2005.01.07.22.51.01;	author athomps;	state Exp;
branches;
next	3.2.2.6;

3.2.2.6
date	2005.01.11.22.49.40;	author athomps;	state Exp;
branches;
next	3.2.2.7;

3.2.2.7
date	2005.01.16.21.56.05;	author athomps;	state Exp;
branches;
next	3.2.2.8;

3.2.2.8
date	2005.01.21.22.24.30;	author athomps;	state Exp;
branches;
next	3.2.2.9;

3.2.2.9
date	2005.01.23.19.04.55;	author athomps;	state Exp;
branches;
next	3.2.2.10;

3.2.2.10
date	2005.01.29.01.44.20;	author athomps;	state Exp;
branches;
next	3.2.2.11;

3.2.2.11
date	2005.01.29.02.15.37;	author athomps;	state Exp;
branches;
next	3.2.2.12;

3.2.2.12
date	2005.01.31.04.22.50;	author athomps;	state Exp;
branches;
next	3.2.2.13;

3.2.2.13
date	2005.02.03.21.40.18;	author athomps;	state Exp;
branches;
next	3.2.2.14;

3.2.2.14
date	2005.02.07.22.43.46;	author athomps;	state Exp;
branches;
next	3.2.2.15;

3.2.2.15
date	2005.02.09.07.14.57;	author athomps;	state Exp;
branches;
next	3.2.2.16;

3.2.2.16
date	2005.03.30.23.32.07;	author athomps;	state Exp;
branches;
next	;

4.1.4.1
date	2005.10.21.15.44.43;	author saubry;	state Exp;
branches;
next	4.1.4.2;

4.1.4.2
date	2006.02.02.23.40.43;	author athomps;	state Exp;
branches;
next	4.1.4.3;

4.1.4.3
date	2006.02.15.21.34.48;	author athomps;	state Exp;
branches;
next	;

4.2.2.1
date	2005.06.20.22.41.00;	author athomps;	state Exp;
branches;
next	4.2.2.2;

4.2.2.2
date	2005.06.21.21.46.18;	author pscrozi;	state Exp;
branches;
next	;

4.8.4.1
date	2006.11.08.04.18.38;	author athomps;	state Exp;
branches;
next	4.8.4.2;

4.8.4.2
date	2006.11.09.00.20.53;	author athomps;	state Exp;
branches;
next	;


desc
@@


4.18
log
@removed some unnecessary dynamic_casts and fixed problems with self-interactions
@
text
@//-----------------------------------------------------------------------
//
//   G R A S P
//   ____________
//   \           \
//    \ General   \
//     \ Reactive  \
//      \ Atomistic \
//       \ Simulation\
//        \ Program   \
//         \___________\
//
//    Timestamp: April 1, 2005
//    Version: 4.0
//
//    Primary Author: Aidan P. Thompson
//
//    e-mail: athomps@@sandia.gov
//   
//    Copyright (2005) Sandia National Laboratories
//
//    Sandia National Laboratories is a multiprogram laboratory 
//    operated by Sandia Corporation, a Lockheed Martin company,
//    for the United States Department of Energy under contract
//    No. DE-AC04-94AL-85000.
//
//    Under the terms of Contract DE-AC04-94AL85000 with Sandia 
//    Corporation, the U.S. Government retains certain rights in 
//    this software.
//
//    This software is distributed under the terms of the GNU Public 
//    License (GPL). For a copy of the GPL see the file 
//    Grasp/Documentation/LICENSE or visit the GNU website at 
//    http://www.gnu.org/copyleft/gpl.html. Briefly, the GPL 
//    entitles you to use the software, modify it and redistribute it. 
//    The main thing you can not do is apply any other licensing 
//    terms to the software. Also, if any part of this sofware is added 
//    to other software, then that software must also be released under 
//    the GPL.
//
//    This software comes with no warranty of any kind. 
//
//----------------------------------------------------------------------- 
/////:EOH~

#ifdef USE_REAX
#include <vector>
#include <string>
#include <fstream>
#include <iostream>
#include <iomanip>
#include <sstream>
#include <cmath>
using namespace std;
#include "mpi.h"
#include "grasp.h"
#include "vec3.h"
#include "constants.h"
#include "particle.h"
#include "neighbor.h"
#include "input_string.h"
#include "forcefield.h"
#include "force_reax.h"
#include "force_ewald.h"
#include "box.h"
#include "box_inline.h"
#include "force_reax_inline.h"
#include "particlelist.h"
#include "particlelist_inline.h"
#include "comm.h"
#include "particletypelist.h"
#include "log.h"
#include "machine.h"

#include "reax_fortran.h"
#include "reax_params.h"
#include "reax_cbkc.h"
#include "reax_cbkd.h"
#include "reax_cbkch.h"
#include "reax_cbkabo.h"
#include "reax_cbkia.h"
#include "reax_cbkpairs.h"
#include "reax_energies.h"
#include "reax_small.h"
#include "reax_functions.h"

extern Log glog;
extern Constants constants;

Force_Reax::Force_Reax(const string arg_string_in) {
  arg_string = arg_string_in;
  classname = reax;
  timeforce = 0.0;
  nforce = 0;
  npieces = 13;
  energy_piece.resize(npieces);
  label_piece.resize(npieces);
  label_piece[0] = "Ebond";
  label_piece[1] = "Eatom";
  label_piece[2] = "Elp";
  label_piece[3] = "Emol";
  label_piece[4] = "Eval";
  label_piece[5] = "Epen";
  label_piece[6] = "Ecoa";
  label_piece[7] = "Ehbo";
  label_piece[8] = "Etors";
  label_piece[9] = "Econj";
  label_piece[10] = "Evdw";
  label_piece[11] = "Ecoul";
  label_piece[12] = "Efield";
  rcutmax = 0.0;
  Lcoul = false;
  rcutneighsq_table = NULL;
  iprune = 4;
  ihb = 1;
  hbcut = 6.0;
}

Force_Reax::~Force_Reax() {
  // Deallocate ntypes x ntypes array rcutneighsq_table
  if (rcutneighsq_table != NULL) {
    for (int itype=0;itype<ntypes;itype++) {
      delete []rcutneighsq_table[itype];
    }
    delete []rcutneighsq_table;
  }
}

void Force_Reax::ReadInteractions(Comm* comm) {
  int node;

  std::istringstream buf_in(arg_string);

  node = comm->get_node();

  buf_in >> label;
  if (buf_in.fail()) {
    glog.get_logfile() << endl;
    glog.error("Force_Reax::ReadInteractions:\n"
	       "Read error in input string");
  }
  FORTRAN(readc,READC)();

  FORTRAN(init,INIT)();
  FORTRAN(ffinpt,FFINPT)();
  FORTRAN(tap7th,TAP7TH)();
  if (node == 0) {
    FORTRAN(readgeo,READGEO)();
  }
  // FORTRAN(srtatom,SRTATOM)();
  glog.warning("Force_Reax::ReadInteractions:\n"
	     "Remember, order of atoms in types.in and fort.4 must match;\n"
	       "fort.4 must contain at least all the types in types.in");

}

void Force_Reax::SetupInteractions(const Box* b, 
                                      const double& g_ewald, 
				      Comm* comm) {
  int node,nprocs;

  node = comm->get_node();
  nprocs = comm->get_nprocs();

  Lnocut = false;
  
  FORTRAN(getswb,GETSWB)(&swb);
  // Make sure that all hbond partners are captured by vlist.
  rcutmax = max(swb,hbcut);

  if (Lcoul) {
    npieces = 2;
    energy_piece.resize(npieces);
    label_piece.resize(npieces);
    label_piece[0] = "Reax";
    label_piece[1] = "Coulombic";
  }
  
  CheckParams();
}

void Force_Reax::SetupCutNeighSq(const double& rskin, Comm* comm) {
  int itype,jtype,i;
  ForceFieldTypes type;
  int node;
  double rsq_tmp;
  double vlbora;

  node = comm->get_node();

  rcutvsq = rcutmax*rcutmax;
  FORTRAN(getvlbora,GETVLBORA)(&vlbora);
  rcutbsq = vlbora*vlbora;

  // Allocate ntypes x ntypes array rcutneighsq_table
  rcutneighsq_table = new double*[ntypes];
  for (itype=0;itype<ntypes;itype++) {
    rcutneighsq_table[itype] = new double[ntypes];
  }

  // Assign values to rcutneighsq_table[][] using global cutoff
  for (itype=0;itype<ntypes;itype++) {
    for (jtype=0;jtype<ntypes;jtype++) {
      rcutneighsq_table[itype][jtype] = rcutvsq;
    }
  }
}

void Force_Reax::ApplyForce(
                    const bool& Lenergy, const bool& Lvirial, 
		    const bool& Latomvirial, 
		    ParticleList* p, 
		    const Box* b, Comm* comm) {
  bool perflag;

  perflag = b->get_perflag();

  if (Lenergy) {
    energy_piece[0] = 0.0;
    energy_piece[1] = 0.0;
    energy_piece[2] = 0.0;
    energy_piece[3] = 0.0;
    energy_piece[4] = 0.0;
    energy_piece[5] = 0.0;
    energy_piece[6] = 0.0;
    energy_piece[7] = 0.0;
    energy_piece[8] = 0.0;
    energy_piece[9] = 0.0;
    energy_piece[10] = 0.0;
    energy_piece[11] = 0.0;
    energy_piece[12] = 0.0;
  }

  if (Lvirial) {
    FORTRAN(cbkvirial,CBKVIRIAL).Lvirial = 1;
  } else {
    FORTRAN(cbkvirial,CBKVIRIAL).Lvirial = 0;
  }

  if (Latomvirial) {
    FORTRAN(cbkvirial,CBKVIRIAL).Lvirial = 1;
    FORTRAN(cbkvirial,CBKVIRIAL).Latomvirial = 1;
  } else {
    FORTRAN(cbkvirial,CBKVIRIAL).Latomvirial = 0;
  }

  WriteReaxPositions(p,comm);

  WriteReaxVlist(p,b,comm);

  FORTRAN(srtbon1,SRTBON1)(&iprune,&ihb,&hbcut);

  comm->comm_double(FORTRAN(cbkabo,CBKABO).abo);

  FORTRAN(molec,MOLEC)();
  FORTRAN(encalc,ENCALC)();
  int node = comm->get_node();
  FORTRAN(mdsav,MDSAV)(&node);

  // Output array sizes if energy is being reported
  if (Lenergy) {
    OutputReaxSizes(comm);
  }

  ReadReaxForces(p,comm);

  if (Lenergy) {
    energy_piece[0] = FORTRAN(cbkenergies,CBKENERGIES).eb;
    energy_piece[1] = FORTRAN(cbkenergies,CBKENERGIES).ea;
    energy_piece[2] = FORTRAN(cbkenergies,CBKENERGIES).elp;
    energy_piece[3] = FORTRAN(cbkenergies,CBKENERGIES).emol;
    energy_piece[4] = FORTRAN(cbkenergies,CBKENERGIES).ev;
    energy_piece[5] = FORTRAN(cbkenergies,CBKENERGIES).epen;
    energy_piece[6] = FORTRAN(cbkenergies,CBKENERGIES).ecoa;
    energy_piece[7] = FORTRAN(cbkenergies,CBKENERGIES).ehb;
    energy_piece[8] = FORTRAN(cbkenergies,CBKENERGIES).et;
    energy_piece[9] = FORTRAN(cbkenergies,CBKENERGIES).eco;
    energy_piece[10] = FORTRAN(cbkenergies,CBKENERGIES).ew;
    energy_piece[11] = FORTRAN(cbkenergies,CBKENERGIES).ep;
    energy_piece[12] = FORTRAN(cbkenergies,CBKENERGIES).efi;
  }

  if (Lenergy) {
    vector<double> energy_piece_all(npieces);
    MPI_Allreduce(&energy_piece[0],&energy_piece_all[0],npieces,MPI_DOUBLE,
		  MPI_SUM,comm->get_world());
    energy_piece.swap(energy_piece_all);
  }

  if (Lvirial) {

    virial[0] = -FORTRAN(cbkvirial,CBKVIRIAL).virial[0];
    virial[1] = -FORTRAN(cbkvirial,CBKVIRIAL).virial[1];
    virial[2] = -FORTRAN(cbkvirial,CBKVIRIAL).virial[2];
    virial[3] = -FORTRAN(cbkvirial,CBKVIRIAL).virial[3];
    virial[4] = -FORTRAN(cbkvirial,CBKVIRIAL).virial[4];
    virial[5] = -FORTRAN(cbkvirial,CBKVIRIAL).virial[5];

    vector<double> virial_all(nvirial);
    MPI_Allreduce(&virial[0],&virial_all[0],nvirial,MPI_DOUBLE,
		  MPI_SUM,comm->get_world());
    virial.swap(virial_all);

  }

  if (Latomvirial) {
    ReadReaxAtomVirial(p,comm);
  }

}

void Force_Reax::SetupNeighbor(const string& neighbor_style,
       const int& neighbor_freq,
       const double& neighbor_rskin, double& rcutneighmax,
			       double& rcutcomm,
       const Box* b, Comm* comm){
  int node,nprocs;
  bool Ltwoway,Ltwoway_ghost;

  node = comm->get_node();
  nprocs = comm->get_nprocs();

  if (neighbor_style == "none") {
    Lneighbor = false;
  } else if (neighbor_style == "nsq") {
    Ltwoway = false;
    Ltwoway_ghost = true;
    Lneighbor = true;
    neighbor = new Neighbor(Neighbor::neighbor_nsq_ghost,
			    Ltwoway,Ltwoway_ghost,
			    neighbor_freq,neighbor_rskin);
  } else if (neighbor_style == "bin") {
    Ltwoway = false;
    Ltwoway_ghost = true;
    Lneighbor = true;
    neighbor = new Neighbor(Neighbor::neighbor_bin_ghost,
			    Ltwoway,Ltwoway_ghost,
			    neighbor_freq,neighbor_rskin);
  } else {
    glog.error("Force_Reax::SetupNeighbor:\n"
	       "Invalid neighbor style");
  }

  if (Lneighbor && Lnocut) {
    glog.error("Force_Reax::SetupNeighbor:\n"
	       "Can not use nocut types with neighboring");
  }

  if (!Lneighbor && nprocs>1) { 
    glog.error("Force_Reax::SetupNeighbor:\n"
	       "Must use neighboring with multiple processes");
  }

  if (!Lneighbor) {
    if (2.0*rcutmax >  b->get_lmin()) {
      glog.error("Force_Reax::SetupNeighbor:\n"
	 "Smallest separation of periodic images less than twice cut-off\n"
	 "Need to use neighbor list to capture all images");
    }
  }

  rcutneighmax = 0.0;
  if (Lneighbor) {
    rcutneighmax = rcutmax + neighbor_rskin;
    if (Lmidpoint) {
      // Midpoint rule not used for hbond partners
      rcutcomm = max(0.5*swb,hbcut) + neighbor_rskin;
    } else {
      rcutcomm = rcutmax + neighbor_rskin;
    }
    neighbor->set_rcutneighmax(rcutneighmax);
    SetupCutNeighSq(neighbor_rskin,comm);
    if (node == 0) {
      glog.get_logfile() << "Cutoffs for this forcefield" << endl;
      glog.get_logfile() << "rcutmax = " << rcutmax << endl;
      glog.get_logfile() << "rskin = " << neighbor_rskin << endl;
      glog.get_logfile() << "rcutneighmax = " << rcutneighmax << endl;
      glog.get_logfile() << "rcutcomm = " << rcutcomm << endl;
      glog.get_logfile() << "Lmidpoint = " << Lmidpoint << endl;
      glog.get_logfile() << "iprune = " << iprune << endl;
      glog.get_logfile() << "ihb = " << ihb << endl;
      glog.get_logfile() << "hbcut = " << hbcut << endl;
    }
  }
}

void Force_Reax::SetupTypes(const ParticleTypeList* t) {
  int itype,itype_ff;
  bool match;
  int nparticletypes;

  nparticletypes = t->get_ntypes();
  type_index.resize(nparticletypes);
  ntypes = nparticletypes;
  id_index.resize(ntypes);
  // For each id in t, generate ff index
  // By construction ff index is type index
  for (itype = 0; itype < nparticletypes; itype++) {
    type_index[itype]=itype;
    id_index[itype]=t->get_id(itype);
  }
  // Check that each id in ff appears in t
  // This is obviously redundant
  for (itype_ff = 0; itype_ff < ntypes; itype_ff++) {
    match = t->find_id(id_index[itype_ff],itype);
    if (!match) {
      glog.warning("Force_Reax::SetupTypes:\n"
		   "ff type id has no particle type match");
    }
  }
  CheckMasses(t);
}

void Force_Reax::WriteReaxPositions(ParticleList* p, Comm* comm) const {
  double rvec[3];
  int j,jx,jy,jz,jia;
  int nparticles, nghost_particles;
  Particle* i_pnt;

  nparticles = p->get_nparticles();
  nghost_particles = p->get_nghost_particles();

  FORTRAN(rsmall,RSMALL).na = nparticles+nghost_particles;
  FORTRAN(rsmall,RSMALL).na_local = nparticles;

  if (nparticles + nghost_particles > ReaxParams::nat) {
    if (comm->get_Lnodefile()) {
      comm->get_nodefile() << "nparticles + nghost_particles = " <<
      nparticles + nghost_particles << endl;
      comm->get_nodefile() << "ReaxParams::nat = " << 
	ReaxParams::nat << endl;
    }
    glog.abort("Force_Reax::WriteReaxPositions:\n"
	       "ReaxParams::nat too small.");
  }

  j = 0;
  jx = 0;
  jy = ReaxParams::nat;
  jz = 2*ReaxParams::nat;
  jia = 0;

  for (int i = 0; i < nparticles + nghost_particles; i++) {
    i_pnt = p->get_particle(i);
    i_pnt->get_x(rvec);
    FORTRAN(cbkc,CBKC).c[j+jx] = rvec[0];
    FORTRAN(cbkc,CBKC).c[j+jy] = rvec[1];
    FORTRAN(cbkc,CBKC).c[j+jz] = rvec[2];
    FORTRAN(cbkch,CBKCH).ch[j] = i_pnt->get_charge();
    FORTRAN(cbkia,CBKIA).ia[j+jia]=type_index[i_pnt->get_type()]+1;
    FORTRAN(cbkia,CBKIA).iag[j+jia]=type_index[i_pnt->get_type()]+1;
    FORTRAN(cbkc,CBKC).itag[j] = i_pnt->get_tag();
    j++;
  }

}

void Force_Reax::ReadReaxForces(ParticleList* p, Comm* comm) {
  double fvec[3], energy;
  int j,jx,jy,jz;
  int nparticles, nghost_particles;
  Particle* i_pnt;

  nparticles = p->get_nparticles();
  nghost_particles = p->get_nghost_particles();

  j = 0;
  jx = 0;
  jy = 1;
  jz = 2;

  for (int i = 0; i < nparticles + nghost_particles; i++) {
    fvec[0] = -FORTRAN(cbkd,CBKD).d[j+jx];
    fvec[1] = -FORTRAN(cbkd,CBKD).d[j+jy];
    fvec[2] = -FORTRAN(cbkd,CBKD).d[j+jz];
    energy  = FORTRAN(cbkd,CBKD).estrain[i];
    i_pnt = p->get_particle(i);
    i_pnt->increment_f(fvec);             // atom forces
    i_pnt->increment_phi(energy);         // atom energy
    j+=3;
  }

}

void Force_Reax::ReadReaxAtomVirial(ParticleList* p, Comm* comm) {
  double vvec[6];
  int j;
  int nparticles, nghost_particles;
  Particle* i_pnt;

  nparticles = p->get_nparticles();
  nghost_particles = p->get_nghost_particles();

  j = 0;

  for (int i = 0; i < nparticles + nghost_particles; i++) {
    vvec[0] = -FORTRAN(cbkvirial,CBKVIRIAL).atomvirial[j+0];
    vvec[1] = -FORTRAN(cbkvirial,CBKVIRIAL).atomvirial[j+1];
    vvec[2] = -FORTRAN(cbkvirial,CBKVIRIAL).atomvirial[j+2];
    vvec[3] = -FORTRAN(cbkvirial,CBKVIRIAL).atomvirial[j+3];
    vvec[4] = -FORTRAN(cbkvirial,CBKVIRIAL).atomvirial[j+4];
    vvec[5] = -FORTRAN(cbkvirial,CBKVIRIAL).atomvirial[j+5];
    i_pnt = p->get_particle(i);
    i_pnt->increment_virial(vvec);
    j+=6;
  }

}

void Force_Reax::WriteReaxVlist(ParticleList* p, const Box* b, Comm* comm) const {
  double xi[3],xj[3];
  int nparticles,nghost_particles;
  Particle* i_pnt;
  Particle* j_pnt;
  int nvpair,nvlself;
  int* neighptr;
  int j,ii,jj;
  double delr2;
  int nvpairmax;
  double rtmp[3],delr[3];

  nparticles = p->get_nparticles();
  nghost_particles = p->get_nghost_particles();

  nvpairmax = ReaxParams::nneighmax * ReaxParams::nat;

  nvpair = 0;
  nvlself = 0;

  for (int i=0;i<nparticles+nghost_particles;i++) {
    i_pnt = p->get_particle(i);
    i_pnt->get_x(xi);
    neighptr = neighbor->first_ptr[i];

    for (int ineigh=0;
	 ineigh<neighbor->nneigh_list[i];ineigh++) {

      j = neighptr[ineigh];
      j_pnt = p->get_particle(j);
      j_pnt->get_x(xj);

      delr2 = vec3_distsq(xi,xj,delr);

      if (delr2 <= rcutvsq) {
	if (i < j) {
	  ii = i+1;
	  jj = j+1;
	} else {
	  ii = j+1;
	  jj = i+1;
	}

	if (nvpair >= nvpairmax) {
	  glog.abort("Force_Reax::WriteReaxVlist:\n"
		     "nvpair >  nneighmax*nat",comm);
	}

	FORTRAN(cbkpairs,CBKPAIRS).nvl1[nvpair]=ii;
	FORTRAN(cbkpairs,CBKPAIRS).nvl2[nvpair]=jj;
	FORTRAN(cbknvlbo,CBKNVLBO).nvlbo[nvpair]=0;
	if (delr2 <= rcutbsq) {
	  FORTRAN(cbknvlbo,CBKNVLBO).nvlbo[nvpair]=1;
	}

	FORTRAN(cbknvlown,CBKNVLOWN).nvlown[nvpair]=0;
	if (Lmidpoint) {
	  // First check if both atoms are local
	  if (jj <= nparticles) {
	    FORTRAN(cbknvlown,CBKNVLOWN).nvlown[nvpair]=1;
	    // If not, do midpoint test
	  } else {
	    vec3_add(xi,xj,rtmp);
	    vec3_scale(0.5,rtmp,rtmp);
	    if (comm->sub_check_strict(b,rtmp)) {
	      FORTRAN(cbknvlown,CBKNVLOWN).nvlown[nvpair]=1;
	    }
	  }
	} else {
	  if (i < nparticles) {
	    if (j < nparticles ) {
	      FORTRAN(cbknvlown,CBKNVLOWN).nvlown[nvpair]=1;
	    } else if (i_pnt->get_tag() < j_pnt->get_tag()) {
	      FORTRAN(cbknvlown,CBKNVLOWN).nvlown[nvpair]=1;
	    } else if (i_pnt->get_tag() == j_pnt->get_tag()) {
	      if (delr[2] > small) {
		FORTRAN(cbknvlown,CBKNVLOWN).nvlown[nvpair]=1;
	      } else if (fabs(delr[2]) < small) {
		if (delr[1] > small) {
		  FORTRAN(cbknvlown,CBKNVLOWN).nvlown[nvpair]=1;
		} else if (fabs(delr[1]) < small) {
		  if (delr[0] > small) 
		    FORTRAN(cbknvlown,CBKNVLOWN).nvlown[nvpair]=1;
		}
	      }
	    }
	  }
	}

	nvpair++;
      }
    }
  }
  FORTRAN(cbkpairs,CBKPAIRS).nvpair=nvpair;
  FORTRAN(cbkpairs,CBKPAIRS).nvlself=nvlself;
}

void Force_Reax::CheckParams() const {
  int nneighmax,nat,nattot,nsort,mbond;

  FORTRAN(getnneighmax,GETNNEIGHMAX)(&nneighmax);
  FORTRAN(getnat,GETNAT)(&nat);
  FORTRAN(getnattot,GETNATTOT)(&nattot);
  FORTRAN(getnsort,GETNSORT)(&nsort);
  FORTRAN(getmbond,GETMBOND)(&mbond);

  if (nneighmax != ReaxParams::nneighmax ||
      nat != ReaxParams::nat ||
      nattot != ReaxParams::nattot ||
      nsort != ReaxParams::nsort ||
      mbond != ReaxParams::mbond ) {
    glog.error("Force_Reax::CheckParams:\n"
	       "nneighmax,nat,nattot,nsort, or mbond \n"
	       " in GRASP does not match params in REAX");
  }
}


void Force_Reax::OutputReaxSizes(Comm* comm) const {
  int nval,ntor,nhb,nbonall,nbon,na,na_local,nvpair;
  enum {nsizes = 8};
  int reaxsizes[nsizes],maxsizes[nsizes],minsizes[nsizes],maxdefsizes[nsizes];
  string namesizes[nsizes];

  na_local = FORTRAN(rsmall,RSMALL).na_local;
  na = FORTRAN(rsmall,RSMALL).na;
  FORTRAN(getnbonall,GETNBONALL)(&nbonall);
  nbon = FORTRAN(rsmall,RSMALL).nbon;
  FORTRAN(getnval,GETNVAL)(&nval);	
  FORTRAN(getntor,GETNTOR)(&ntor);
  FORTRAN(getnhb,GETNHB)(&nhb);	
  nvpair = FORTRAN(cbkpairs,CBKPAIRS).nvpair;

  reaxsizes[0] = na_local;
  reaxsizes[1] = na;
  reaxsizes[2] = nbonall;
  reaxsizes[3] = nbon;
  reaxsizes[4] = nval;	
  reaxsizes[5] = ntor;
  reaxsizes[6] = nhb;	
  reaxsizes[7] = nvpair;	

  maxdefsizes[0] = NATDEF;
  maxdefsizes[1] = NATDEF;
  maxdefsizes[2] = NBOALLMAXDEF;
  maxdefsizes[3] = NBOMAXDEF;
  maxdefsizes[4] = NVAMAXDEF;	
  maxdefsizes[5] = NTOMAXDEF;
  maxdefsizes[6] = NHBMAXDEF;	
  maxdefsizes[7] = NNEIGHMAXDEF*ReaxParams::nat;	

  namesizes[0] = "na_local";
  namesizes[1] = "na      ";
  namesizes[2] = "nbonall ";
  namesizes[3] = "nbon    ";
  namesizes[4] = "nval    ";	
  namesizes[5] = "ntor    ";
  namesizes[6] = "nhb     ";	
  namesizes[7] = "nvpair  ";	

  MPI_Reduce(&reaxsizes[0],&minsizes,nsizes,MPI_INT,MPI_MIN,0,comm->get_world());
  MPI_Reduce(&reaxsizes[0],&maxsizes,nsizes,MPI_INT,MPI_MAX,0,comm->get_world());
 
  if (comm->get_node() == 0) {
    glog.get_logfile() << "\n*************** Table of Latest Reax Sizes *******************************\n"; 
    glog.get_logfile() << "Category\tMinimum\t\tMaximum\t\tAllocated" << "\n";
    for (int i = 0;i < nsizes;i++) {
      glog.get_logfile() << namesizes[i] <<
	"\t\t " << minsizes[i] << "\t\t " << maxsizes[i] << "\t\t" << maxdefsizes[i] << "\n";
    }
        glog.get_logfile() << "**************************************************************************" << endl;
  }
  
  if (comm->get_Lnodefile()) {
    comm->get_nodefile() << "na_local = \t" << na_local << " \t" 
      "reax_defs.h::NATDEF = \t\t" << NATDEF << "\n";
    comm->get_nodefile() << "na = \t\t" << na << " \t" 
      "reax_defs.h::NATDEF = \t\t" << NATDEF << "\n";
    comm->get_nodefile() << "nbonall = \t" << nbonall << " \t" 
      "reax_defs.h::NBOALLMAXDEF = \t" << NBOALLMAXDEF << "\n";
    comm->get_nodefile() << "nbon = \t\t" << nbon << " \t" 
      "reax_defs.h::NBOMAXDEF = \t" << NBOMAXDEF << "\n";
    comm->get_nodefile() << "nval = \t\t" << nval << " \t" 
      "reax_defs.h::NVAMAXDEF = \t" << NVAMAXDEF << "\n";
    comm->get_nodefile() << "ntor = \t\t" << ntor << " \t" 
      "reax_defs.h::NTOMAXDEF = \t" << NTOMAXDEF << "\n";
    comm->get_nodefile() << "nhb = \t\t" << nhb << " \t" 
      "reax_defs.h::NHBMAXDEF = \t" << NHBMAXDEF << "\n";
    comm->get_nodefile() << "nvpair = \t\t" << nvpair << " \t" 
      "reax_defs.h::NNEIGHMAXDEF * nat = \t" <<   NNEIGHMAXDEF * ReaxParams::nat << "\n";
    comm->get_nodefile() << endl;
  }
}

void Force_Reax::set_iprune(const int iprune_in) {
  iprune = iprune_in;
};

void Force_Reax::set_ihb(const int ihb_in) {
  ihb = ihb_in;
};

void Force_Reax::set_hbcut(const double hbcut_in) {
  hbcut = hbcut_in;
};

void Force_Reax::set_Lmidpoint(const bool& Lmidpoint_in) {
  Lmidpoint = Lmidpoint_in;
};

#endif

@


4.17
log
@Fixed problem with hbonds in ReaxFF implementation. Now matches pre-midpoint results
@
text
@d520 1
a520 1
  double rtmp[3],ftmp[3];
d542 1
a542 1
      delr2 = vec3_distsq(xi,xj);
d580 1
a580 1
	    if (j < nparticles || i_pnt->get_tag() < j_pnt->get_tag()) {
d582 13
d598 1
@


4.16
log
@Fixed midpoint bug and eliminated all osx_serial_debug warnings (-Wuninitialized, -Wshadow, ...)
@
text
@d167 3
a169 1
  FORTRAN(getswb,GETSWB)(&rcutmax);
d366 2
a367 1
      rcutcomm = 0.5*rcutmax + neighbor_rskin;
@


4.15
log
@Added commands to control midpoint rule, iprune, ihb and hbcut
@
text
@d699 1
a699 1
void Force_Reax::set_Lmidpoint(const bool Lmidpoint_in) {
@


4.14
log
@Fixed neighbor styles for walls.
@
text
@d114 3
d249 1
a249 1
  FORTRAN(srtbon1,SRTBON1)();
d363 5
a367 1
    rcutcomm = 0.5*rcutmax + neighbor_rskin;
d375 5
d561 14
a574 4
	// First check if both atoms are local
	if (jj <= nparticles) {
	  FORTRAN(cbknvlown,CBKNVLOWN).nvlown[nvpair]=1;
	  // If not, do midpoint test
d576 4
a579 6
	  vec3_add(xi,xj,rtmp);
	  vec3_scale(0.5,rtmp,rtmp);
	  if (comm->sub_check_strict(b,rtmp)) {
	    FORTRAN(cbknvlown,CBKNVLOWN).nvlown[nvpair]=1;	    
	  } else {
	    FORTRAN(cbknvlown,CBKNVLOWN).nvlown[nvpair]=0;
a580 6
// 	  b->Fractional(rtmp,ftmp);
// 	  FORTRAN(cbknvlown,CBKNVLOWN).nvlown[nvpair]=0;
// 	  if (ftmp[0] >= sublo[0] && ftmp[0] < subhi[0]) 
// 	  if (ftmp[1] >= sublo[1] && ftmp[1] < subhi[1]) 
// 	  if (ftmp[2] >= sublo[2] && ftmp[2] < subhi[2]) 
// 	  FORTRAN(cbknvlown,CBKNVLOWN).nvlown[nvpair]=1;
d687 16
d704 1
@


4.13
log
@Cleaned up the midpoint method some more
@
text
@a317 1
  
@


4.12
log
@Implemented midpoint method for ReaxFF
@
text
@a243 2
  FORTRAN(distan,DISTAN)();

@


4.11
log
@Upgraded ReaxFF in Grasp to latest version
@
text
@d246 1
a246 1
  WriteReaxVlist(p,comm);
d312 1
d363 1
d498 1
a498 1
void Force_Reax::WriteReaxVlist(ParticleList* p, Comm* comm) const {
d508 1
d552 19
a571 1

@


4.10
log
@Added atom energy and bonding output for ReaxFF
@
text
@d580 3
a582 3
  int nval,ntor,nhb,nbonall,nbon,na,na_local;
  enum {nsizes = 7};
  int reaxsizes[nsizes],maxsizes[nsizes],minsizes[nsizes];
d592 1
d601 10
d619 1
d626 1
a626 1
    glog.get_logfile() << "Category \t Minimum\t\t Maximum" << "\n";
d629 1
a629 1
	"\t\t " << minsizes[i] << "\t\t " << maxsizes[i] << "\n";
d649 2
@


4.9
log
@Merged ReverseComm_branch back into main branch
@
text
@d445 1
a445 1
  double fvec[3];
d462 1
d464 2
a465 1
    i_pnt->increment_f(fvec);
@


4.8
log
@Added Force_Reax::OutputReaxSizes()
@
text
@d205 3
a207 1
                    const bool& Lenergy, const bool& Lvirial, ParticleList* p, 
a208 1

d230 10
a239 3
    for (int ivirial=0;ivirial<nvirial;ivirial++) {
      virial[ivirial] = 0.0;
    }
d288 8
d300 5
d306 1
d469 25
@


4.8.4.1
log
@Added atom stress for ReaxFF
@
text
@d228 1
a228 1
//   if (Lvirial) {
d232 1
a232 1
//   }
a235 1
  FORTRAN(setatomvirial,SETATOMVIRIAL)();
d279 1
a279 15
//   if (Lvirial) {
//     virial[0] = -FORTRAN(cbkvirial,CBKVIRIAL).virial[0];
//     virial[1] = -FORTRAN(cbkvirial,CBKVIRIAL).virial[4];
//     virial[2] = -FORTRAN(cbkvirial,CBKVIRIAL).virial[8];
//     virial[3] = -FORTRAN(cbkvirial,CBKVIRIAL).virial[1];
//     virial[4] = -FORTRAN(cbkvirial,CBKVIRIAL).virial[2];
//     virial[5] = -FORTRAN(cbkvirial,CBKVIRIAL).virial[5];

    virial[0] = -FORTRAN(cbkvirial,CBKVIRIAL).virial[0];
    virial[1] = -FORTRAN(cbkvirial,CBKVIRIAL).virial[1];
    virial[2] = -FORTRAN(cbkvirial,CBKVIRIAL).virial[2];
    virial[3] = -FORTRAN(cbkvirial,CBKVIRIAL).virial[3];
    virial[4] = -FORTRAN(cbkvirial,CBKVIRIAL).virial[4];
    virial[5] = -FORTRAN(cbkvirial,CBKVIRIAL).virial[5];

d284 1
a284 4

    ReadReaxAtomVirial(p,comm);

//   }
a446 25
void Force_Reax::ReadReaxAtomVirial(ParticleList* p, Comm* comm) {
  double vvec[6];
  int j;
  int nparticles, nghost_particles;
  Particle* i_pnt;

  nparticles = p->get_nparticles();
  nghost_particles = p->get_nghost_particles();

  j = 0;

  for (int i = 0; i < nparticles + nghost_particles; i++) {
    vvec[0] = -FORTRAN(cbkvirial,CBKVIRIAL).atomvirial[j+0];
    vvec[1] = -FORTRAN(cbkvirial,CBKVIRIAL).atomvirial[j+1];
    vvec[2] = -FORTRAN(cbkvirial,CBKVIRIAL).atomvirial[j+2];
    vvec[3] = -FORTRAN(cbkvirial,CBKVIRIAL).atomvirial[j+3];
    vvec[4] = -FORTRAN(cbkvirial,CBKVIRIAL).atomvirial[j+4];
    vvec[5] = -FORTRAN(cbkvirial,CBKVIRIAL).atomvirial[j+5];
    i_pnt = p->get_particle(i);
    i_pnt->increment_virial(vvec);
    j+=6;
  }

}

@


4.8.4.2
log
@Finished adding atomic virial for ReaxFF force field
@
text
@d205 1
a205 3
                    const bool& Lenergy, const bool& Lvirial, 
		    const bool& Latomvirial, 
		    ParticleList* p, 
d207 1
d228 5
a232 12
  if (Lvirial) {
    FORTRAN(cbkvirial,CBKVIRIAL).Lvirial = 1;
  } else {
    FORTRAN(cbkvirial,CBKVIRIAL).Lvirial = 0;
  }

  if (Latomvirial) {
    FORTRAN(cbkvirial,CBKVIRIAL).Lvirial = 1;
    FORTRAN(cbkvirial,CBKVIRIAL).Latomvirial = 1;
  } else {
    FORTRAN(cbkvirial,CBKVIRIAL).Latomvirial = 0;
  }
d236 1
d280 7
a286 1
  if (Lvirial) {
a299 3
  }

  if (Latomvirial) {
a300 1
  }
d302 1
@


4.7
log
@Added better diagnostics for ReaxFF memory footprint.
Output to nodefiles for successful runs (grep reax_def).
Output to standard output for unsuccessful runs.
@
text
@a208 1
  int nval,ntor,nhb,nbonall;
d249 3
a251 20
  if (comm->get_Lnodefile()) {
    comm->get_nodefile() << "na_local = \t" << FORTRAN(rsmall,RSMALL).na_local << " \t" 
      "reax_defs.h::NATDEF = \t\t" << NATDEF << "\n";
    comm->get_nodefile() << "na = \t\t" << FORTRAN(rsmall,RSMALL).na << " \t" 
      "reax_defs.h::NATDEF = \t\t" << NATDEF << "\n";
    FORTRAN(getnbonall,GETNBONALL)(&nbonall);
    comm->get_nodefile() << "nbonall = \t" << nbonall << " \t" 
      "reax_defs.h::NBOALLMAXDEF = \t" << NBOALLMAXDEF << "\n";
    comm->get_nodefile() << "nbon = \t\t" << FORTRAN(rsmall,RSMALL).nbon << " \t" 
      "reax_defs.h::NBOMAXDEF = \t" << NBOMAXDEF << "\n";
    FORTRAN(getnval,GETNVAL)(&nval);	
    comm->get_nodefile() << "nval = \t\t" << nval << " \t" 
      "reax_defs.h::NVAMAXDEF = \t" << NVAMAXDEF << "\n";
    FORTRAN(getntor,GETNTOR)(&ntor);
    comm->get_nodefile() << "ntor = \t\t" << ntor << " \t" 
      "reax_defs.h::NTOMAXDEF = \t" << NTOMAXDEF << "\n";
    FORTRAN(getnhb,GETNHB)(&nhb);	
    comm->get_nodefile() << "nhb = \t\t" << nhb << " \t" 
      "reax_defs.h::NHBMAXDEF = \t" << NHBMAXDEF << "\n";
    comm->get_nodefile() << endl;
d253 1
a253 1
	
d528 64
@


4.6
log
@Added multiple replica feature.
@
text
@d209 1
a209 1
  int nval,ntor;
d251 9
a259 1
    comm->get_nodefile() << "nbon = " << FORTRAN(rsmall,RSMALL).nbon << endl;
d261 2
a262 1
    comm->get_nodefile() << "nval = " << nval << endl;
d264 7
a270 3
    comm->get_nodefile() << "ntor = " << ntor << endl;

       }
@


4.5
log
@Added some new barostats and thermostats.
@
text
@d135 1
a135 1
    glog.logfile << endl;
d348 4
a351 4
      glog.logfile << "Cutoffs for this forcefield" << endl;
      glog.logfile << "rcutmax = " << rcutmax << endl;
      glog.logfile << "rskin = " << neighbor_rskin << endl;
      glog.logfile << "rcutneighmax = " << rcutneighmax << endl;
@


4.4
log
@ReaxFF: Provided atom tags to ReaxFF common blocks
@
text
@d247 2
@


4.3
log
@Miscellaneous fixes
@
text
@d419 1
@


4.2
log
@Added prototype for Force_PPPM class
@
text
@a295 2
  double vrange;
  int nvlist;
a341 12
    FORTRAN(getvrange,GETVRANGE)(&vrange);
    if (vrange != neighbor_rskin) {
      glog.logfile << "rskin = " << neighbor_rskin << endl;
      glog.logfile << "vrange = " << vrange << endl;
      glog.error("Force_Reax::SetupNeighbor:\n"
		 "neighbor_rskin in GRASP does not match vrange in REAX");
    }
    FORTRAN(getnvlist,GETNVLIST)(&nvlist);
    if (nvlist != neighbor_freq) {
      glog.error("Force_Reax::SetupNeighbor:\n"
		 "neighbor_freq in GRASP does not match nvlist in REAX");
    }
@


4.2.2.1
log
@Added ParticleList to ForceField::SetupInterations()
@
text
@d154 1
a154 2
void Force_Reax::SetupInteractions(const ParticleList* p, 
				      const Box* b, 
@


4.2.2.2
log
@Latest PPPM version
@
text
@d154 1
a154 1
void Force_Reax::SetupInteractions(ParticleList* p, 
d156 1
a156 1
                                      double& g_ewald, 
d207 1
a207 1
		    const Box* b, double& g_ewald, Comm* comm) {
@


4.1
log
@Fixed glitch in header.
@
text
@d155 2
a156 2
				   const Force_Ewald* ff_ewald,
				   Comm* comm) {
@


4.1.4.1
log
@Correct a few things.
@
text
@a543 10

void Force_Reax::EnergyChange(int* atom, double boost[3],
				 const bool& Lenergy,
				 ParticleList* p,const Box* b, Comm* comm) {
  glog.error("Force_Twobody::EnergyChange:\n"
	     "Not implemented yet");
}



@


4.1.4.2
log
@Added EAM energy change calculation
@
text
@a96 1
  energy_save.resize(npieces);
@


4.1.4.3
log
@Improved performance of MC moves and turned on periodic output
@
text
@d546 9
@


4.0
log
@This is version 4.0
@
text
@d43 1
a43 1
//------------------------------------------------------------------------ 
@


3.3
log
@Merged REAX version with main version
@
text
@d16 1
a16 1
//    Author: Aidan P. Thompson
d20 4
a23 4
//    Copyright (2004) Sandia National Laboratories
//   
//    Sandia is a multiprogram laboratory operated by 
//    Sandia Corporation, a Lockheed Martin company,
d27 16
@


3.2
log
@Removed files inadvertently added to main branch
@
text
@d13 2
a14 2
//    Timestamp: September 22, 2004
//    Version: 3.0
d30 1
d63 1
d67 1
d79 1
a79 1
  npieces = 1;
d82 13
a94 1
  label_piece[0] = "n/a";
d123 13
d139 2
a140 2
				      const Force_Ewald* ff_ewald,
                                      Comm* comm) {
a145 8
  FORTRAN(version,VERSION)();
  FORTRAN(readc,READC)();
  FORTRAN(init,INIT)();
  FORTRAN(ffinpt,FFINPT)();
  FORTRAN(tap7th,TAP7TH)();
  FORTRAN(readgeo,READGEO)();
  FORTRAN(srtatom,SRTATOM)();

d157 2
d170 1
a170 1
  rcutvsq = pow(rcutmax+rskin,2);
a191 7
  double f[3];
  double energy_ij;
  double virial_ij[nvirial];
  int itype,jtype,ientry;
  ForceFieldTypes reax_type;
  int i,j,image;
  double xi[3],xj[3];
d193 1
a193 5
  Particle* i_pnt;
  Particle* j_pnt;
  int nparticles;
  int* neighptr;
  double qi,qj,energy_coul_ij;
d199 12
a210 3
    if (Lcoul) {
      energy_piece[1] = 0.0;
    }
a226 1
  //  comm->reverse_comm_double_add(FORTRAN(cbkabo,CBKABO).abo);
a228 11
  if (comm->get_Lnodefile()) {
    comm->get_nodefile() << "total atom bond orders after comm" << endl;
    for (int i = 0;i < p->get_nparticles()+p->get_nghost_particles();i++) {
      i_pnt = p->get_particle(i);
      comm->get_nodefile() << i << " " << 
	p->get_usertag(i_pnt->get_tag()) << 
	" " << type_index[i_pnt->get_type()]+1 << " " <<
	FORTRAN(cbkabo,CBKABO).abo[i] << endl;
    }
  }

a229 1
  //  FORTRAN(charges,CHARGES)();
d232 9
d244 16
d300 1
a300 1
    neighbor = new Neighbor(Neighbor::neighbor_nsq_ghost,
d388 2
a389 1
  FORTRAN(small,SMALL).na = nparticles+nghost_particles;
d414 1
d437 3
a439 3
    fvec[0] = FORTRAN(cbkd,CBKD).d[j+jx];
    fvec[1] = FORTRAN(cbkd,CBKD).d[j+jy];
    fvec[2] = FORTRAN(cbkd,CBKD).d[j+jz];
d456 1
d461 2
d489 5
a495 3
	FORTRAN(cbknvl,CBKNVL).nvlx[nvpair]=0;
	FORTRAN(cbknvl,CBKNVL).nvly[nvpair]=0;
	FORTRAN(cbknvl,CBKNVL).nvlz[nvpair]=0;
d501 1
d508 21
@


3.2.2.1
log
@Test addition
@
text
@@


3.2.2.2
log
@Completed prototype of parallel ReaxFF in GRASP, including charge equilibration
@
text
@a61 1
#include "reax_cbkch.h"
a64 1
#include "reax_energies.h"
a222 1
  ComputeCharges(p,comm);
d268 1
a268 1
    neighbor = new Neighbor(Neighbor::neighbor_bin_ghost,
a467 255

void Force_Reax::ComputeCharges(ParticleList* p, Comm* comm) {
  double xi[3],xj[3];
  int nparticles;
  Particle* i_pnt;
  Particle* j_pnt;
  int nvpair,nvlself;
  int* neighptr;
  int jj;
  int itag,jtag,itype,jtype;
  double delr2,rcutsq,delr_norm,gamt,hulp1,hulp2;
  double elcvec[ReaxParams::neem],chgglobal[ReaxParams::neem];

  int nparticles_tot,nbuf,iperatom,most,j;
  vector<double> buf;
  Particle* p_pnt;
  int node,nprocs,nlocal_tmp,itmp;
  MPI_Comm world;
  MPI_Request irequest;
  MPI_Status istatus;

  node = comm->get_node();
  world = comm->get_world();
  nprocs = comm->get_nprocs();

  rcutsq = rcutmax*rcutmax;

  nparticles = p->get_nparticles();
  nparticles_tot = p->get_nparticles_tot();

  // Note: xmortr[i][j] is matrix element in row j+1, column i+1
  // The system Ax==b looks like this:
  //
  //  |a11 ...  a1n 1|  |q1|   | b1 |
  //  |:            :| x| :| = | :  |
  //  |:            :| x| :| = | :  |
  //  |an1 ...  ann 1|  |qn|   | bn |
  //  | 1  ...   1  0|  |mu|   |qtot|
  //
  // We compute the lower triangular part and then copy it up.
  // Could also write it as a two linear symmetric linear systems
  // with the same A and different b's
  //
  // Initialize global linear system
  FORTRAN(cbkm,CBKM).xmortr[nparticles_tot][nparticles_tot] = 0.0;

  for (int i=0;i<nparticles_tot;i++) {
    FORTRAN(cbkm,CBKM).xmortr[i][nparticles_tot] = 1.0;
  }

  for (int i=0;i<nparticles_tot+1;i++) {
    elcvec[i] = 0.0;
    for (int j=i;j<nparticles_tot;j++) {
	FORTRAN(cbkm,CBKM).xmortr[i][j] = 0.0;
    }
  }
	  
  // Add local entries to global linear system
  for (int i=0;i<nparticles;i++) {
    i_pnt = p->get_particle(i);
    i_pnt->get_x(xi);
    itag = i_pnt->get_tag();
    itype = type_index[i_pnt->get_type()];
 
    FORTRAN(cbkm,CBKM).xmortr[itag][itag] =
      2.0*FORTRAN(cbkchb,CBKCHB).eta[itype];
    elcvec[itag] = -FORTRAN(cbkchb,CBKCHB).chi[itype];
  }

  for (int i=0;i<nparticles;i++) {
    i_pnt = p->get_particle(i);
    i_pnt->get_x(xi);
    itag = i_pnt->get_tag();
    itype = type_index[i_pnt->get_type()];
    neighptr = neighbor->first_ptr[i];

    for (int ineigh=0;
	 ineigh<neighbor->nneigh_list[i];ineigh++) {

      j = neighptr[ineigh];
      j_pnt = p->get_particle(j);
      j_pnt->get_x(xj);

      delr2 = vec3_distsq(xi,xj);

      if (delr2 <= rcutsq) {
	jtag = j_pnt->get_tag();
	jtype = type_index[j_pnt->get_type()];
	gamt=sqrt(FORTRAN(cbkchb,CBKCHB).gam[itype]*
		  FORTRAN(cbkchb,CBKCHB).gam[jtype]);
	delr_norm = sqrt(delr2);
	FORTRAN(taper,TAPER)(&delr_norm,&delr2);
	hulp1=(delr_norm*delr2+(1.0/(gamt*gamt*gamt)));
	hulp2=FORTRAN(cbkenergies,CBKENERGIES).sw*14.40/cbrt(hulp1);
	if (j < nparticles) {
	  FORTRAN(cbkm,CBKM).xmortr[itag][jtag]+=hulp2;
	} else {
	  if (itag <= jtag) {
	    FORTRAN(cbkm,CBKM).xmortr[itag][jtag]+=0.5*hulp2;
	  } else {
	    FORTRAN(cbkm,CBKM).xmortr[jtag][itag]+=0.5*hulp2;
	  }
	}
      }
    }
  }

  // Complete symmetric image of global linear system
  for (int i=0;i<nparticles_tot+1;i++) {
    for (int j=0;j<i;j++) {
      FORTRAN(cbkm,CBKM).xmortr[i][j] = 
	FORTRAN(cbkm,CBKM).xmortr[j][i];
    }
  }

  // Output to node file
  if (comm->get_Lnodefile()) {
    comm->get_nodefile() << "Elements" << endl;
    for (int i=0;i<nparticles_tot+1;i++) {
      for (int j=0;j<nparticles_tot+1;j++) {
	comm->get_nodefile() << 
	  FORTRAN(cbkm,CBKM).xmortr[i][j] << endl;
      }
      comm->get_nodefile() << "\n" << elcvec[i] << "\n" << endl;
    }
  }

  // Compute own buffer size	  
  jj = 0;
  for (int i=0;i<nparticles_tot+1;i++) {
    for (int j=i;j<nparticles_tot;j++) {
      if (FORTRAN(cbkm,CBKM).xmortr[i][j] != 0.0) {
	jj++;
      }
    }
    if (elcvec[i] != 0.0) {
      jj++;
    }
  }
	  
  // Allocate maximum buffer size
  iperatom = 3;
  MPI_Allreduce(&jj,&most,1,MPI_INT,MPI_MAX,comm->get_world());
  nbuf = iperatom*most;
  buf.resize(nbuf);

  // Copy local entries to buffer.
  jj = 0;
  for (int i=0;i<nparticles_tot+1;i++) {
    for (int j=i;j<nparticles_tot;j++) {
      if (FORTRAN(cbkm,CBKM).xmortr[i][j] != 0.0) {
	buf[jj] = i;
	buf[jj+1] = j;
	buf[jj+2] = FORTRAN(cbkm,CBKM).xmortr[i][j];
	jj+=iperatom;
      }
    }
    if (elcvec[i] != 0.0) {
      buf[jj] = i;
      buf[jj+1] = -1;
      buf[jj+2] = elcvec[i];
      jj+=iperatom;
    }
  }
	  
  //c node 0 pings each node, receives their buffer, writes to file
  //c  all other nodes wait for ping, send buffer to node 0

  if (node == 0) {

    // Re-initialize global linear system

    for (int i=0;i<nparticles_tot+1;i++) {
      elcvec[i] = 0.0;
      for (int j=i;j<nparticles_tot;j++) {
	FORTRAN(cbkm,CBKM).xmortr[i][j] = 0.0;
      }
    }
	  
    for (int inode = 0;inode<nprocs;inode++) {
      if (inode == 0) {
	nlocal_tmp = jj/iperatom;
      } else {
	MPI_Irecv(&buf[0],nbuf,MPI_DOUBLE,inode,0,world,&irequest);
        MPI_Send(&itmp,0,MPI_INT,inode,0,world);
        MPI_Wait(&irequest,&istatus);
        MPI_Get_count(&istatus,MPI_DOUBLE,&nlocal_tmp);
	nlocal_tmp = nlocal_tmp/iperatom;
      }

      jj = 0;
      for (int i=0;i<nlocal_tmp;i++) {
	itag = nint(buf[jj]);
	jtag = nint(buf[jj+1]);
	if (jtag == -1) {
	  elcvec[itag] = buf[jj+2];
	} else {
	  FORTRAN(cbkm,CBKM).xmortr[itag][jtag] += buf[jj+2];
	}
	jj+=iperatom;
      }
    }  
  } else {
    MPI_Recv(&itmp,0,MPI_INT,0,0,world,&istatus);
    MPI_Rsend(&buf[0],jj,MPI_DOUBLE,0,0,world);
  }

  if (node == 0) {
    // Complete symmetric image of global linear system
    for (int i=0;i<nparticles_tot+1;i++) {
      for (int j=0;j<i;j++) {
	FORTRAN(cbkm,CBKM).xmortr[i][j] = 
	  FORTRAN(cbkm,CBKM).xmortr[j][i];
      }
    }

    // Output to node file
    if (comm->get_Lnodefile()) {
      comm->get_nodefile() << "Elements" << endl;
      for (int i=0;i<nparticles_tot+1;i++) {
	for (int j=0;j<nparticles_tot+1;j++) {
	  comm->get_nodefile() << 
	    FORTRAN(cbkm,CBKM).xmortr[i][j] << endl;
	}
	comm->get_nodefile() << "\n" << elcvec[i] << "\n" << endl;
      }
    }

    // Solve global linear system for charges
    FORTRAN(chargrasp,CHARGRASP)(&nparticles_tot,elcvec,chgglobal);

    // Output charges to node file
    if (comm->get_Lnodefile()) {
      comm->get_nodefile() << "Charges" << endl;
      for (int i=0;i<nparticles_tot;i++) {
	comm->get_nodefile() << 
	  chgglobal[i] << endl;
      }
    }
	  
  }

  MPI_Bcast(&chgglobal[0],nparticles_tot,MPI_DOUBLE,0,comm->get_world());
  
  // Copy charges to local list
  for (int i=0;i<nparticles;i++) {
    i_pnt = p->get_particle(i);
    itag = i_pnt->get_tag();
    FORTRAN(cbkch,CBKCH).ch[i] = chgglobal[itag];
    i_pnt->set_charge(chgglobal[itag]);
  }

  comm->comm_double(FORTRAN(cbkch,CBKCH).ch);

}
@


3.2.2.3
log
@Added REAXFF energy evaluation to Grasp
@
text
@d78 1
a78 1
  npieces = 14;
d81 1
a81 14
  label_piece[0] = "Ebond";
  label_piece[1] = "Eatom";
  label_piece[2] = "Elp";
  label_piece[3] = "Emol";
  label_piece[4] = "Eval";
  label_piece[5] = "Epen";
  label_piece[6] = "Ecoa";
  label_piece[7] = "Ehbo";
  label_piece[8] = "Etors";
  label_piece[9] = "Econj";
  label_piece[10] = "Evdw";
  label_piece[11] = "Ecoul";
  label_piece[12] = "Echarge";
  label_piece[13] = "Efield";
d190 3
a192 13
    energy_piece[1] = 0.0;
    energy_piece[2] = 0.0;
    energy_piece[3] = 0.0;
    energy_piece[4] = 0.0;
    energy_piece[5] = 0.0;
    energy_piece[6] = 0.0;
    energy_piece[7] = 0.0;
    energy_piece[8] = 0.0;
    energy_piece[9] = 0.0;
    energy_piece[10] = 0.0;
    energy_piece[11] = 0.0;
    energy_piece[12] = 0.0;
    energy_piece[13] = 0.0;
a230 17
    energy_piece[0] = FORTRAN(cbkenergies,CBKENERGIES).eb;
    energy_piece[1] = FORTRAN(cbkenergies,CBKENERGIES).ea;
    energy_piece[2] = FORTRAN(cbkenergies,CBKENERGIES).elp;
    energy_piece[3] = FORTRAN(cbkenergies,CBKENERGIES).emol;
    energy_piece[4] = FORTRAN(cbkenergies,CBKENERGIES).ev;
    energy_piece[5] = FORTRAN(cbkenergies,CBKENERGIES).epen;
    energy_piece[6] = FORTRAN(cbkenergies,CBKENERGIES).ecoa;
    energy_piece[7] = FORTRAN(cbkenergies,CBKENERGIES).ehb;
    energy_piece[8] = FORTRAN(cbkenergies,CBKENERGIES).et;
    energy_piece[9] = FORTRAN(cbkenergies,CBKENERGIES).eco;
    energy_piece[10] = FORTRAN(cbkenergies,CBKENERGIES).ew;
    energy_piece[11] = FORTRAN(cbkenergies,CBKENERGIES).ep;
    energy_piece[12] = FORTRAN(cbkcha,CBKCHA).ech;
    energy_piece[13] = FORTRAN(cbkenergies,CBKENERGIES).efi;
  }

  if (Lenergy) {
a359 1
  FORTRAN(small,SMALL).na_local = nparticles;
a714 2
  FORTRAN(cbkcha,CBKCHA).ech=0.0;

a720 6
    itype = type_index[i_pnt->get_type()];
    FORTRAN(cbkcha,CBKCHA).ech+=23.02*(
            FORTRAN(cbkchb,CBKCHB).chi[itype]*
	    chgglobal[itag]+
	    FORTRAN(cbkchb,CBKCHB).eta[itype]*
            chgglobal[itag]*chgglobal[itag]);
@


3.2.2.4
log
@Added energies to Reax code, added kcal unit style and added
the example testrdx to Makefile.testing
@
text
@d235 10
a244 10
//   if (comm->get_Lnodefile()) {
//     comm->get_nodefile() << "total atom bond orders after comm" << endl;
//     for (int i = 0;i < p->get_nparticles()+p->get_nghost_particles();i++) {
//       i_pnt = p->get_particle(i);
//       comm->get_nodefile() << i << " " << 
// 	p->get_usertag(i_pnt->get_tag()) << 
// 	" " << type_index[i_pnt->get_type()]+1 << " " <<
// 	FORTRAN(cbkabo,CBKABO).abo[i] << endl;
//     }
//   }
d447 3
a449 3
    fvec[0] = -FORTRAN(cbkd,CBKD).d[j+jx];
    fvec[1] = -FORTRAN(cbkd,CBKD).d[j+jy];
    fvec[2] = -FORTRAN(cbkd,CBKD).d[j+jz];
d628 10
a637 10
//   if (comm->get_Lnodefile()) {
//     comm->get_nodefile() << "Elements" << endl;
//     for (int i=0;i<nparticles_tot+1;i++) {
//       for (int j=0;j<nparticles_tot+1;j++) {
// 	comm->get_nodefile() << 
// 	  FORTRAN(cbkm,CBKM).xmortr[i][j] << endl;
//       }
//       comm->get_nodefile() << "\n" << elcvec[i] << "\n" << endl;
//     }
//   }
d729 10
a738 10
//     if (comm->get_Lnodefile()) {
//       comm->get_nodefile() << "Elements" << endl;
//       for (int i=0;i<nparticles_tot+1;i++) {
// 	for (int j=0;j<nparticles_tot+1;j++) {
// 	  comm->get_nodefile() << 
// 	    FORTRAN(cbkm,CBKM).xmortr[i][j] << endl;
// 	}
// 	comm->get_nodefile() << "\n" << elcvec[i] << "\n" << endl;
//       }
//     }
d744 7
a750 7
//     if (comm->get_Lnodefile()) {
//       comm->get_nodefile() << "Charges" << endl;
//       for (int i=0;i<nparticles_tot;i++) {
// 	comm->get_nodefile() << 
// 	  chgglobal[i] << endl;
//       }
//     }
@


3.2.2.5
log
@Finished optimized implementation of ReaxFF.
Eliminates O(N^2) scaling of srttor and srtang.
Also blanks out the ghost bonds that are not in dihedral
with local atom.
@
text
@d163 1
a163 1
  rcutvsq = rcutmax*rcutmax;
d498 3
a505 1

@


3.2.2.6
log
@Modified use of nat to allow treatment of big parallel systems.
@
text
@a412 5
  if (ReaxParams::nat > ReaxParams::nattot) {
    glog.abort("Force_Reax::WriteReaxPositions:\n"
	       "ReaxParams::nat greater than ReaxParams::nattot");
  }

d415 2
a416 2
  jy = ReaxParams::nattot;
  jz = 2*ReaxParams::nattot;
@


3.2.2.7
log
@Separated charge equilibration part of REAXFF into separate force field.
@
text
@d78 1
a78 1
  npieces = 13;
d93 2
a94 1
  label_piece[12] = "Efield";
a122 9

  FORTRAN(version,VERSION)();
  FORTRAN(readc,READC)();
  FORTRAN(init,INIT)();
  FORTRAN(ffinpt,FFINPT)();
  FORTRAN(tap7th,TAP7TH)();
  FORTRAN(readgeo,READGEO)();
  FORTRAN(srtatom,SRTATOM)();

d133 8
d185 7
d193 5
d215 1
a234 1
//   Particle* i_pnt;
d247 2
d266 2
a267 1
    energy_piece[12] = FORTRAN(cbkenergies,CBKENERGIES).efi;
d516 262
@


3.2.2.8
log
@Implemented a parallel CG scheme. Does not exploit sparsity and
so is still quite slow.
@
text
@a414 1
    FORTRAN(cbkch,CBKCH).ch[j] = i_pnt->get_charge();
@


3.2.2.9
log
@Added and removed some nodefile diagnostics.
@
text
@a185 1
  int nval,ntor;
a236 9
  if (comm->get_Lnodefile()) {
    comm->get_nodefile() << "nbon = " << FORTRAN(small,SMALL).nbon << endl;
    FORTRAN(getnval,GETNVAL)(&nval);	
    comm->get_nodefile() << "nval = " << nval << endl;
    FORTRAN(getntor,GETNTOR)(&ntor);
    comm->get_nodefile() << "ntor = " << ntor << endl;

       }
	
@


3.2.2.10
log
@Cleaned up charge eequilibration, removed some FORTRAN allocations
@
text
@d220 1
d223 12
@


3.2.2.11
log
@Added various things to make Grasp/REAXFF run on Blue Gene
@
text
@d226 1
a226 1
    comm->get_nodefile() << "nbon = " << FORTRAN(rsmall,RSMALL).nbon << endl;
d381 2
a382 2
  FORTRAN(rsmall,RSMALL).na = nparticles+nghost_particles;
  FORTRAN(rsmall,RSMALL).na_local = nparticles;
@


3.2.2.12
log
@Streamlined memory for global and local data
@
text
@a124 1

d128 2
a129 4
  if (node == 0) {
    FORTRAN(readgeo,READGEO)();
  }
  // FORTRAN(srtatom,SRTATOM)();
d395 5
d402 2
a403 2
  jy = ReaxParams::nat;
  jz = 2*ReaxParams::nat;
@


3.2.2.13
log
@Greatly reduced memory usage.
@
text
@a451 1
  int nvpairmax;
a455 2
  nvpairmax = ReaxParams::nneighmax * ReaxParams::nat;

a481 5
	if (nvpair >= nvpairmax) {
	  glog.abort("Force_Reax::WriteReaxVlist:\n"
		     "nvpair >  nneighmax*nat",comm);
	}

@


3.2.2.14
log
@Removed version() from distribution
@
text
@d122 2
@


3.2.2.15
log
@Added some error checking and some memory efficiency.
@
text
@a152 2
  
  CheckParams();
a502 19
void Force_Reax::CheckParams() const {
  int nneighmax,nat,nattot,nsort,mbond;

  FORTRAN(getnneighmax,GETNNEIGHMAX)(&nneighmax);
  FORTRAN(getnat,GETNAT)(&nat);
  FORTRAN(getnattot,GETNATTOT)(&nattot);
  FORTRAN(getnsort,GETNSORT)(&nsort);
  FORTRAN(getmbond,GETMBOND)(&mbond);

  if (nneighmax != ReaxParams::nneighmax ||
      nat != ReaxParams::nat ||
      nattot != ReaxParams::nattot ||
      nsort != ReaxParams::nsort ||
      mbond != ReaxParams::mbond ) {
    glog.error("Force_Reax::CheckParams:\n"
	       "nneighmax,nat,nattot,nsort, or mbond \n"
	       " in GRASP does not match params in REAX");
  }
}
@


3.2.2.16
log
@Separated charge equilibration input from REAX
@
text
@a130 3
  glog.warning("Force_Reax::ReadInteractions:\n"
	     "Remember, order of atoms in types.in and fort.4 must match;\n"
	       "fort.4 must contain at least all the types in types.in");
d135 2
a136 2
				   const Force_Ewald* ff_ewald,
				   Comm* comm) {
@


3.1
log
@Finally, this is the REAXFF branch, first pass
@
text
@@

