head	4.6;
access;
symbols
	ReverseComm_branch:4.4.0.6
	ADTools_branch:4.4.0.4
	Monaco_Aidan:4.3.2.1.0.2
	Root-of-Monaco_Aidan:4.3.2.1
	PPPM_Crozier2:4.4.0.2
	PPPM_Crozier:4.4
	Root-of-PPPM_Crozier:4.4
	Monaco:4.3.0.2
	PreMonaco:4.3
	Recovery-2004-04-12:4.0
	BRANCH:4.1.0.4
	PMONACO:4.1.0.2
	ROOT:4.1
	initial:4.0.0.2
	pmonaco:4.0
	Version_4_0:4.0
	Version_3_0:3.0
	BeforeREAXMerge:3.1
	REAX-2:3.1
	P_MonacoSource:3.1.0.6
	GraspSource:3.1
	P_Monaco:3.1.0.4
	InitialGrasp:3.1
	REAXFF:3.1.0.2
	premerge_cjkimme_version:3.0
	CRAY:2.15.0.2
	cjkimme_version_merge_from_trunk_1:2.9.2.1
	cjkimme_version:2.9.0.2;
locks; strict;
comment	@ * @;


4.6
date	2007.05.30.05.41.46;	author athomps;	state Exp;
branches;
next	4.5;

4.5
date	2006.11.09.20.13.52;	author athomps;	state Exp;
branches;
next	4.4;

4.4
date	2005.06.08.20.08.48;	author athomps;	state Exp;
branches
	4.4.2.1
	4.4.6.1;
next	4.3;

4.3
date	2005.05.03.16.28.27;	author athomps;	state Exp;
branches
	4.3.2.1;
next	4.2;

4.2
date	2005.05.02.20.13.38;	author athomps;	state Exp;
branches;
next	4.1;

4.1
date	2005.04.12.22.26.04;	author saubry;	state Exp;
branches;
next	4.0;

4.0
date	2005.04.05.16.43.30;	author athomps;	state Exp;
branches;
next	3.2;

3.2
date	2005.04.02.00.37.56;	author athomps;	state Exp;
branches;
next	3.1;

3.1
date	2004.10.22.22.30.16;	author cjkimme;	state Exp;
branches
	3.1.6.1;
next	3.0;

3.0
date	2004.09.22.17.56.49;	author athomps;	state Exp;
branches;
next	2.15;

2.15
date	2004.08.13.21.52.19;	author athomps;	state Exp;
branches;
next	2.14;

2.14
date	2004.07.26.15.52.18;	author athomps;	state Exp;
branches;
next	2.13;

2.13
date	2004.05.20.22.11.33;	author athomps;	state Exp;
branches;
next	2.12;

2.12
date	2004.03.20.00.15.38;	author athomps;	state Exp;
branches;
next	2.11;

2.11
date	2004.03.02.17.49.47;	author athomps;	state Exp;
branches;
next	2.10;

2.10
date	2004.03.01.18.13.34;	author athomps;	state Exp;
branches;
next	2.9;

2.9
date	2004.01.28.20.36.13;	author athomps;	state Exp;
branches
	2.9.2.1;
next	2.8;

2.8
date	2004.01.09.19.01.08;	author athomps;	state Exp;
branches;
next	2.7;

2.7
date	2003.11.26.22.51.14;	author athomps;	state Exp;
branches;
next	2.6;

2.6
date	2003.10.04.02.46.52;	author athomps;	state Exp;
branches;
next	2.5;

2.5
date	2003.09.19.23.35.18;	author athomps;	state Exp;
branches;
next	2.4;

2.4
date	2003.08.14.22.50.23;	author athomps;	state Exp;
branches;
next	2.3;

2.3
date	2003.08.01.16.22.01;	author athomps;	state Exp;
branches;
next	2.2;

2.2
date	2003.07.22.22.27.41;	author athomps;	state Exp;
branches;
next	2.1;

2.1
date	2003.06.17.19.08.11;	author athomps;	state Exp;
branches;
next	2.0;

2.0
date	2003.04.24.17.19.15;	author athomps;	state Exp;
branches;
next	1.3;

1.3
date	2003.03.17.17.14.18;	author athomps;	state Exp;
branches;
next	1.2;

1.2
date	2003.03.03.20.32.39;	author athomps;	state Exp;
branches;
next	1.1;

1.1
date	2003.02.18.23.15.17;	author athomps;	state Exp;
branches;
next	;

2.9.2.1
date	2004.09.13.23.00.09;	author cjkimme;	state Exp;
branches;
next	2.9.2.2;

2.9.2.2
date	2004.10.20.23.14.05;	author cjkimme;	state Exp;
branches;
next	;

3.1.6.1
date	2005.02.17.21.41.38;	author saubry;	state Exp;
branches;
next	3.1.6.2;

3.1.6.2
date	2005.02.24.21.03.59;	author saubry;	state Exp;
branches;
next	;

4.3.2.1
date	2005.05.03.21.44.53;	author athomps;	state Exp;
branches
	4.3.2.1.2.1;
next	;

4.3.2.1.2.1
date	2005.10.21.15.44.43;	author saubry;	state Exp;
branches;
next	4.3.2.1.2.2;

4.3.2.1.2.2
date	2006.02.15.21.34.48;	author athomps;	state Exp;
branches;
next	;

4.4.2.1
date	2005.06.20.22.41.00;	author athomps;	state Exp;
branches;
next	4.4.2.2;

4.4.2.2
date	2005.06.21.21.46.18;	author pscrozi;	state Exp;
branches;
next	;

4.4.6.1
date	2006.11.09.00.20.53;	author athomps;	state Exp;
branches;
next	;


desc
@@


4.6
log
@Implemented midpoint method for ReaxFF
@
text
@//-----------------------------------------------------------------------
//
//   G R A S P
//   ____________
//   \           \
//    \ General   \
//     \ Reactive  \
//      \ Atomistic \
//       \ Simulation\
//        \ Program   \
//         \___________\
//
//    Timestamp: April 1, 2005
//    Version: 4.0
//
//    Primary Author: Aidan P. Thompson
//
//    e-mail: athomps@@sandia.gov
//   
//    Copyright (2005) Sandia National Laboratories
//
//    Sandia National Laboratories is a multiprogram laboratory 
//    operated by Sandia Corporation, a Lockheed Martin company,
//    for the United States Department of Energy under contract
//    No. DE-AC04-94AL-85000.
//
//    Under the terms of Contract DE-AC04-94AL85000 with Sandia 
//    Corporation, the U.S. Government retains certain rights in 
//    this software.
//
//    This software is distributed under the terms of the GNU Public 
//    License (GPL). For a copy of the GPL see the file 
//    Grasp/Documentation/LICENSE or visit the GNU website at 
//    http://www.gnu.org/copyleft/gpl.html. Briefly, the GPL 
//    entitles you to use the software, modify it and redistribute it. 
//    The main thing you can not do is apply any other licensing 
//    terms to the software. Also, if any part of this sofware is added 
//    to other software, then that software must also be released under 
//    the GPL.
//
//    This software comes with no warranty of any kind. 
//
//----------------------------------------------------------------------- 
/////:EOH~

#ifndef FORCE_THREEBODY_H
#define FORCE_THREEBODY_H

class Particle_Types;
class Box;

// Data structure for three-body force fields
// Derived from ForceField base class.
class Force_Threebody: public ForceField {
 public:
  // List of allowable forcefield types. Several types
  // can be used in a single simulation.
  //
  // enum class for force field types
  enum ForceFieldTypes {sw_cut};
 private:
  struct ff_params {ForceFieldTypes type;int np;double* params;};
  //Array of ff_params created on input 
  vector<ff_params> input_param_list;
  //Array of ff_params created in SetupInteractions
  int nentries;
  vector<ff_params> param_list;
  //3-D array of pointers to elements in input_param_list, 
  // indexed by three particle types
  int*** input_param_index;
  //3-D array of pointers to elements in param_list 
  // indexed by three particle types
  int*** param_index;
 public:

  Force_Threebody(const string);
  ~Force_Threebody();
  void SetupCutNeighSq(const double&, Comm*);

  int get_entry(const int&, const int&, const int&) const;

  void ApplyForce(const bool&, const bool&, const bool&, 
		  ParticleList*, 
		  const Box*, Comm*);
  void ApplyPartialForce(const bool&, const bool&, const bool&, 
			 ParticleList*,
	                 const Box*, Comm*);
  void ReadInteractions(Comm*);
  void SetupInteractions(const Box*, const double&, Comm*);
  void SetupNeighbor(const string&, const int&,const double&, 
                        double&, double&, const Box*, Comm*);
  void force_sw_cut(const double[], const double[], const double[], 
		       double[], double[], 
		    const bool&, const bool&, double&, double[], double[],
		    const int&) const;
  void force_sw_twobody_cut(const double[], const double[], double[], 
		    const bool&, const bool&, double&, double[],
		    const int&) const;
  void force_sw_cut_minimg(const Particle&,const Particle&,const Particle&, 
                    double[],double[],
			   const bool&, const bool&, double&, double[], double[],
                    const int&, const Box*) const;
  void force_sw_twobody_cut_minimg(const Particle&, const Particle&, 
                    double[],
		    const bool&, const bool&, double&, double[],
                    const int&, const Box*) const;
  void sw_cut_cross_setup(const double&, const double&, const double&, 
		    const double&, const double&, const double&, 
		    ff_params&);
  void sw_cut_pure_setup(const double&, const double&, const double&, 
		    const double&, const double&, const double&, 
		    const double&, const double&, const double&, 
		    const double&, ff_params&);
};

// INLINE(inline) FUNCTION DEFINITIONS
//
// Inlining inner loop operations provides significant performance gain
//

#endif

@


4.5
log
@Merged ReverseComm_branch back into main branch
@
text
@d91 1
a91 1
                        double&, const Box*, Comm*);
@


4.4
log
@Added prototype for Force_PPPM class
@
text
@d82 2
a83 1
  void ApplyForce(const bool&, const bool&, ParticleList*, 
d85 2
a86 1
  void ApplyPartialForce(const bool&, const bool&, ParticleList*,
@


4.4.6.1
log
@Finished adding atomic virial for ReaxFF force field
@
text
@d82 1
a82 2
  void ApplyForce(const bool&, const bool&, const bool&, 
		  ParticleList*, 
d84 1
a84 2
  void ApplyPartialForce(const bool&, const bool&, const bool&, 
			 ParticleList*,
@


4.4.2.1
log
@Added ParticleList to ForceField::SetupInterations()
@
text
@d87 1
a87 1
  void SetupInteractions(const ParticleList*, const Box*, const double&, Comm*);
@


4.4.2.2
log
@Latest PPPM version
@
text
@d83 1
a83 1
		  const Box*, double&, Comm*);
d87 1
a87 1
  void SetupInteractions(ParticleList*, const Box*, double&, Comm*);
@


4.3
log
@Fixed glitch in header.
@
text
@d87 1
a87 1
  void SetupInteractions(const Box*, const Force_Ewald*, Comm*);
@


4.3.2.1
log
@First commit of new Monaco branch
@
text
@a83 6

  // added saubry (01-24-05)
  void EnergyChange(int* , vector <double>,
		    const bool&, ParticleList*, 
		    const Box*, Comm*);

@


4.3.2.1.2.1
log
@Correct a few things.
@
text
@d86 1
a86 1
  void EnergyChange(int* , double[3],
@


4.3.2.1.2.2
log
@Improved performance of MC moves and turned on periodic output
@
text
@d85 4
@


4.2
log
@Recovered from corruption on April 12, 1005
@
text
@d43 1
a43 1
//------------------------------------------------------------------------ 
@


4.1
log
@Create new branch.
@
text
@d13 2
a14 2
//    Timestamp: September 22, 2004
//    Version: 3.0
d16 1
a16 1
//    Author: Aidan P. Thompson
d20 4
a23 4
//    Copyright (2004) Sandia National Laboratories
//   
//    Sandia is a multiprogram laboratory operated by 
//    Sandia Corporation, a Lockheed Martin company,
d27 16
a83 6

  // added saubry (01-24-05)
  void EnergyChange(int* , vector <double>,
		    const bool&, ParticleList*, 
		    const Box*, Comm*);

@


4.0
log
@This is version 4.0
@
text
@d13 2
a14 2
//    Timestamp: April 1, 2005
//    Version: 4.0
d16 1
a16 1
//    Primary Author: Aidan P. Thompson
d20 4
a23 4
//    Copyright (2005) Sandia National Laboratories
//
//    Sandia National Laboratories is a multiprogram laboratory 
//    operated by Sandia Corporation, a Lockheed Martin company,
a26 16
//    Under the terms of Contract DE-AC04-94AL85000 with Sandia 
//    Corporation, the U.S. Government retains certain rights in 
//    this software.
//
//    This software is distributed under the terms of the GNU Public 
//    License (GPL). For a copy of the GPL see the file 
//    Grasp/Documentation/LICENSE or visit the GNU website at 
//    http://www.gnu.org/copyleft/gpl.html. Briefly, the GPL 
//    entitles you to use the software, modify it and redistribute it. 
//    The main thing you can not do is apply any other licensing 
//    terms to the software. Also, if any part of this sofware is added 
//    to other software, then that software must also be released under 
//    the GPL.
//
//    This software comes with no warranty of any kind. 
//
d68 6
@


3.2
log
@Merged REAX version with main version
@
text
@d16 1
a16 1
//    Author: Aidan P. Thompson
d20 4
a23 4
//    Copyright (2004) Sandia National Laboratories
//   
//    Sandia is a multiprogram laboratory operated by 
//    Sandia Corporation, a Lockheed Martin company,
d27 16
@


3.1
log
@Merging branch cjkimme_version with the trunk. testh and testi are kind
of questionable, but everything else looks ok.
@
text
@d13 2
a14 2
//    Timestamp: September 22, 2004
//    Version: 3.0
@


3.1.6.1
log
@Implement energy change.
Two ways are implemented:
     -  brute force,
     -  removal of the energy of atom before being boosted
        and addition of the energy of the boosted atoms.
Brute force is for every force field. Other method is for EAM only for now.


Sylvie Aubry - 02-17-05
@
text
@a67 6

  // added saubry (01-24-05)
  void EnergyChange(int* , vector <double>,
		    const bool&, const bool&, ParticleList*, 
		    const Box*, Comm*);

@


3.1.6.2
log
@Update changes.
@
text
@d71 1
a71 1
		    const bool&, ParticleList*, 
@


3.0
log
@Created a new version number, GRASP 3.0
@
text
@d68 2
d76 1
a76 1
		    const bool&, const bool&, double&, double[],
d83 1
a83 1
		    const bool&, const bool&, double&, double[],
@


2.15
log
@Did some memory clean up, to satisfy valgrind
@
text
@d13 2
a14 1
//    Timestamp: July 26, 2004
@


2.14
log
@Updated header
@
text
@d60 1
@


2.13
log
@Added NPT ensemble. Noy sure if it is working
yet, and need to update documentation.
@
text
@d13 1
a13 1
//    Timestamp: 1 March 2004
@


2.12
log
@Various
@
text
@d71 2
a72 1
		       double[], double[], double&,
d75 2
a76 1
		       double&, const int&) const;
d78 3
a80 2
				   double[],double[],double&,
				   const int&, const Box*) const;
d82 3
a84 2
				   double[],double&,
				   const int&, const Box*) const;
a87 1

a91 1

@


2.11
log
@Updated documentation
@
text
@d13 1
a13 1
//    Timestamp: 8 January 2004
@


2.10
log
@Added Ewald sum example
@
text
@d67 1
a67 1
  void SetupInteractions(const Box*, Comm*);
@


2.9
log
@The primary change is the addition of the embedded atom method (EAM)
This is contained in the class Force_Eam. An example is contained
in the directory Testing/testl.

I also tweaked various parts of the code:
-Added epsilon shift to unit cell origin to avoid
pathologies associated with origin at zero
-Changed ndof from 3n to 3n-3
-Implemented localptr usertag arrays in class ParticleList
This enables user to pick whatever integer tags they want for
atoms, but the code generates internal tags 0,1,....nparticles_tot-1.
-Random velocities are now generated for all nparticles_tot particles,
but only assigned to local particles, so that velocity assignments
are independent of number of processors used.
-I got rid of the dreaded COSP neighboring scheme
-I added an example of Nose-Hoover thermostat in testm
-I added a warning for when force field type has no particle type match.
@
text
@d59 1
a59 2
  Force_Threebody(const string&, const int&, const double&);

d64 3
a66 3
  void ApplyForce(ParticleList*,
		  const Box*, const int[], Comm*);
  void ReadInteractions(const string&, const string&, Comm*);
d68 2
a69 1

@


2.9.2.1
log
@Committing merge of main trunk onto branch cjkimme_version.
@
text
@d13 1
a13 1
//    Timestamp: July 26, 2004
d59 2
a60 2
  Force_Threebody(const string);
  ~Force_Threebody();
d65 5
a69 6
  void ApplyForce(const bool&, const bool&, ParticleList*, 
		  const Box*, Comm*);
  void ReadInteractions(Comm*);
  void SetupInteractions(const Box*, const Force_Ewald*, Comm*);
  void SetupNeighbor(const string&, const int&,const double&, 
                        double&, const Box*, Comm*);
d71 1
a71 2
		       double[], double[], 
		    const bool&, const bool&, double&, double[],
d74 1
a74 2
		    const bool&, const bool&, double&, double[],
		    const int&) const;
d76 2
a77 3
                    double[],double[],
		    const bool&, const bool&, double&, double[],
                    const int&, const Box*) const;
d79 2
a80 3
                    double[],
		    const bool&, const bool&, double&, double[],
                    const int&, const Box*) const;
d84 1
d89 1
@


2.9.2.2
log
@Fixing bug in particlelist.h that ruined parallel execution. Everything else
is incidental checking in of the grain boundary minimizer which still does
not handle interlayer relaxation correctly.
@
text
@a66 2
  void ApplyPartialForce(const bool&, const bool&, ParticleList*,
	                 const Box*, Comm*);
d73 1
a73 1
		    const bool&, const bool&, double&, double[], double[],
d80 1
a80 1
		    const bool&, const bool&, double&, double[], double[],
@


2.8
log
@Added a Perl script to Header.pl to prepend a header contained in
header.txt to source fiels, using

Header.pl *.pl *.cpp *.h M*[^~]
@
text
@a56 1
  bool Lneighbor_cosp;
a64 2
  int get_type(const int&) const;

d66 1
a66 1
		  const Box&, const int[]);
d68 1
a68 1
  void SetupInteractions(const Box&, Comm*);
d77 1
a77 1
				   const int&, const Box&) const;
d80 1
a80 1
				   const int&, const Box&) const;
@


2.7
log
@Gutted the class Input, so that it is now a generic wrapper.
All the detailed treatment of each command is pushed down into
the relevant classes.
@
text
@d1 28
@


2.6
log
@Fized up the output a little mor.
Standardized the method for treating enum option lists
Created the Constants class
@
text
@d32 1
a32 1
  Force_Threebody(const Neighbor::NeighborStyles&, const int&, const double&);
@


2.5
log
@Reworked a lot of the output to make it cleaner and more consistent.
Improved the timers.
@
text
@d14 2
a15 1
  enum ff_types { sw_cut };
d17 1
a17 1
  struct ff_params {int type;int np;double* params;};
d32 1
a32 1
  Force_Threebody(const int&, const int&, const double&);
@


2.4
log
@Combined particles and ghost_particles into one list.
@
text
@d8 2
a9 2
// Derived from Forcefield base class.
class Force_Threebody: public Forcefield {
d39 1
a39 1
  void ApplyForce(ParticleList*, double& , 
d41 1
a41 1
  void ReadInteractions(const string&, Comm*);
@


2.3
log
@This version does not work.  It contains the beginnings of the
neighbor binning scheme. I want to save it before I attempt
to combine local and ghost atoms in one list.
@
text
@d31 1
a31 1
  Force_Threebody(const int&, const bool&, const int&, const double&);
@


2.2
log
@Improved treament of log and error messages using new class Log.
Added minimization class Minimizer (currently only steepest descent).
Implemented Nsq neighboring for threebody forcefields.
Reinstated density profiles.
@
text
@d14 1
a14 1
  enum ff_type { sw_cut };
d16 1
a16 1
  struct ff_params {ff_type type;int np;double* params;};
@


2.1
log
@This is a lot of stuff.  Basically, the code is now parallel,
but it is only tested for the force field twobody_lj_cut.

The parallelization scheme is based on Steve Plimptons Comm class.
@
text
@d28 1
@


2.0
log
@*** empty log message ***
@
text
@d32 1
a32 1
  void SetupCutNeighSq(const double&);
d40 2
a41 2
  void ReadInteractions(const string&);
  void SetupInteractions(const Box&);
@


1.3
log
@Added class Profile to measure different types of spatial profiles
Added class Input to handle input commands.
Added global functions input_string to parse input commands.
@
text
@d30 1
a30 1
  Force_Threebody(const int&, const double&);
d32 1
a32 1
  void SetupCutNeighSq();
d38 2
a39 2
  void ApplyForce(vector<Particle>&, double& , 
		  const bool&, const Box&, const int[]);
@


1.2
log
@Added the Forcefield derived class Force_External. It makes use
of the class Fixed_Object, which resembles class Particle,
bu does not have a velocity vector and does not provide
timestepping operations.

Also added the basic temperature initialization in temperature.cpp,
as well as velocity output in box.cpp.
@
text
@d30 1
a30 1
  Force_Threebody();
d40 1
a40 1
  void ReadInteractions();
@


1.1
log
@Created an abstract class Forcefield, with derived classes Force_Twobody
and Force_Threebody.
Implemented Stillinger-Weber forcefield within Force_Threebody.
Unfortunately, the COSP neighboring method does not work for
threebody forces, so we currently do not have neighbor lists
for threebody interactions.  Probably need to use LAMMPS-like
ghost atom method and standard neighbor list structures.
@
text
@d41 1
a41 1
  void SetupInteractions();
@

