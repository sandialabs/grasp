head	4.5;
access;
symbols
	ReverseComm_branch:4.4.0.6
	ADTools_branch:4.4.0.4
	Monaco_Aidan:4.3.2.1.0.2
	Root-of-Monaco_Aidan:4.3.2.1
	PPPM_Crozier2:4.4.0.2
	PPPM_Crozier:4.4
	Root-of-PPPM_Crozier:4.4
	Monaco:4.3.0.2
	PreMonaco:4.3
	Recovery-2004-04-12:4.0
	BRANCH:4.1.0.4
	PMONACO:4.1.0.2
	ROOT:4.1
	initial:4.0.0.2
	pmonaco:4.0
	Version_4_0:4.0
	Version_3_0:3.0
	BeforeREAXMerge:3.1
	REAX-2:3.1
	P_MonacoSource:3.1.0.6
	GraspSource:3.1
	P_Monaco:3.1.0.4
	InitialGrasp:3.1
	REAXFF:3.1.0.2
	premerge_cjkimme_version:3.0
	CRAY:2.17.0.2
	cjkimme_version_merge_from_trunk_1:2.8.2.1
	cjkimme_version:2.8.0.2;
locks; strict;
comment	@ * @;


4.5
date	2006.11.09.20.13.52;	author athomps;	state Exp;
branches;
next	4.4;

4.4
date	2005.06.08.20.08.48;	author athomps;	state Exp;
branches
	4.4.2.1
	4.4.4.1
	4.4.6.1;
next	4.3;

4.3
date	2005.05.03.16.28.27;	author athomps;	state Exp;
branches
	4.3.2.1;
next	4.2;

4.2
date	2005.05.02.20.13.38;	author athomps;	state Exp;
branches;
next	4.1;

4.1
date	2005.04.12.22.26.04;	author saubry;	state Exp;
branches;
next	4.0;

4.0
date	2005.04.05.16.43.30;	author athomps;	state Exp;
branches;
next	3.2;

3.2
date	2005.04.02.00.37.56;	author athomps;	state Exp;
branches;
next	3.1;

3.1
date	2004.11.23.00.59.55;	author athomps;	state Exp;
branches
	3.1.6.1;
next	3.0;

3.0
date	2004.09.22.17.56.49;	author athomps;	state Exp;
branches;
next	2.17;

2.17
date	2004.08.13.21.52.19;	author athomps;	state Exp;
branches;
next	2.16;

2.16
date	2004.07.26.15.52.18;	author athomps;	state Exp;
branches;
next	2.15;

2.15
date	2004.07.22.23.35.55;	author athomps;	state Exp;
branches;
next	2.14;

2.14
date	2004.07.21.17.46.50;	author athomps;	state Exp;
branches;
next	2.13;

2.13
date	2004.05.20.22.11.33;	author athomps;	state Exp;
branches;
next	2.12;

2.12
date	2004.04.28.21.59.16;	author athomps;	state Exp;
branches;
next	2.11;

2.11
date	2004.03.20.00.15.38;	author athomps;	state Exp;
branches;
next	2.10;

2.10
date	2004.03.02.17.49.47;	author athomps;	state Exp;
branches;
next	2.9;

2.9
date	2004.03.01.18.13.34;	author athomps;	state Exp;
branches;
next	2.8;

2.8
date	2004.01.28.20.36.13;	author athomps;	state Exp;
branches
	2.8.2.1;
next	2.7;

2.7
date	2004.01.09.19.01.08;	author athomps;	state Exp;
branches;
next	2.6;

2.6
date	2003.11.26.22.51.14;	author athomps;	state Exp;
branches;
next	2.5;

2.5
date	2003.10.04.02.46.53;	author athomps;	state Exp;
branches;
next	2.4;

2.4
date	2003.09.19.23.35.18;	author athomps;	state Exp;
branches;
next	2.3;

2.3
date	2003.08.14.22.50.23;	author athomps;	state Exp;
branches;
next	2.2;

2.2
date	2003.08.01.16.22.01;	author athomps;	state Exp;
branches;
next	2.1;

2.1
date	2003.06.17.19.08.11;	author athomps;	state Exp;
branches;
next	2.0;

2.0
date	2003.04.24.17.19.15;	author athomps;	state Exp;
branches;
next	1.7;

1.7
date	2003.03.17.17.14.18;	author athomps;	state Exp;
branches;
next	1.6;

1.6
date	2003.03.03.20.32.39;	author athomps;	state Exp;
branches;
next	1.5;

1.5
date	2003.02.18.23.15.17;	author athomps;	state Exp;
branches;
next	1.4;

1.4
date	2003.02.05.00.32.02;	author athomps;	state Exp;
branches;
next	1.3;

1.3
date	2003.02.04.00.12.41;	author athomps;	state Exp;
branches;
next	1.2;

1.2
date	2003.01.18.00.20.49;	author athomps;	state Exp;
branches;
next	1.1;

1.1
date	2003.01.08.23.25.53;	author athomps;	state Exp;
branches;
next	;

2.8.2.1
date	2004.09.13.23.00.09;	author cjkimme;	state Exp;
branches;
next	;

3.1.6.1
date	2005.02.17.21.41.38;	author saubry;	state Exp;
branches;
next	3.1.6.2;

3.1.6.2
date	2005.02.24.21.03.59;	author saubry;	state Exp;
branches;
next	3.1.6.3;

3.1.6.3
date	2005.04.07.00.04.52;	author saubry;	state Exp;
branches;
next	;

4.3.2.1
date	2005.05.03.21.44.53;	author athomps;	state Exp;
branches
	4.3.2.1.2.1;
next	;

4.3.2.1.2.1
date	2005.10.21.15.44.43;	author saubry;	state Exp;
branches;
next	4.3.2.1.2.2;

4.3.2.1.2.2
date	2006.02.15.21.34.48;	author athomps;	state Exp;
branches;
next	;

4.4.2.1
date	2005.06.20.22.41.00;	author athomps;	state Exp;
branches;
next	4.4.2.2;

4.4.2.2
date	2005.06.21.21.46.18;	author pscrozi;	state Exp;
branches;
next	;

4.4.4.1
date	2006.08.28.22.33.15;	author athomps;	state Exp;
branches;
next	;

4.4.6.1
date	2006.11.09.00.20.53;	author athomps;	state Exp;
branches;
next	;


desc
@@


4.5
log
@Merged ReverseComm_branch back into main branch
@
text
@//-----------------------------------------------------------------------
//
//   G R A S P
//   ____________
//   \           \
//    \ General   \
//     \ Reactive  \
//      \ Atomistic \
//       \ Simulation\
//        \ Program   \
//         \___________\
//
//    Timestamp: April 1, 2005
//    Version: 4.0
//
//    Primary Author: Aidan P. Thompson
//
//    e-mail: athomps@@sandia.gov
//   
//    Copyright (2005) Sandia National Laboratories
//
//    Sandia National Laboratories is a multiprogram laboratory 
//    operated by Sandia Corporation, a Lockheed Martin company,
//    for the United States Department of Energy under contract
//    No. DE-AC04-94AL-85000.
//
//    Under the terms of Contract DE-AC04-94AL85000 with Sandia 
//    Corporation, the U.S. Government retains certain rights in 
//    this software.
//
//    This software is distributed under the terms of the GNU Public 
//    License (GPL). For a copy of the GPL see the file 
//    Grasp/Documentation/LICENSE or visit the GNU website at 
//    http://www.gnu.org/copyleft/gpl.html. Briefly, the GPL 
//    entitles you to use the software, modify it and redistribute it. 
//    The main thing you can not do is apply any other licensing 
//    terms to the software. Also, if any part of this sofware is added 
//    to other software, then that software must also be released under 
//    the GPL.
//
//    This software comes with no warranty of any kind. 
//
//----------------------------------------------------------------------- 
/////:EOH~

#ifndef FORCE_TWOBODY_H
#define FORCE_TWOBODY_H

class Particle_Types;
class Box;

// Data structure for two-body force fields
// Derived from ForceField base class.
class Force_Twobody: public ForceField {
 public:
  // List of allowable forcefield types. Several types
  // can be used in a single simulation.
  //
  // nocut types do not use a force cut-off. Instead,
  // forces are calculated between every pair.  The
  // minimum image convention may be applied in zero, one,
  // two or all directions, depending on the boundary
  // conditions specified.
  //
  // Note: Any occurence of nocut types will prevent
  // the use of neighbor lists for all atom pairs. 
  // In this case, any force cut-offs must not exceed
  // half the minimum box width, and only a single
  // process is allowed.
  //
  // enum class for force field types
  enum ForceFieldTypes { lj_cut, lj_cut_shift, lj_nocut, 
                         lj_coul_cut, lj_coul_cut_shift, lj_coul_nocut, 
                         lj_ewald_cut, lj_ewald_cut_shift, lj_ewald_nocut,
			 exp6_cut, exp6_cut_shift, exp6_nocut, 
			 exp6_coul_cut, exp6_coul_cut_shift, exp6_coul_nocut, 
			 exp6_ewald_cut, exp6_ewald_cut_shift, exp6_ewald_nocut, 
			 exp6_eps_cut, exp6_eps_cut_shift, exp6_eps_nocut, 
			 exp6_eps_coul_cut, exp6_eps_coul_cut_shift, exp6_eps_coul_nocut, 
			 exp6_eps_ewald_cut, exp6_eps_ewald_cut_shift, exp6_eps_ewald_nocut, 
  };
 private:
  struct ff_params {ForceFieldTypes type; double rcutsq; int np; double* params;};
  //Array of ff_params created on imput 
  vector<ff_params> input_param_list;
  //Array of ff_params created in SetupInteractions
  int nentries;
  vector<ff_params> param_list;
  //2-D array of pointers to elements in input_param_list, 
  // indexed by two particle types
  int** input_param_index;
  //2-D array of pointers to elements in param_list 
  // indexed by two particle types
  int** param_index;
  bool Lcoul;

  // These data members are initialized in force_twobody_inline.h
  //
  static const double EWALD_F;
  static const double EWALD_P;
  static const double EWALD_A1;
  static const double EWALD_A2;
  static const double EWALD_A3;
  static const double EWALD_A4;
  static const double EWALD_A5;

 public:

  Force_Twobody(const string);
  ~Force_Twobody();
  void SetupCutNeighSq(const double&, Comm*);

  int get_entry(const int&, const int&) const;

  void ApplyForce(const bool&, const bool&, const bool&, 
		  ParticleList*, 
		  const Box*, Comm*);
  void ApplyForceLJCutFast(
      const bool&, const bool&, const bool&, ParticleList*,
      const Box*, Comm*);
  void ApplyForceLJCutSuperFast(
      const bool&, const bool&, const bool&, ParticleList*,
      const Box*, Comm*);
  void ReadInteractions(Comm*);
  void SetupInteractions(const Box*, const double&, Comm*);

  void force_lj(const double[], const double[], 
		    double[], const bool&, const bool&, 
		    double&, double[],  
		    const int&) const;
  void force_lj_coul(
       const double[], const double[], 
       double[], const bool&, const bool&, 
       double&, double&, double[], 
       const int&, const double&, const double&) const;
  void force_lj_ewald(
       const double[], const double[], 
       double[], const bool&, const bool&, 
       double&, double&, double[], 
       const int&, const double&, const double&) const;
  void force_exp6(const double[], const double[], 
			double[], const bool&, const bool&, 
                        double&, double[], 
			const int&) const;
  void force_exp6_coul(
       const double[], const double[], 
       double[], const bool&, const bool&, 
       double&, double&, double[], 
       const int&, const double&, const double&) const;
  void force_exp6_ewald(
       const double[], const double[], 
       double[], const bool&, const bool&, 
       double&, double&, double[], 
       const int&, const double&, const double&) const;

  void lj_setup(const ff_params&, ff_params&);
  void lj_setup(const ff_params&, const ff_params&, ff_params&);

  void lj_coul_setup(const ff_params&, const double&, ff_params&);
  void lj_coul_setup(const ff_params&, const ff_params&, const double&, ff_params&);

  void lj_ewald_setup(const ff_params&, const double&, const double&, ff_params&);
  void lj_ewald_setup(const ff_params&, const ff_params&, const double&, const double&, ff_params&);

  void exp6_setup(const ff_params&, ff_params&);

  void exp6_coul_setup(const ff_params&, const double&, ff_params&);

  void exp6_ewald_setup(const ff_params&, const double&, const double&, ff_params&);

  void exp6_eps_setup(const ff_params&, ff_params&);
  void exp6_eps_setup(const ff_params&, const ff_params&, ff_params&);

  void exp6_eps_coul_setup(const ff_params&, const double&, ff_params&);
  void exp6_eps_coul_setup(const ff_params&, const ff_params&, const double&, ff_params&);

  void exp6_eps_ewald_setup(const ff_params&, const double&, const double&, ff_params&);
  void exp6_eps_ewald_setup(const ff_params&, const ff_params&, const double&, const double&, ff_params&);

};

// INLINE(inline) FUNCTION DEFINITIONS
//
// Inlining inner loop operations provides significant performance gain
//

#endif

@


4.4
log
@Added prototype for Force_PPPM class
@
text
@d115 3
a117 2
  void ApplyForce(const bool&, const bool&, ParticleList*, 
                const Box*, Comm*);
d119 1
a119 1
      const bool&, const bool&, ParticleList*,
d122 1
a122 1
      const bool&, const bool&, ParticleList*,
@


4.4.6.1
log
@Finished adding atomic virial for ReaxFF force field
@
text
@d115 2
a116 3
  void ApplyForce(const bool&, const bool&, const bool&, 
		  ParticleList*, 
		  const Box*, Comm*);
d118 1
a118 1
      const bool&, const bool&, const bool&, ParticleList*,
d121 1
a121 1
      const bool&, const bool&, const bool&, ParticleList*,
@


4.4.4.1
log
@Created automatic differentiation version for LJ force field, called lj_cut_AD
@
text
@d72 1
a72 1
  enum ForceFieldTypes { lj_cut, lj_cut_AD, lj_cut_shift, lj_nocut, 
a178 7

  void force_lj_AD(
            const double[], const double[], 
	    double[], const bool&, const bool&, 
	    double&, double[],
	    const int&) const;

@


4.4.2.1
log
@Added ParticleList to ForceField::SetupInterations()
@
text
@d124 1
a124 1
  void SetupInteractions(const ParticleList*, const Box*, const double&, Comm*);
@


4.4.2.2
log
@Latest PPPM version
@
text
@d116 1
a116 1
                const Box*, double& g_ewald, Comm*);
d124 1
a124 1
  void SetupInteractions(ParticleList*, const Box*, double&, Comm*);
@


4.3
log
@Fixed glitch in header.
@
text
@d116 1
a116 1
		  const Box*, Comm*);
d118 1
a118 1
      const bool&, const bool&, ParticleList*, 
d121 1
a121 1
      const bool&, const bool&, ParticleList*, 
d124 1
a124 1
  void SetupInteractions(const Box*, const Force_Ewald*, Comm*);
@


4.3.2.1
log
@First commit of new Monaco branch
@
text
@a116 7

  // added saubry (01-24-05)
  void EnergyChange(int* , vector <double>,
		    const bool&, ParticleList*, 
		    const Box*, Comm*);


@


4.3.2.1.2.1
log
@Correct a few things.
@
text
@d119 1
a119 1
  void EnergyChange(int* , double*,
@


4.3.2.1.2.2
log
@Improved performance of MC moves and turned on periodic output
@
text
@d118 4
@


4.2
log
@Recovered from corruption on April 12, 1005
@
text
@d43 1
a43 1
//------------------------------------------------------------------------ 
@


4.1
log
@Create new branch.
@
text
@d13 2
a14 2
//    Timestamp: September 22, 2004
//    Version: 3.0
d16 1
a16 1
//    Author: Aidan P. Thompson
d20 4
a23 4
//    Copyright (2004) Sandia National Laboratories
//   
//    Sandia is a multiprogram laboratory operated by 
//    Sandia Corporation, a Lockheed Martin company,
d27 16
a116 7

  // added saubry (01-24-05)
  void EnergyChange(int* , vector <double>,
		    const bool&, ParticleList*, 
		    const Box*, Comm*);


@


4.0
log
@This is version 4.0
@
text
@d13 2
a14 2
//    Timestamp: April 1, 2005
//    Version: 4.0
d16 1
a16 1
//    Primary Author: Aidan P. Thompson
d20 4
a23 4
//    Copyright (2005) Sandia National Laboratories
//
//    Sandia National Laboratories is a multiprogram laboratory 
//    operated by Sandia Corporation, a Lockheed Martin company,
a26 16
//    Under the terms of Contract DE-AC04-94AL85000 with Sandia 
//    Corporation, the U.S. Government retains certain rights in 
//    this software.
//
//    This software is distributed under the terms of the GNU Public 
//    License (GPL). For a copy of the GPL see the file 
//    Grasp/Documentation/LICENSE or visit the GNU website at 
//    http://www.gnu.org/copyleft/gpl.html. Briefly, the GPL 
//    entitles you to use the software, modify it and redistribute it. 
//    The main thing you can not do is apply any other licensing 
//    terms to the software. Also, if any part of this sofware is added 
//    to other software, then that software must also be released under 
//    the GPL.
//
//    This software comes with no warranty of any kind. 
//
d101 7
@


3.2
log
@Merged REAX version with main version
@
text
@d16 1
a16 1
//    Author: Aidan P. Thompson
d20 4
a23 4
//    Copyright (2004) Sandia National Laboratories
//   
//    Sandia is a multiprogram laboratory operated by 
//    Sandia Corporation, a Lockheed Martin company,
d27 16
@


3.1
log
@Redid Force_Twobody class to better handle many different variants.
Added in new for of exp6 that is required for BKS force field.
@
text
@d13 2
a14 2
//    Timestamp: September 22, 2004
//    Version: 3.0
@


3.1.6.1
log
@Implement energy change.
Two ways are implemented:
     -  brute force,
     -  removal of the energy of atom before being boosted
        and addition of the energy of the boosted atoms.
Brute force is for every force field. Other method is for EAM only for now.


Sylvie Aubry - 02-17-05
@
text
@a100 6

  // added saubry (01-24-05)
  void EnergyChange(int* , vector <double>,
		    const bool&, const bool&, ParticleList*, 
		    const Box*, Comm*);

@


3.1.6.2
log
@Update changes.
@
text
@d104 1
a104 1
		    const bool&, ParticleList*, 
@


3.1.6.3
log
@Fusion of ALex and Sylvie's versions.
Implementation of bins.
Add energy change.

saubry (04-06-05)
@
text
@a106 1

@


3.0
log
@Created a new version number, GRASP 3.0
@
text
@d52 2
a53 1
  // half the minimum box width.
d56 10
a65 4
  enum ForceFieldTypes { lj_cut, lj_cut_shift, 
			 lj_nocut, exp6_nocut, square_exp6_nocut,
                         lj_cut_coul, lj_cut_shift_coul,
                         lj_cut_ewald, lj_cut_shift_ewald};
d67 1
a67 1
  struct ff_params {ForceFieldTypes type;int np;double* params;};
d110 1
a110 1
  void force_lj_cut(const double[], const double[], 
d114 1
a114 45
  void force_lj_cut_shift(const double[], const double[], 
			  double[], const bool&, const bool&, 
			  double&, double[], 
			  const int&) const;
  void force_lj_cut_minimg(const Particle&, const Particle&, 
			   double[], const bool&, const bool&, 
			   double&, double[], 
			   const int&, const Box*) const;
  void force_lj_cut_shift_minimg(const Particle&, const Particle&, 
			double[], const bool&, const bool&, 
			double&, double[], 
			const int&, const Box*) const;
  void force_lj_nocut_minimg(const Particle&, const Particle&, 
			double[], const bool&, const bool&, 
                        double&, double[], 
			const int&, const Box*) const;
  void force_exp6_nocut_minimg(const Particle&, const Particle&, 
			double[], const bool&, const bool&, 
                        double&, double[], 
			const int&, const Box*) const;
  void force_square_exp6_nocut_minimg(const Particle&, const Particle&, 
			double[], const bool&, const bool&, 
                        double&, double[], 
			const int&, const Box*) const;
  void force_lj_cut_nopbc(const Particle&, const Particle&, 
			double[], const bool&, const bool&, 
                        double&, double[], 
			const int&) const;
  void force_lj_cut_shift_nopbc(const Particle&, const Particle&, 
			double[], const bool&, const bool&, 
                        double&, double[], 
			const int&) const;
  void force_lj_nocut_nopbc(const Particle&, const Particle&, 
			double[], const bool&, const bool&, 
                        double&, double[], 
			const int&) const;
  void force_exp6_nocut_nopbc(const Particle&, const Particle&, 
			double[], const bool&, const bool&, 
                        double&, double[], 
			const int&) const;
  void force_square_exp6_nocut_nopbc(const Particle&, const Particle&, 
			double[], const bool&, const bool&, 
                        double&, double[], 
			const int&) const;
  void force_lj_cut_coul(
d119 1
a119 1
  void force_lj_cut_shift_coul(
d124 5
a128 1
  void force_lj_cut_ewald(
d133 1
a133 1
  void force_lj_cut_shift_ewald(
d139 2
a140 2
  void lj_cut_setup(const double&, const double&, const double&, 
                    ff_params&);
d142 2
a143 2
  void lj_cut_shift_setup(const double&, const double&, const double&, 
                    ff_params&);
d145 2
a146 1
  void lj_nocut_setup(const double&, const double&, ff_params&);
d148 1
a148 2
  void exp6_nocut_setup(const double&, const double&, const double&, 
                    ff_params&);
d150 1
a150 2
  void square_exp6_nocut_setup(const double&, const double&, 
                    const double&, ff_params&);
d152 1
a152 2
  void lj_cut_coul_setup(const double&, const double&, const double&, 
                    const double&, ff_params&);
d154 2
a155 2
  void lj_cut_shift_coul_setup(const double&, const double&, 
                    const double&, const double&, ff_params&);
d157 2
a158 2
  void lj_cut_ewald_setup(const double&, const double&, const double&, 
                    const double&, const double&, ff_params&);
d160 2
a161 2
  void lj_cut_shift_ewald_setup(const double&, const double&, 
                    const double&, const double&, const double&, ff_params&);
@


2.17
log
@Did some memory clean up, to satisfy valgrind
@
text
@d13 2
a14 1
//    Timestamp: July 26, 2004
@


2.16
log
@Updated header
@
text
@d86 1
@


2.15
log
@Fixed problem with Ewald sum parameters.
@
text
@d13 1
a13 1
//    Timestamp: 1 March 2004
@


2.14
log
@Added anisotropic style to pressure control,
and included in Tersoff example testp.
@
text
@d73 9
a81 7
  static const double EWALD_F = 1.12837917;
  static const double EWALD_P = 0.3275911;
  static const double A1 = 0.254829592;
  static const double A2 = -0.284496736;
  static const double A3 = 1.421413741;
  static const double A4 = -1.453152027;
  static const double A5 = 1.061405429;
@


2.13
log
@Added NPT ensemble. Noy sure if it is working
yet, and need to update documentation.
@
text
@d72 9
@


2.12
log
@Added force_ewald.
Moved eam data from Particle into Force_Eam.
Added some fast version of LJ forces.
Eliminated redundant reneighboring on first timestep.
This caused epsilon changes in some forces.
@
text
@d91 2
a92 1
		    double[], double&, 
d95 3
a97 2
			double[], double&,
			const int&) const;
d99 2
a100 1
			   double[], double&,
d103 2
a104 1
			double[], double&,
d107 2
a108 1
			double[], double&,
d111 2
a112 1
			double[], double&,
d115 2
a116 1
			double[], double&,
d119 2
a120 1
			double[], double&,
d123 2
a124 1
			double[], double&,
d127 2
a128 1
			double[], double&,
d131 2
a132 1
			double[], double&,
d135 2
a136 1
			double[], double&,
d140 2
a141 1
       double[], double&, double&, 
d145 2
a146 1
       double[], double&, double&, 
d150 2
a151 1
       double[], double&, double&, 
d155 2
a156 1
       double[], double&, double&, 
@


2.11
log
@Various
@
text
@d81 6
@


2.10
log
@Updated documentation
@
text
@d13 1
a13 1
//    Timestamp: 8 January 2004
@


2.9
log
@Added Ewald sum example
@
text
@d82 1
a82 1
  void SetupInteractions(const Box*, Comm*);
d131 1
a131 2
       const int&, const double&, const double&,
       const double&) const;
d135 1
a135 2
       const int&, const double&, const double&, 
       const double&) const;
d158 1
a158 1
                    const double&, ff_params&);
d161 1
a161 1
                    const double&, const double&, ff_params&);
@


2.8
log
@The primary change is the addition of the embedded atom method (EAM)
This is contained in the class Force_Eam. An example is contained
in the directory Testing/testl.

I also tweaked various parts of the code:
-Added epsilon shift to unit cell origin to avoid
pathologies associated with origin at zero
-Changed ndof from 3n to 3n-3
-Implemented localptr usertag arrays in class ParticleList
This enables user to pick whatever integer tags they want for
atoms, but the code generates internal tags 0,1,....nparticles_tot-1.
-Random velocities are now generated for all nparticles_tot particles,
but only assigned to local particles, so that velocity assignments
are independent of number of processors used.
-I got rid of the dreaded COSP neighboring scheme
-I added an example of Nose-Hoover thermostat in testm
-I added a warning for when force field type has no particle type match.
@
text
@d55 3
a57 1
			 lj_nocut, exp6_nocut, square_exp6_nocut};
d71 1
d74 1
a74 2
  Force_Twobody(const string&, const int&, const double&);

d79 3
a81 3
  void ApplyForce(ParticleList*, 
		  const Box*, const int[], Comm*);
  void ReadInteractions(const string&, const string&, Comm*);
d120 18
d139 2
a140 1
  void lj_cut_setup(const double&, const double&, const double&, ff_params&);
d142 2
a143 1
  void lj_cut_shift_setup(const double&, const double&, const double&, ff_params&);
d147 14
a160 1
  void exp6_nocut_setup(const double&, const double&, const double&, ff_params&);
d162 2
a163 1
  void square_exp6_nocut_setup(const double&, const double&, const double&, ff_params&);
@


2.8.2.1
log
@Committing merge of main trunk onto branch cjkimme_version.
@
text
@d13 1
a13 1
//    Timestamp: July 26, 2004
d55 1
a55 3
			 lj_nocut, exp6_nocut, square_exp6_nocut,
                         lj_cut_coul, lj_cut_shift_coul,
                         lj_cut_ewald, lj_cut_shift_ewald};
d69 1
a69 1
  bool Lcoul;
d71 1
a71 9
  // These data members are initialized in force_twobody_inline.h
  //
  static const double EWALD_F;
  static const double EWALD_P;
  static const double EWALD_A1;
  static const double EWALD_A2;
  static const double EWALD_A3;
  static const double EWALD_A4;
  static const double EWALD_A5;
a72 4
 public:

  Force_Twobody(const string);
  ~Force_Twobody();
d77 4
a80 10
  void ApplyForce(const bool&, const bool&, ParticleList*, 
		  const Box*, Comm*);
  void ApplyForceLJCutFast(
      const bool&, const bool&, ParticleList*, 
      const Box*, Comm*);
  void ApplyForceLJCutSuperFast(
      const bool&, const bool&, ParticleList*, 
      const Box*, Comm*);
  void ReadInteractions(Comm*);
  void SetupInteractions(const Box*, const Force_Ewald*, Comm*);
d83 1
a83 2
		    double[], const bool&, const bool&, 
		    double&, double[],  
d86 2
a87 3
			  double[], const bool&, const bool&, 
			  double&, double[], 
			  const int&) const;
d89 1
a89 2
			   double[], const bool&, const bool&, 
			   double&, double[], 
d92 1
a92 2
			double[], const bool&, const bool&, 
			double&, double[], 
d95 1
a95 2
			double[], const bool&, const bool&, 
                        double&, double[], 
d98 1
a98 2
			double[], const bool&, const bool&, 
                        double&, double[], 
d101 1
a101 2
			double[], const bool&, const bool&, 
                        double&, double[], 
d104 1
a104 2
			double[], const bool&, const bool&, 
                        double&, double[], 
d107 1
a107 2
			double[], const bool&, const bool&, 
                        double&, double[], 
d110 1
a110 2
			double[], const bool&, const bool&, 
                        double&, double[], 
d113 1
a113 2
			double[], const bool&, const bool&, 
                        double&, double[], 
d116 1
a116 2
			double[], const bool&, const bool&, 
                        double&, double[], 
a117 20
  void force_lj_cut_coul(
       const double[], const double[], 
       double[], const bool&, const bool&, 
       double&, double&, double[], 
       const int&, const double&, const double&) const;
  void force_lj_cut_shift_coul(
       const double[], const double[], 
       double[], const bool&, const bool&, 
       double&, double&, double[], 
       const int&, const double&, const double&) const;
  void force_lj_cut_ewald(
       const double[], const double[], 
       double[], const bool&, const bool&, 
       double&, double&, double[], 
       const int&, const double&, const double&) const;
  void force_lj_cut_shift_ewald(
       const double[], const double[], 
       double[], const bool&, const bool&, 
       double&, double&, double[], 
       const int&, const double&, const double&) const;
d119 1
a119 2
  void lj_cut_setup(const double&, const double&, const double&, 
                    ff_params&);
d121 1
a121 2
  void lj_cut_shift_setup(const double&, const double&, const double&, 
                    ff_params&);
d125 1
a125 14
  void exp6_nocut_setup(const double&, const double&, const double&, 
                    ff_params&);

  void square_exp6_nocut_setup(const double&, const double&, 
                    const double&, ff_params&);

  void lj_cut_coul_setup(const double&, const double&, const double&, 
                    const double&, ff_params&);

  void lj_cut_shift_coul_setup(const double&, const double&, 
                    const double&, const double&, ff_params&);

  void lj_cut_ewald_setup(const double&, const double&, const double&, 
                    const double&, const double&, ff_params&);
d127 1
a127 2
  void lj_cut_shift_ewald_setup(const double&, const double&, 
                    const double&, const double&, const double&, ff_params&);
@


2.7
log
@Added a Perl script to Header.pl to prepend a header contained in
header.txt to source fiels, using

Header.pl *.pl *.cpp *.h M*[^~]
@
text
@a68 1
  bool Lneighbor_cosp;
a76 2
  int get_type(const int&) const;

d78 1
a78 1
		  const Box&, const int[]);
d80 1
a80 1
  void SetupInteractions(const Box&, Comm*);
d90 1
a90 1
			   const int&, const Box&) const;
d93 1
a93 1
			const int&, const Box&) const;
d96 1
a96 1
			const int&, const Box&) const;
d99 1
a99 1
			const int&, const Box&) const;
d102 1
a102 1
			const int&, const Box&) const;
@


2.6
log
@Gutted the class Input, so that it is now a generic wrapper.
All the detailed treatment of each command is pushed down into
the relevant classes.
@
text
@d1 28
@


2.5
log
@Fized up the output a little mor.
Standardized the method for treating enum option lists
Created the Constants class
@
text
@d44 1
a44 1
  Force_Twobody(const Neighbor::NeighborStyles&, const int&, const double&);
@


2.4
log
@Reworked a lot of the output to make it cleaner and more consistent.
Improved the timers.
@
text
@d25 3
a27 2
  enum ff_types { lj_cut, lj_cut_shift, 
		 lj_nocut, exp6_nocut, square_exp6_nocut};
d29 1
a29 1
  struct ff_params {int type;int np;double* params;};
d44 1
a44 1
  Force_Twobody(const int&, const int&, const double&);
@


2.3
log
@Combined particles and ghost_particles into one list.
@
text
@d8 2
a9 2
// Derived from Forcefield base class.
class Force_Twobody: public Forcefield {
d51 1
a51 1
  void ApplyForce(ParticleList*, double& , 
d53 1
a53 1
  void ReadInteractions(const string&, Comm*);
@


2.2
log
@This version does not work.  It contains the beginnings of the
neighbor binning scheme. I want to save it before I attempt
to combine local and ghost atoms in one list.
@
text
@d43 1
a43 1
  Force_Twobody(const int&, const bool&, const int&, const double&);
@


2.1
log
@This is a lot of stuff.  Basically, the code is now parallel,
but it is only tested for the force field twobody_lj_cut.

The parallelization scheme is based on Steve Plimptons Comm class.
@
text
@d25 1
a25 1
  enum ff_type { lj_cut, lj_cut_shift, 
d28 1
a28 1
  struct ff_params {ff_type type;int np;double* params;};
@


2.0
log
@*** empty log message ***
@
text
@d40 1
d45 1
a45 1
  void SetupCutNeighSq(const double&);
d53 2
a54 2
  void ReadInteractions(const string&);
  void SetupInteractions(const Box&);
@


1.7
log
@Added class Profile to measure different types of spatial profiles
Added class Input to handle input commands.
Added global functions input_string to parse input commands.
@
text
@d42 1
a42 1
  Force_Twobody(const int&, const double&);
d44 1
a44 1
  void SetupCutNeighSq();
d50 2
a51 2
  void ApplyForce(vector<Particle>&, double& , 
		  const bool&, const Box&, const int[]);
@


1.6
log
@Added the Forcefield derived class Force_External. It makes use
of the class Fixed_Object, which resembles class Particle,
bu does not have a velocity vector and does not provide
timestepping operations.

Also added the basic temperature initialization in temperature.cpp,
as well as velocity output in box.cpp.
@
text
@d42 1
a42 1
  Force_Twobody();
d52 1
a52 1
  void ReadInteractions();
@


1.5
log
@Created an abstract class Forcefield, with derived classes Force_Twobody
and Force_Threebody.
Implemented Stillinger-Weber forcefield within Force_Threebody.
Unfortunately, the COSP neighboring method does not work for
threebody forces, so we currently do not have neighbor lists
for threebody interactions.  Probably need to use LAMMPS-like
ghost atom method and standard neighbor list structures.
@
text
@d53 1
a53 1
  void SetupInteractions();
@


1.4
log
@Got rid of gratuituous "friend" declaration for class Neighobr in class Box.
@
text
@d4 3
d8 2
a9 2
// Uses singleton construction same as that of class Box.
class Force_Twobody {
d31 1
a31 1
  //Array of ff_params created in SetupTwobodyInteractions
a33 4
  vector<double> rcutneighsq;
  int ntypes, maxparam;
  //Array of particle id's, indexed by twobody type.
  vector<int> id_index;
a39 13
  // Description of force cut-off treatment
  double rcut_max;
  static const double rskin = 1.0;
  bool Lnocut;
  bool Lneighbor;
  Neighbor neighbor;
  // Private constructor and copy constructor
  Force_Twobody() {
    return;
      };
  Force_Twobody(const Force_Twobody&) {
    return;
      };
d41 3
a43 7
  static Force_Twobody& get();
  void ApplyForce(vector<Particle>&, double& , const bool&, const Box&);
  void SetupNeighborListNsq(vector<Particle>& particles) {
    neighbor.SetupNeighborListNsq(particles);
  };
  void ReadTwobodyInteractions();
  void SetupTwobodyInteractions();
d45 1
a46 21
  ff_type get_type(const int&) const;
  bool find_id(const int&, int&) const;
  int get_ntypes() const {
    return ntypes;
    };
  int get_nneighbors() const {
    return neighbor.nneighbors;
    };
  double get_rcut_max() const {
    return rcut_max;
    };
  double get_cutneighsq(const int& ientry) const {
    return rcutneighsq[ientry];
  }

  bool get_Lneighbor() const {
    return Lneighbor;
    };
  ~Force_Twobody(){
    return;
  };
d48 6
d56 2
a57 2
		    double[], double&,
			const int&) const;
d63 1
a63 1
			const int&, const Box&) const;
d104 4
@


1.3
log
@

Added neighbor list object.
@
text
@d57 2
a58 2
  void SetupNeighborListNsq() {
    neighbor.SetupNeighborListNsq();
@


1.2
log
@
Added ReadParticleTypes, and improved organization of input,
including error checking.
@
text
@d8 16
a23 1
  enum ff_type { lj_nocut, exp6_nocut, square_exp6_nocut};
d25 1
a25 1
  typedef struct {ff_type type;int np;double* params;} ff_params;
d29 1
d31 1
d41 7
d56 4
d62 1
d69 13
d87 32
a118 23
  void force_lj_minimg(const vector<Particle>::iterator,
			const vector<Particle>::iterator, 
			double[], double&, const Box&,
			const int&) const;
  void force_exp6_minimg(const vector<Particle>::iterator,
			const vector<Particle>::iterator, 
			double[], double&, const Box&,
			const int&) const;
  void force_square_exp6_minimg(const vector<Particle>::iterator,
			const vector<Particle>::iterator, 
			double[], double&, const Box&,
			const int&) const;
  void force_lj_nopbc(const vector<Particle>::iterator,
			const vector<Particle>::iterator, 
			double[], double&, const Box&,
			const int&) const;
  void force_exp6_nopbc(const vector<Particle>::iterator,
			const vector<Particle>::iterator, 
			double[], double&, const Box&,
			const int&) const;
  void force_square_exp6_nopbc(const vector<Particle>::iterator,
			const vector<Particle>::iterator, 
			double[], double&, const Box&,
d120 13
d136 1
d138 1
@


1.1
log
@Starting source distribution for Grasp.
Basic molecular dynamics code with twobody interactions
@
text
@d11 4
a14 1
  vector<ff_params> param_list,input_param_list;
d16 1
d18 2
a19 1
  //2-D array of indices for force field param_list
d21 2
d37 3
@

