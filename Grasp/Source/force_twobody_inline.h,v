head	4.5;
access;
symbols
	ReverseComm_branch:4.4.0.4
	ADTools_branch:4.4.0.2
	Monaco_Aidan:4.3.0.6
	Root-of-Monaco_Aidan:4.3
	PPPM_Crozier2:4.3.0.4
	PPPM_Crozier:4.3
	Root-of-PPPM_Crozier:4.3
	Monaco:4.3.0.2
	PreMonaco:4.3
	Recovery-2004-04-12:4.0
	BRANCH:4.1.0.4
	PMONACO:4.1.0.2
	ROOT:4.1
	initial:4.0.0.2
	pmonaco:4.0
	Version_4_0:4.0
	Version_3_0:3.0
	BeforeREAXMerge:3.2
	REAX-2:3.2
	P_MonacoSource:3.2.0.6
	GraspSource:3.2
	P_Monaco:3.2.0.4
	InitialGrasp:3.2
	REAXFF:3.2.0.2
	premerge_cjkimme_version:3.0
	CRAY:2.12.0.2
	cjkimme_version_merge_from_trunk_1:2.2.2.1
	cjkimme_version:2.2.0.2;
locks; strict;
comment	@ * @;


4.5
date	2007.09.05.22.43.34;	author athomps;	state Exp;
branches;
next	4.4;

4.4
date	2005.10.28.19.10.56;	author athomps;	state Exp;
branches
	4.4.2.1;
next	4.3;

4.3
date	2005.05.03.16.28.27;	author athomps;	state Exp;
branches;
next	4.2;

4.2
date	2005.05.02.20.13.38;	author athomps;	state Exp;
branches;
next	4.1;

4.1
date	2005.04.12.22.26.04;	author saubry;	state Exp;
branches;
next	4.0;

4.0
date	2005.04.05.16.43.30;	author athomps;	state Exp;
branches;
next	3.3;

3.3
date	2005.04.02.00.37.56;	author athomps;	state Exp;
branches;
next	3.2;

3.2
date	2004.11.24.23.39.28;	author athomps;	state Exp;
branches;
next	3.1;

3.1
date	2004.11.23.00.59.55;	author athomps;	state Exp;
branches;
next	3.0;

3.0
date	2004.09.22.17.56.49;	author athomps;	state Exp;
branches;
next	2.12;

2.12
date	2004.08.27.20.05.36;	author athomps;	state Exp;
branches;
next	2.11;

2.11
date	2004.07.26.15.52.18;	author athomps;	state Exp;
branches;
next	2.10;

2.10
date	2004.07.22.23.35.55;	author athomps;	state Exp;
branches;
next	2.9;

2.9
date	2004.07.21.17.46.50;	author athomps;	state Exp;
branches;
next	2.8;

2.8
date	2004.07.19.17.05.38;	author athomps;	state Exp;
branches;
next	2.7;

2.7
date	2004.05.20.22.11.33;	author athomps;	state Exp;
branches;
next	2.6;

2.6
date	2004.04.28.21.59.16;	author athomps;	state Exp;
branches;
next	2.5;

2.5
date	2004.03.20.00.15.38;	author athomps;	state Exp;
branches;
next	2.4;

2.4
date	2004.03.02.17.49.47;	author athomps;	state Exp;
branches;
next	2.3;

2.3
date	2004.03.01.18.13.34;	author athomps;	state Exp;
branches;
next	2.2;

2.2
date	2004.01.28.20.36.13;	author athomps;	state Exp;
branches
	2.2.2.1;
next	2.1;

2.1
date	2004.01.09.19.01.08;	author athomps;	state Exp;
branches;
next	2.0;

2.0
date	2003.04.24.17.19.15;	author athomps;	state Exp;
branches;
next	1.5;

1.5
date	2003.03.17.17.14.18;	author athomps;	state Exp;
branches;
next	1.4;

1.4
date	2003.02.18.23.15.17;	author athomps;	state Exp;
branches;
next	1.3;

1.3
date	2003.02.04.00.12.41;	author athomps;	state Exp;
branches;
next	1.2;

1.2
date	2003.01.18.00.20.49;	author athomps;	state Exp;
branches;
next	1.1;

1.1
date	2003.01.08.23.25.53;	author athomps;	state Exp;
branches;
next	;

2.2.2.1
date	2004.09.13.23.00.09;	author cjkimme;	state Exp;
branches;
next	;

4.4.2.1
date	2006.08.28.22.33.15;	author athomps;	state Exp;
branches;
next	;


desc
@@


4.5
log
@Fixed midpoint bug and eliminated all osx_serial_debug warnings (-Wuninitialized, -Wshadow, ...)
@
text
@//-----------------------------------------------------------------------
//
//   G R A S P
//   ____________
//   \           \
//    \ General   \
//     \ Reactive  \
//      \ Atomistic \
//       \ Simulation\
//        \ Program   \
//         \___________\
//
//    Timestamp: April 1, 2005
//    Version: 4.0
//
//    Primary Author: Aidan P. Thompson
//
//    e-mail: athomps@@sandia.gov
//   
//    Copyright (2005) Sandia National Laboratories
//
//    Sandia National Laboratories is a multiprogram laboratory 
//    operated by Sandia Corporation, a Lockheed Martin company,
//    for the United States Department of Energy under contract
//    No. DE-AC04-94AL-85000.
//
//    Under the terms of Contract DE-AC04-94AL85000 with Sandia 
//    Corporation, the U.S. Government retains certain rights in 
//    this software.
//
//    This software is distributed under the terms of the GNU Public 
//    License (GPL). For a copy of the GPL see the file 
//    Grasp/Documentation/LICENSE or visit the GNU website at 
//    http://www.gnu.org/copyleft/gpl.html. Briefly, the GPL 
//    entitles you to use the software, modify it and redistribute it. 
//    The main thing you can not do is apply any other licensing 
//    terms to the software. Also, if any part of this sofware is added 
//    to other software, then that software must also be released under 
//    the GPL.
//
//    This software comes with no warranty of any kind. 
//
//----------------------------------------------------------------------- 
/////:EOH~

#ifndef FORCE_TWOBODY_INLINE_H
#define FORCE_TWOBODY_INLINE_H

// INLINE(inline) FUNCTION DEFINITIONS
//
// Inlining inner loop operations provides significant performance gain
//

inline void Force_Twobody::force_lj(
            const double xi[], const double xj[], 
	    double f[], const bool& Lenergy, const bool& Lvirial, 
	    double& energy, double virial_ij[],
	    const int& ientry) const {
  double delr_norm,delr2,delr_2,delr_6,virial_tmp;
  double delr[3];

  delr2 = vec3_distsq(xi,xj,delr);

  if (delr2 <= param_list[ientry].rcutsq) {
    
    delr_2 = 1.0/delr2;
    delr_6 = delr_2*delr_2*delr_2;
    virial_tmp = (param_list[ientry].params[0]*delr_6 
	      - param_list[ientry].params[1])*delr_6;
    virial_tmp*=delr_2;
    f[0] = virial_tmp*delr[0];
    f[1] = virial_tmp*delr[1];
    f[2] = virial_tmp*delr[2];
    if (Lenergy) {
      energy = (param_list[ientry].params[2]*delr_6
		- param_list[ientry].params[3])*delr_6
	        - param_list[ientry].params[4];
    }
    if (Lvirial) {
      virial_ij[0] = virial_tmp*delr[0]*delr[0];
      virial_ij[1] = virial_tmp*delr[1]*delr[1];
      virial_ij[2] = virial_tmp*delr[2]*delr[2];
      virial_ij[3] = virial_tmp*delr[0]*delr[1];
      virial_ij[4] = virial_tmp*delr[0]*delr[2];
      virial_ij[5] = virial_tmp*delr[1]*delr[2];
    }
  }  else {
    if (Lenergy) {
      energy = 0.0;
    }
    if (Lvirial) {
      for (int ivirial=0;ivirial<nvirial;ivirial++) {
	virial_ij[ivirial] = 0.0;
      }
    }
    f[0] = 0.0;
    f[1] = 0.0;
    f[2] = 0.0;
  }
}

inline void Force_Twobody::force_lj_coul(
	    const double xi[], const double xj[], 
	    double f[], const bool& Lenergy, const bool& Lvirial, 
	    double& energy_lj, double& energy_coul, double virial_ij[],
	    const int& ientry,
	    const double& qi, const double& qj) const {
  double delr_norm,delr2,delr_2,delr_6;
  double virial_lj,virial_tmp;
  double qiqjr;
  double delr[3];

  delr2 = vec3_distsq(xi,xj,delr);

  if (delr2 <= param_list[ientry].rcutsq) {
    
    delr_2 = 1.0/delr2;
    delr_6 = delr_2*delr_2*delr_2;
    virial_lj = (param_list[ientry].params[0]*delr_6 
	      - param_list[ientry].params[1])*delr_6;
    if (qi != 0.0 && qj != 0.0) {
      qiqjr =  param_list[ientry].params[5]*qi*qj*sqrt(delr_2);
    } else {
      qiqjr = 0.0;
    }
    virial_tmp = (virial_lj+qiqjr)*delr_2;
    f[0] = virial_tmp*delr[0];
    f[1] = virial_tmp*delr[1];
    f[2] = virial_tmp*delr[2];
    if (Lenergy) {
      energy_lj = (param_list[ientry].params[2]*delr_6 
		   - param_list[ientry].params[3])*delr_6
	           - param_list[ientry].params[4];
      energy_coul = qiqjr;
    }
    if (Lvirial) {
      virial_ij[0] = virial_tmp*delr[0]*delr[0];
      virial_ij[1] = virial_tmp*delr[1]*delr[1];
      virial_ij[2] = virial_tmp*delr[2]*delr[2];
      virial_ij[3] = virial_tmp*delr[0]*delr[1];
      virial_ij[4] = virial_tmp*delr[0]*delr[2];
      virial_ij[5] = virial_tmp*delr[1]*delr[2];
    }
  }  else {
    f[0] = 0.0;
    f[1] = 0.0;
    f[2] = 0.0;
    if (Lenergy) {
      energy_lj = 0.0;
      energy_coul = 0.0;
    }
    if (Lvirial) {
      for (int ivirial=0;ivirial<nvirial;ivirial++) {
	virial_ij[ivirial] = 0.0;
      }
    }
  }
  return ;
}

// This is the most convenient way to define static class constants
// associated with inline functions.
//
// These constants have external linkage, and so if this file is
// included twice in one or more program units, the compiler
// will give a 'duplicate initialization' error.
// However, this file is only required
// by one program unit, the class implementation. 
// In addition, accidental double inclusion 
// in a single program unit is prevented by the
// preprocessor boilerplate at the top of this file.
//
const double Force_Twobody::EWALD_F = 1.12837917;
const double Force_Twobody::EWALD_P = 0.3275911;
const double Force_Twobody::EWALD_A1 = 0.254829592;
const double Force_Twobody::EWALD_A2 = -0.284496736;
const double Force_Twobody::EWALD_A3 = 1.421413741;
const double Force_Twobody::EWALD_A4 = -1.453152027;
const double Force_Twobody::EWALD_A5 = 1.061405429;

inline void Force_Twobody::force_lj_ewald(
	    const double xi[], const double xj[], 
	    double f[], const bool& Lenergy, const bool& Lvirial, 
	    double& energy_lj, double& energy_coul, double virial_ij[],
	    const int& ientry,
	    const double& qi, const double& qj) const {
  double delr_norm,delr2,delr_2,delr_6;
  double virial_lj,virial_coul,virial_tmp;
  double qiqjr,t,grij,r,expm2,erfc;
  double delr[3];

  delr2 = vec3_distsq(xi,xj,delr);

  if (delr2 <= param_list[ientry].rcutsq) {
    
    delr_2 = 1.0/delr2;
    delr_6 = delr_2*delr_2*delr_2;
    virial_lj = (param_list[ientry].params[0]*delr_6 
	      - param_list[ientry].params[1])*delr_6;
    if (qi != 0.0 && qj != 0.0) {
      r = sqrt(delr2);
      grij = param_list[ientry].params[6] * r;
      expm2 = exp(-grij*grij);
      t = 1.0 / (1.0 + EWALD_P*grij);
      erfc = t * (EWALD_A1+t*(EWALD_A2+
	     t * (EWALD_A3+t*(EWALD_A4+t*EWALD_A5)))) * expm2;
      qiqjr =  param_list[ientry].params[5]*qi*qj/r;
      virial_coul = qiqjr*(erfc + EWALD_F*grij*expm2);
    } else {
      qiqjr = 0.0;
      erfc = 0.0;
      virial_coul = 0.0;
    }
    virial_tmp = (virial_lj+virial_coul)*delr_2;
    f[0] = virial_tmp*delr[0];
    f[1] = virial_tmp*delr[1];
    f[2] = virial_tmp*delr[2];
    if (Lenergy) {
      energy_lj = (param_list[ientry].params[2]*delr_6 
		   - param_list[ientry].params[3])*delr_6
                   - param_list[ientry].params[4];
      energy_coul = qiqjr*erfc;
    }
    if (Lvirial) {
      virial_ij[0] = virial_tmp*delr[0]*delr[0];
      virial_ij[1] = virial_tmp*delr[1]*delr[1];
      virial_ij[2] = virial_tmp*delr[2]*delr[2];
      virial_ij[3] = virial_tmp*delr[0]*delr[1];
      virial_ij[4] = virial_tmp*delr[0]*delr[2];
      virial_ij[5] = virial_tmp*delr[1]*delr[2];
    }
  }  else {
    f[0] = 0.0;
    f[1] = 0.0;
    f[2] = 0.0;
    if (Lenergy) {
      energy_lj = 0.0;
      energy_coul = 0.0;
    }
    if (Lvirial) {
      for (int ivirial=0;ivirial<nvirial;ivirial++) {
	virial_ij[ivirial] = 0.0;
      }
    }
  }

  return ;
}

inline void Force_Twobody::force_exp6(
	    const double xi[], const double xj[],
	    double f[], const bool& Lenergy, const bool& Lvirial, 
	    double& energy, double virial_ij[],
	    const int& ientry) const {
  double delr_norm,delr2,delr_2,delr_6,virial_tmp,expr;
  double delr[3];

  // delr is -r_ij = r_ji
  delr2 = vec3_distsq(xi,xj,delr);

  if (delr2 <= param_list[ientry].rcutsq) {
    
    delr_2 = 1.0/delr2;
    delr_6 = delr_2*delr_2*delr_2;
    delr_norm = sqrt(delr2);
    expr = exp(param_list[ientry].params[2]*delr_norm);
    virial_tmp = param_list[ientry].params[0]*delr_norm*expr   
      - param_list[ientry].params[1]*delr_6;
    virial_tmp*=delr_2;
    f[0] = virial_tmp*delr[0];
    f[1] = virial_tmp*delr[1];
    f[2] = virial_tmp*delr[2];
    if (Lenergy) {
      energy = param_list[ientry].params[3]*expr
	- param_list[ientry].params[4]*delr_6
	- param_list[ientry].params[5];

    }
    if (Lvirial) {
      virial_ij[0] = virial_tmp*delr[0]*delr[0];
      virial_ij[1] = virial_tmp*delr[1]*delr[1];
      virial_ij[2] = virial_tmp*delr[2]*delr[2];
      virial_ij[3] = virial_tmp*delr[0]*delr[1];
      virial_ij[4] = virial_tmp*delr[0]*delr[2];
      virial_ij[5] = virial_tmp*delr[1]*delr[2];
    }
  } else {
    if (Lenergy) {
      energy = 0.0;
    }
    if (Lvirial) {
      for (int ivirial=0;ivirial<nvirial;ivirial++) {
	virial_ij[ivirial] = 0.0;
      }
    }
    
    f[0] = 0.0;
    f[1] = 0.0;
    f[2] = 0.0;
  }
}

inline void Force_Twobody::force_exp6_coul(
	    const double xi[], const double xj[], 
	    double f[], const bool& Lenergy, const bool& Lvirial, 
	    double& energy_exp6, double& energy_coul, double virial_ij[],
	    const int& ientry,
	    const double& qi, const double& qj) const {
  double delr_norm,delr2,delr_2,delr_6,virial_tmp,expr;
  double delr[3];
  double qiqjr,virial_exp6;

  // delr is -r_ij = r_ji
  delr2 = vec3_distsq(xi,xj,delr);

  if (delr2 <= param_list[ientry].rcutsq) {
    
    delr_2 = 1.0/delr2;
    delr_6 = delr_2*delr_2*delr_2;
    delr_norm = sqrt(delr2);
    expr = exp(param_list[ientry].params[2]*delr_norm);
    virial_exp6 = param_list[ientry].params[0]*delr_norm*expr   
      - param_list[ientry].params[1]*delr_6;
    if (qi != 0.0 && qj != 0.0) {
      qiqjr =  param_list[ientry].params[6]*qi*qj*sqrt(delr_2);
    } else {
      qiqjr = 0.0;
    }
    virial_tmp = (virial_exp6+qiqjr)*delr_2;
    f[0] = virial_tmp*delr[0];
    f[1] = virial_tmp*delr[1];
    f[2] = virial_tmp*delr[2];
    if (Lenergy) {
      energy_exp6 = param_list[ientry].params[3]*expr
	- param_list[ientry].params[4]*delr_6
	- param_list[ientry].params[5];
      energy_coul = qiqjr;
    }
    if (Lvirial) {
      virial_ij[0] = virial_tmp*delr[0]*delr[0];
      virial_ij[1] = virial_tmp*delr[1]*delr[1];
      virial_ij[2] = virial_tmp*delr[2]*delr[2];
      virial_ij[3] = virial_tmp*delr[0]*delr[1];
      virial_ij[4] = virial_tmp*delr[0]*delr[2];
      virial_ij[5] = virial_tmp*delr[1]*delr[2];
    }
  } else {
    if (Lenergy) {
      energy_exp6 = 0.0;
      energy_coul = 0.0;
    }
    if (Lvirial) {
      for (int ivirial=0;ivirial<nvirial;ivirial++) {
	virial_ij[ivirial] = 0.0;
      }
    }
    
    f[0] = 0.0;
    f[1] = 0.0;
    f[2] = 0.0;
  }
}

inline void Force_Twobody::force_exp6_ewald(
	    const double xi[], const double xj[], 
	    double f[], const bool& Lenergy, const bool& Lvirial, 
	    double& energy_exp6, double& energy_coul, double virial_ij[],
	    const int& ientry,
	    const double& qi, const double& qj) const {
  double delr_norm,delr2,delr_2,delr_6,virial_tmp,expr;
  double delr[3];
  double qiqjr,virial_exp6,virial_coul;
  double t,grij,r,expm2,erfc;

  // delr is -r_ij = r_ji
  delr2 = vec3_distsq(xi,xj,delr);

  if (delr2 <= param_list[ientry].rcutsq) {
    
    delr_2 = 1.0/delr2;
    delr_6 = delr_2*delr_2*delr_2;
    delr_norm = sqrt(delr2);
    expr = exp(param_list[ientry].params[2]*delr_norm);
    virial_exp6 = param_list[ientry].params[0]*delr_norm*expr   
      - param_list[ientry].params[1]*delr_6;
    if (qi != 0.0 && qj != 0.0) {
      r = sqrt(delr2);
      grij = param_list[ientry].params[7] * r;
      expm2 = exp(-grij*grij);
      t = 1.0 / (1.0 + EWALD_P*grij);
      erfc = t * (EWALD_A1+t*(EWALD_A2+
	     t * (EWALD_A3+t*(EWALD_A4+t*EWALD_A5)))) * expm2;
      qiqjr =  param_list[ientry].params[6]*qi*qj/r;
      virial_coul = qiqjr*(erfc + EWALD_F*grij*expm2);
    } else {
      qiqjr = 0.0;
      erfc = 0.0;
      virial_coul = 0.0;
    }
    virial_tmp = (virial_exp6+virial_coul)*delr_2;
    f[0] = virial_tmp*delr[0];
    f[1] = virial_tmp*delr[1];
    f[2] = virial_tmp*delr[2];
    if (Lenergy) {
      energy_exp6 = param_list[ientry].params[3]*expr
	- param_list[ientry].params[4]*delr_6
	- param_list[ientry].params[5];
      energy_coul = qiqjr*erfc;
    }
    if (Lvirial) {
      virial_ij[0] = virial_tmp*delr[0]*delr[0];
      virial_ij[1] = virial_tmp*delr[1]*delr[1];
      virial_ij[2] = virial_tmp*delr[2]*delr[2];
      virial_ij[3] = virial_tmp*delr[0]*delr[1];
      virial_ij[4] = virial_tmp*delr[0]*delr[2];
      virial_ij[5] = virial_tmp*delr[1]*delr[2];
    }
  } else {
    if (Lenergy) {
      energy_exp6 = 0.0;
      energy_coul = 0.0;
    }
    if (Lvirial) {
      for (int ivirial=0;ivirial<nvirial;ivirial++) {
	virial_ij[ivirial] = 0.0;
      }
    }
    
    f[0] = 0.0;
    f[1] = 0.0;
    f[2] = 0.0;
  }
}

#endif
@


4.4
log
@Added GaAs version of Tersoff
@
text
@d57 1
a57 1
	    double& energy, double virial[],
d80 6
a85 6
      virial[0] = virial_tmp*delr[0]*delr[0];
      virial[1] = virial_tmp*delr[1]*delr[1];
      virial[2] = virial_tmp*delr[2]*delr[2];
      virial[3] = virial_tmp*delr[0]*delr[1];
      virial[4] = virial_tmp*delr[0]*delr[2];
      virial[5] = virial_tmp*delr[1]*delr[2];
d93 1
a93 1
	virial[ivirial] = 0.0;
d105 1
a105 1
	    double& energy_lj, double& energy_coul, double virial[],
d137 6
a142 6
      virial[0] = virial_tmp*delr[0]*delr[0];
      virial[1] = virial_tmp*delr[1]*delr[1];
      virial[2] = virial_tmp*delr[2]*delr[2];
      virial[3] = virial_tmp*delr[0]*delr[1];
      virial[4] = virial_tmp*delr[0]*delr[2];
      virial[5] = virial_tmp*delr[1]*delr[2];
d154 1
a154 1
	virial[ivirial] = 0.0;
d184 1
a184 1
	    double& energy_lj, double& energy_coul, double virial[],
d225 6
a230 6
      virial[0] = virial_tmp*delr[0]*delr[0];
      virial[1] = virial_tmp*delr[1]*delr[1];
      virial[2] = virial_tmp*delr[2]*delr[2];
      virial[3] = virial_tmp*delr[0]*delr[1];
      virial[4] = virial_tmp*delr[0]*delr[2];
      virial[5] = virial_tmp*delr[1]*delr[2];
d242 1
a242 1
	virial[ivirial] = 0.0;
d253 1
a253 1
	    double& energy, double virial[],
d280 6
a285 6
      virial[0] = virial_tmp*delr[0]*delr[0];
      virial[1] = virial_tmp*delr[1]*delr[1];
      virial[2] = virial_tmp*delr[2]*delr[2];
      virial[3] = virial_tmp*delr[0]*delr[1];
      virial[4] = virial_tmp*delr[0]*delr[2];
      virial[5] = virial_tmp*delr[1]*delr[2];
d293 1
a293 1
	virial[ivirial] = 0.0;
d306 1
a306 1
	    double& energy_exp6, double& energy_coul, double virial[],
d340 6
a345 6
      virial[0] = virial_tmp*delr[0]*delr[0];
      virial[1] = virial_tmp*delr[1]*delr[1];
      virial[2] = virial_tmp*delr[2]*delr[2];
      virial[3] = virial_tmp*delr[0]*delr[1];
      virial[4] = virial_tmp*delr[0]*delr[2];
      virial[5] = virial_tmp*delr[1]*delr[2];
d354 1
a354 1
	virial[ivirial] = 0.0;
d367 1
a367 1
	    double& energy_exp6, double& energy_coul, double virial[],
d411 6
a416 6
      virial[0] = virial_tmp*delr[0]*delr[0];
      virial[1] = virial_tmp*delr[1]*delr[1];
      virial[2] = virial_tmp*delr[2]*delr[2];
      virial[3] = virial_tmp*delr[0]*delr[1];
      virial[4] = virial_tmp*delr[0]*delr[2];
      virial[5] = virial_tmp*delr[1]*delr[2];
d425 1
a425 1
	virial[ivirial] = 0.0;
@


4.4.2.1
log
@Created automatic differentiation version for LJ force field, called lj_cut_AD
@
text
@a53 47
inline void Force_Twobody::force_lj_AD(
            const double xi[], const double xj[], 
	    double f[], const bool& Lenergy, const bool& Lvirial, 
	    double& energy, double virial[],
	    const int& ientry) const {

  // This function computes energies and forces for the standard 
  // truncated LJ interaction, but the force sare obtained using 
  // automatic differention. This is achieved using the SFad
  // class, which is part of the ADTools library, developed by
  // Eric Phipps and others. To access this function, you need to
  // specify the lj_cut_AD interaction style:
  // 
  // A   A   lj_cut_AD  1.0 1.0  3.0
  //

  ADTools::Fad::SFad<double,3> xi_fad[3], energy_fad, delr2, delr_2, delr_6;

  for (int i=0; i<3; i++) {
    xi_fad[i] = ADTools::Fad::SFad<double,3>(3, i, xi[i]);
  }

  delr2 = vec3_distsq(xi_fad,xj);

  if (delr2 <= param_list[ientry].rcutsq) {
     delr_2 = 1.0/delr2; 
     delr_6 = delr_2*delr_2*delr_2; 
     energy_fad = (param_list[ientry].params[2]*delr_6 
 	      - param_list[ientry].params[3])*delr_6 
       - param_list[ientry].params[4]; 

  }
  else {
    energy_fad = 0.0;
  }

  energy = energy_fad.val();
  for (int i=0; i<3; i++)
    f[i] = -energy_fad.dx(i);

  if (Lvirial) {
    for (int ivirial=0;ivirial<nvirial;ivirial++) {
      virial[ivirial] = 0.0;
    }
  }
}

@


4.3
log
@Fixed glitch in header.
@
text
@d161 12
a172 5
// This is a little risky, since if for any reason,
// this file is include in more than one file,
// the compiler will baulk. Should really put these
// initializations directly in force_twobody.cpp, or in a separate
// include used only by force_twobody.cpp
@


4.2
log
@Recovered from corruption on April 12, 1005
@
text
@d43 1
a43 1
//------------------------------------------------------------------------ 
@


4.1
log
@Create new branch.
@
text
@d13 2
a14 2
//    Timestamp: September 22, 2004
//    Version: 3.0
d16 1
a16 1
//    Author: Aidan P. Thompson
d20 4
a23 4
//    Copyright (2004) Sandia National Laboratories
//   
//    Sandia is a multiprogram laboratory operated by 
//    Sandia Corporation, a Lockheed Martin company,
d27 16
@


4.0
log
@This is version 4.0
@
text
@d13 2
a14 2
//    Timestamp: April 1, 2005
//    Version: 4.0
d16 1
a16 1
//    Primary Author: Aidan P. Thompson
d20 4
a23 4
//    Copyright (2005) Sandia National Laboratories
//
//    Sandia National Laboratories is a multiprogram laboratory 
//    operated by Sandia Corporation, a Lockheed Martin company,
a26 16
//    Under the terms of Contract DE-AC04-94AL85000 with Sandia 
//    Corporation, the U.S. Government retains certain rights in 
//    this software.
//
//    This software is distributed under the terms of the GNU Public 
//    License (GPL). For a copy of the GPL see the file 
//    Grasp/Documentation/LICENSE or visit the GNU website at 
//    http://www.gnu.org/copyleft/gpl.html. Briefly, the GPL 
//    entitles you to use the software, modify it and redistribute it. 
//    The main thing you can not do is apply any other licensing 
//    terms to the software. Also, if any part of this sofware is added 
//    to other software, then that software must also be released under 
//    the GPL.
//
//    This software comes with no warranty of any kind. 
//
@


3.3
log
@Merged REAX version with main version
@
text
@d16 1
a16 1
//    Author: Aidan P. Thompson
d20 4
a23 4
//    Copyright (2004) Sandia National Laboratories
//   
//    Sandia is a multiprogram laboratory operated by 
//    Sandia Corporation, a Lockheed Martin company,
d27 16
@


3.2
log
@Added a ForceTwobody exp6 example (BKS SiO2) to the
test suite.
@
text
@d13 2
a14 2
//    Timestamp: September 22, 2004
//    Version: 3.0
@


3.1
log
@Redid Force_Twobody class to better handle many different variants.
Added in new for of exp6 that is required for BKS force field.
@
text
@d302 1
a302 1
      qiqjr =  param_list[ientry].params[5]*qi*qj*sqrt(delr_2);
d365 1
a365 1
      grij = param_list[ientry].params[6] * r;
d370 1
a370 1
      qiqjr =  param_list[ientry].params[5]*qi*qj/r;
@


3.0
log
@Created a new version number, GRASP 3.0
@
text
@d38 2
a39 2
inline void Force_Twobody::force_lj_cut(
	    const double xi[], const double xj[],
a45 1
  // delr is -r_ij = r_ji
d48 1
a48 1
  if (delr2 <= param_list[ientry].params[4]) {
d52 1
a52 2
    // virial_tmp is (-1/r)dphi/dr
    virial_tmp = (param_list[ientry].params[0]*delr_6
a54 1
    // f_i = -grad_i phi(r_ij) = -dphi/dr grad_i r_ij = virial_tmp r_ji
d60 2
a61 1
		- param_list[ientry].params[3])*delr_6;
a79 1

d86 2
a87 2
inline void Force_Twobody::force_lj_cut_shift(
            const double xi[], const double xj[], 
d89 6
a94 3
	    double& energy, double virial[],
	    const int& ientry) const {
  double delr_norm,delr2,delr_2,delr_6,virial_tmp;
d99 1
a99 1
  if (delr2 <= param_list[ientry].params[4]) {
d103 1
a103 1
    virial_tmp = (param_list[ientry].params[0]*delr_6 
d105 4
a108 8
    virial_tmp*=delr_2;
    f[0] = virial_tmp*delr[0];
    f[1] = virial_tmp*delr[1];
    f[2] = virial_tmp*delr[2];
    if (Lenergy) {
      energy = (param_list[ientry].params[2]*delr_6
		- param_list[ientry].params[3])*delr_6
	        - param_list[ientry].params[5];
d110 1
a110 187
    if (Lvirial) {
      virial[0] = virial_tmp*delr[0]*delr[0];
      virial[1] = virial_tmp*delr[1]*delr[1];
      virial[2] = virial_tmp*delr[2]*delr[2];
      virial[3] = virial_tmp*delr[0]*delr[1];
      virial[4] = virial_tmp*delr[0]*delr[2];
      virial[5] = virial_tmp*delr[1]*delr[2];
    }
  }  else {
    if (Lenergy) {
      energy = 0.0;
    }
    if (Lvirial) {
      for (int ivirial=0;ivirial<nvirial;ivirial++) {
	virial[ivirial] = 0.0;
      }
    }
    f[0] = 0.0;
    f[1] = 0.0;
    f[2] = 0.0;
  }
}

inline void Force_Twobody::force_lj_cut_minimg(
            const Particle& pi, const Particle& pj, 
	    double f[], const bool& Lenergy, const bool& Lvirial, 
	    double& energy, double virial[],
	    const int& ientry, const Box* b) const {
  double xi[3],xj[3];

  pi.get_x(xi);
  pj.get_x(xj);
  
  b->Minimg_Diff_Shift(xi,xj);

  force_lj_cut(xi,xj,f,Lenergy,Lvirial,energy,virial,ientry);

}

inline void Force_Twobody::force_lj_cut_shift_minimg(
            const Particle& pi, const Particle& pj, 
	    double f[], const bool& Lenergy, const bool& Lvirial, 
	    double& energy, double virial[],
	    const int& ientry, const Box* b) const {
  double xi[3],xj[3];

  pi.get_x(xi);
  pj.get_x(xj);
  
  b->Minimg_Diff_Shift(xi,xj);

  force_lj_cut_shift(xi,xj,f,Lenergy,Lvirial,energy,virial,ientry);
}

inline void Force_Twobody::force_lj_nocut_minimg(
            const Particle& pi, const Particle& pj, 
	    double f[], const bool& Lenergy, const bool& Lvirial, 
	    double& energy, double virial[],
	    const int& ientry, const Box* b) const {
  double xi[3],xj[3],delr[3];
  double delr_norm,delr2,delr_2,delr_6,virial_tmp;

  pi.get_x(xi);
  pj.get_x(xj);
  
  b->Minimg_Diff(xi,xj,delr);
  delr2 = delr[0]*delr[0]+delr[1]*delr[1]+delr[2]*delr[2];

  delr_2 = 1.0/delr2;
  delr_6 = delr_2*delr_2*delr_2;

  virial_tmp = (param_list[ientry].params[0]*delr_6 
		- param_list[ientry].params[1])*delr_6;
  virial_tmp*=delr_2;
  f[0] = virial_tmp*delr[0];
  f[1] = virial_tmp*delr[1];
  f[2] = virial_tmp*delr[2];
  if (Lenergy) {
    energy = (param_list[ientry].params[2]*delr_6
	      - param_list[ientry].params[3])*delr_6;
  }
  if (Lvirial) {
    virial[0] = virial_tmp*delr[0]*delr[0];
    virial[1] = virial_tmp*delr[1]*delr[1];
    virial[2] = virial_tmp*delr[2]*delr[2];
    virial[3] = virial_tmp*delr[0]*delr[1];
    virial[4] = virial_tmp*delr[0]*delr[2];
    virial[5] = virial_tmp*delr[1]*delr[2];
  }
}

inline void Force_Twobody::force_exp6_nocut_minimg(
            const Particle& pi, const Particle& pj, 
	    double f[], const bool& Lenergy, const bool& Lvirial, 
	    double& energy, double virial[],
	    const int& ientry, const Box* b) const {
  double xi[3],xj[3],delr[3];
  double delr_norm,delr2,delr_2,delr_6,virial_tmp,expr;

  pi.get_x(xi);
  pj.get_x(xj);
  b->Minimg_Diff(xi,xj,delr);
  delr2 = delr[0]*delr[0]+delr[1]*delr[1]+delr[2]*delr[2];
  delr_2 = 1.0/delr2;
  delr_6 = delr_2*delr_2*delr_2;
  delr_norm = sqrt(delr2);
  expr = exp(param_list[ientry].params[2] - 
	      param_list[ientry].params[3]*delr_norm);
  virial_tmp = param_list[ientry].params[0]*delr_norm*expr   
    - param_list[ientry].params[1]*delr_6;
  virial_tmp*=delr_2;
  f[0] = virial_tmp*delr[0];
  f[1] = virial_tmp*delr[1];
  f[2] = virial_tmp*delr[2];
  if (Lenergy) {
    energy = param_list[ientry].params[4]*expr
      - param_list[ientry].params[5]*delr_6;
  }
  if (Lvirial) {
    virial[0] = virial_tmp*delr[0]*delr[0];
    virial[1] = virial_tmp*delr[1]*delr[1];
    virial[2] = virial_tmp*delr[2]*delr[2];
    virial[3] = virial_tmp*delr[0]*delr[1];
    virial[4] = virial_tmp*delr[0]*delr[2];
    virial[5] = virial_tmp*delr[1]*delr[2];
  }
}

inline void Force_Twobody::force_square_exp6_nocut_minimg(
	    const Particle& pi, const Particle& pj, 
	    double f[], const bool& Lenergy, const bool& Lvirial, 
	    double& energy, double virial[],
	    const int& ientry, const Box* b) const {
  double xi[3],xj[3],delr[3];
  double delr2,delr_2,delr_6,virial_tmp,expr;

  pi.get_x(xi);
  pj.get_x(xj);
  b->Minimg_Diff(xi,xj,delr);
  delr2 = delr[0]*delr[0]+delr[1]*delr[1]+delr[2]*delr[2];
  delr_2 = 1.0/delr2;
  delr_6 = delr_2*delr_2*delr_2;
  expr = exp(param_list[ientry].params[2] - 
	      param_list[ientry].params[3]*delr2);
  virial_tmp = param_list[ientry].params[0]*delr2*expr   
    - param_list[ientry].params[1]*delr_6;
  virial_tmp*=delr_2;
  f[0] = virial_tmp*delr[0];
  f[1] = virial_tmp*delr[1];
  f[2] = virial_tmp*delr[2];
  if (Lenergy) {
    energy = param_list[ientry].params[4]*expr
      - param_list[ientry].params[5]*delr_6;
  }
  if (Lvirial) {
    virial[0] = virial_tmp*delr[0]*delr[0];
    virial[1] = virial_tmp*delr[1]*delr[1];
    virial[2] = virial_tmp*delr[2]*delr[2];
    virial[3] = virial_tmp*delr[0]*delr[1];
    virial[4] = virial_tmp*delr[0]*delr[2];
    virial[5] = virial_tmp*delr[1]*delr[2];
  }
}

inline void Force_Twobody::force_lj_cut_nopbc(
	    const Particle& pi, const Particle& pj, 
	    double f[], const bool& Lenergy, const bool& Lvirial, 
	    double& energy, double virial[],
	    const int& ientry) const {
  double xi[3],xj[3],delr[3];
  double delr_norm,delr2,delr_2,delr_6,virial_tmp;

  pi.get_x(xi);
  pj.get_x(xj);
  delr[0] = xi[0]-xj[0];
  delr[1] = xi[1]-xj[1];
  delr[2] = xi[2]-xj[2];
  
  delr2 = delr[0]*delr[0]+delr[1]*delr[1]+delr[2]*delr[2];

  if (delr2 <= param_list[ientry].params[4]) {
    
    delr_2 = 1.0/delr2;
    delr_6 = delr_2*delr_2*delr_2;
    virial_tmp = (param_list[ientry].params[0]*delr_6
	      - param_list[ientry].params[1])*delr_6;
    virial_tmp*=delr_2;
d115 4
a118 2
      energy = (param_list[ientry].params[2]*delr_6
		- param_list[ientry].params[3])*delr_6;
a128 9
    if (Lenergy) {
      energy = 0.0;
    }
    if (Lvirial) {
      for (int ivirial=0;ivirial<nvirial;ivirial++) {
	virial[ivirial] = 0.0;
      }
    }

a131 29
  }
}

inline void Force_Twobody::force_lj_cut_shift_nopbc(
	    const Particle& pi, const Particle& pj, 
	    double f[], const bool& Lenergy, const bool& Lvirial, 
	    double& energy, double virial[],
	    const int& ientry) const {
  double xi[3],xj[3],delr[3];
  double delr_norm,delr2,delr_2,delr_6,virial_tmp;

  pi.get_x(xi);
  pj.get_x(xj);
  delr[0] = xi[0]-xj[0];
  delr[1] = xi[1]-xj[1];
  delr[2] = xi[2]-xj[2];
  
  delr2 = delr[0]*delr[0]+delr[1]*delr[1]+delr[2]*delr[2];

  if (delr2 <= param_list[ientry].params[4]) {
    
    delr_2 = 1.0/delr2;
    delr_6 = delr_2*delr_2*delr_2;
    virial_tmp = (param_list[ientry].params[0]*delr_6 
	      - param_list[ientry].params[1])*delr_6;
    virial_tmp*=delr_2;
    f[0] = virial_tmp*delr[0];
    f[1] = virial_tmp*delr[1];
    f[2] = virial_tmp*delr[2];
d133 2
a134 15
      energy = (param_list[ientry].params[2]*delr_6
		- param_list[ientry].params[3])*delr_6
	        - param_list[ientry].params[5];
    }
    if (Lvirial) {
      virial[0] = virial_tmp*delr[0]*delr[0];
      virial[1] = virial_tmp*delr[1]*delr[1];
      virial[2] = virial_tmp*delr[2]*delr[2];
      virial[3] = virial_tmp*delr[0]*delr[1];
      virial[4] = virial_tmp*delr[0]*delr[2];
      virial[5] = virial_tmp*delr[1]*delr[2];
    }
  }  else {
    if (Lenergy) {
      energy = 0.0;
a140 3
    f[0] = 0.0;
    f[1] = 0.0;
    f[2] = 0.0;
d142 1
d145 12
a156 114
inline void Force_Twobody::force_lj_nocut_nopbc(
            const Particle& pi, const Particle& pj, 
	    double f[], const bool& Lenergy, const bool& Lvirial, 
	    double& energy, double virial[],
	    const int& ientry) const {
  double xi[3],xj[3],delr[3];
  double delr_norm,delr2,delr_2,delr_6,virial_tmp;

  pi.get_x(xi);
  pj.get_x(xj);
  delr[0] = xi[0]-xj[0];
  delr[1] = xi[1]-xj[1];
  delr[2] = xi[2]-xj[2];
  delr2 = delr[0]*delr[0]+delr[1]*delr[1]+delr[2]*delr[2];

  delr_2 = 1.0/delr2;
  delr_6 = delr_2*delr_2*delr_2;

  virial_tmp = (param_list[ientry].params[0]*delr_6 
		- param_list[ientry].params[1])*delr_6;
  virial_tmp*=delr_2;
  f[0] = virial_tmp*delr[0];
  f[1] = virial_tmp*delr[1];
  f[2] = virial_tmp*delr[2];
  if (Lenergy) {
    energy = (param_list[ientry].params[2]*delr_6
	      - param_list[ientry].params[3])*delr_6;
  }
  if (Lvirial) {
    virial[0] = virial_tmp*delr[0]*delr[0];
    virial[1] = virial_tmp*delr[1]*delr[1];
    virial[2] = virial_tmp*delr[2]*delr[2];
    virial[3] = virial_tmp*delr[0]*delr[1];
    virial[4] = virial_tmp*delr[0]*delr[2];
    virial[5] = virial_tmp*delr[1]*delr[2];
  }
}

inline void Force_Twobody::force_exp6_nocut_nopbc(
            const Particle& pi, const Particle& pj, 
	    double f[], const bool& Lenergy, const bool& Lvirial, 
	    double& energy, double virial[],
	    const int& ientry) const {
  double xi[3],xj[3],delr[3];
  double delr_norm,delr2,delr_2,delr_6,virial_tmp,expr;

  pi.get_x(xi);
  pj.get_x(xj);
  delr[0] = xi[0]-xj[0];
  delr[1] = xi[1]-xj[1];
  delr[2] = xi[2]-xj[2];
  delr2 = delr[0]*delr[0]+delr[1]*delr[1]+delr[2]*delr[2];
  delr_2 = 1.0/delr2;
  delr_6 = delr_2*delr_2*delr_2;
  delr_norm = sqrt(delr2);
  expr = exp(param_list[ientry].params[2] - 
	      param_list[ientry].params[3]*delr_norm);
  virial_tmp = param_list[ientry].params[0]*delr_norm*expr   
    - param_list[ientry].params[1]*delr_6;
  virial_tmp*=delr_2;
  f[0] = virial_tmp*delr[0];
  f[1] = virial_tmp*delr[1];
  f[2] = virial_tmp*delr[2];
  if (Lenergy) {
    energy = param_list[ientry].params[4]*expr
      - param_list[ientry].params[5]*delr_6;
  }
  if (Lvirial) {
    virial[0] = virial_tmp*delr[0]*delr[0];
    virial[1] = virial_tmp*delr[1]*delr[1];
    virial[2] = virial_tmp*delr[2]*delr[2];
    virial[3] = virial_tmp*delr[0]*delr[1];
    virial[4] = virial_tmp*delr[0]*delr[2];
    virial[5] = virial_tmp*delr[1]*delr[2];
  }
}

inline void Force_Twobody::force_square_exp6_nocut_nopbc(
	    const Particle& pi, const Particle& pj, 
	    double f[], const bool& Lenergy, const bool& Lvirial, 
	    double& energy, double virial[],
	    const int& ientry) const {
  double xi[3],xj[3],delr[3];
  double delr2,delr_2,delr_6,virial_tmp,expr;

  pi.get_x(xi);
  pj.get_x(xj);
  delr[0] = xi[0]-xj[0];
  delr[1] = xi[1]-xj[1];
  delr[2] = xi[2]-xj[2];
  delr2 = delr[0]*delr[0]+delr[1]*delr[1]+delr[2]*delr[2];
  delr_2 = 1.0/delr2;
  delr_6 = delr_2*delr_2*delr_2;
  expr = exp(param_list[ientry].params[2] - 
	      param_list[ientry].params[3]*delr2);
  virial_tmp = param_list[ientry].params[0]*delr2*expr   
    - param_list[ientry].params[1]*delr_6;
  virial_tmp*=delr_2;
  f[0] = virial_tmp*delr[0];
  f[1] = virial_tmp*delr[1];
  f[2] = virial_tmp*delr[2];
  if (Lenergy) {
    energy = param_list[ientry].params[4]*expr
      - param_list[ientry].params[5]*delr_6;
  }
  if (Lvirial) {
    virial[0] = virial_tmp*delr[0]*delr[0];
    virial[1] = virial_tmp*delr[1]*delr[1];
    virial[2] = virial_tmp*delr[2]*delr[2];
    virial[3] = virial_tmp*delr[0]*delr[1];
    virial[4] = virial_tmp*delr[0]*delr[2];
    virial[5] = virial_tmp*delr[1]*delr[2];
  }
}
d158 1
a158 1
inline void Force_Twobody::force_lj_cut_coul(
d165 2
a166 2
  double virial_lj,virial_tmp;
  double qiqjr;
d171 1
a171 1
  if (delr2 <= param_list[ientry].params[4]) {
d178 8
a185 1
      qiqjr =  param_list[ientry].params[5]*qi*qj*sqrt(delr_2);
d188 2
d191 1
a191 1
    virial_tmp = (virial_lj+qiqjr)*delr_2;
d197 3
a199 2
		   - param_list[ientry].params[3])*delr_6;
      energy_coul = qiqjr;
d223 1
d227 2
a228 2
inline void Force_Twobody::force_lj_cut_shift_coul(
	    const double xi[], const double xj[], 
d230 3
a232 6
	    double& energy_lj, double& energy_coul, double virial[],
	    const int& ientry,
	    const double& qi, const double& qj) const {
  double delr_norm,delr2,delr_2,delr_6;
  double virial_lj,virial_tmp;
  double qiqjr;
d235 1
d238 1
a238 1
  if (delr2 <= param_list[ientry].params[4]) {
d242 5
a246 8
    virial_lj = (param_list[ientry].params[0]*delr_6 
	      - param_list[ientry].params[1])*delr_6;
    if (qi != 0.0 && qj != 0.0) {
      qiqjr =  param_list[ientry].params[5]*qi*qj*sqrt(delr_2);
    } else {
      qiqjr = 0.0;
    }
    virial_tmp = (virial_lj+qiqjr)*delr_2;
d251 4
a254 4
      energy_lj = (param_list[ientry].params[2]*delr_6 
		   - param_list[ientry].params[3])*delr_6
	           - param_list[ientry].params[6];
      energy_coul = qiqjr;
d264 1
a264 4
  }  else {
    f[0] = 0.0;
    f[1] = 0.0;
    f[2] = 0.0;
d266 1
a266 2
      energy_lj = 0.0;
      energy_coul = 0.0;
d273 4
a277 1
  return ;
d280 1
a280 14
// This is a little risky, since if for any reason,
// this file is include in more than one file,
// the compiler will baulk. Should really put these
// initializations directly in force_twobody.cpp, or in a separate
// include used only by force_twobody.cpp
const double Force_Twobody::EWALD_F = 1.12837917;
const double Force_Twobody::EWALD_P = 0.3275911;
const double Force_Twobody::EWALD_A1 = 0.254829592;
const double Force_Twobody::EWALD_A2 = -0.284496736;
const double Force_Twobody::EWALD_A3 = 1.421413741;
const double Force_Twobody::EWALD_A4 = -1.453152027;
const double Force_Twobody::EWALD_A5 = 1.061405429;

inline void Force_Twobody::force_lj_cut_ewald(
d283 1
a283 1
	    double& energy_lj, double& energy_coul, double virial[],
d286 1
a286 3
  double delr_norm,delr2,delr_2,delr_6;
  double virial_lj,virial_coul,virial_tmp;
  double qiqjr,t,grij,r,expm2,erfc;
d288 1
d290 1
d293 1
a293 1
  if (delr2 <= param_list[ientry].params[4]) {
d297 4
a300 2
    virial_lj = (param_list[ientry].params[0]*delr_6 
	      - param_list[ientry].params[1])*delr_6;
d302 1
a302 8
      r = sqrt(delr2);
      grij = param_list[ientry].params[6] * r;
      expm2 = exp(-grij*grij);
      t = 1.0 / (1.0 + EWALD_P*grij);
      erfc = t * (EWALD_A1+t*(EWALD_A2+
	     t*(EWALD_A3+t*(EWALD_A4+t*EWALD_A5)))) * expm2;
      qiqjr =  param_list[ientry].params[5]*qi*qj/r;
      virial_coul = qiqjr*(erfc + EWALD_F*grij*expm2);
a304 2
      erfc = 0.0;
      virial_coul = 0.0;
d306 1
a306 1
    virial_tmp = (virial_lj+virial_coul)*delr_2;
d311 4
a314 3
      energy_lj = (param_list[ientry].params[2]*delr_6 
		   - param_list[ientry].params[3])*delr_6;
      energy_coul = qiqjr*erfc;
d324 1
a324 4
  }  else {
    f[0] = 0.0;
    f[1] = 0.0;
    f[2] = 0.0;
d326 1
a326 1
      energy_lj = 0.0;
d334 4
a338 2

  return ;
d341 1
a341 1
inline void Force_Twobody::force_lj_cut_shift_ewald(
d344 1
a344 1
	    double& energy_lj, double& energy_coul, double virial[],
d347 1
a347 3
  double delr_norm,delr2,delr_2,delr_6;
  double virial_lj,virial_coul,virial_tmp;
  double qiqjr,t,grij,r,expm2,erfc;
d349 2
d352 1
d355 1
a355 1
  if (delr2 <= param_list[ientry].params[4]) {
d359 4
a362 2
    virial_lj = (param_list[ientry].params[0]*delr_6 
	      - param_list[ientry].params[1])*delr_6;
d377 1
a377 1
    virial_tmp = (virial_lj+virial_coul)*delr_2;
d382 3
a384 3
      energy_lj = (param_list[ientry].params[2]*delr_6 
		   - param_list[ientry].params[3])*delr_6
                   - param_list[ientry].params[7];
d395 1
a395 4
  }  else {
    f[0] = 0.0;
    f[1] = 0.0;
    f[2] = 0.0;
d397 1
a397 1
      energy_lj = 0.0;
d405 4
a409 2

  return ;
@


2.12
log
@Eliminated troublesome use of inline static const initializations
to define compile-time integer constants. Replaced with enumeration constants.
@
text
@d13 2
a14 1
//    Timestamp: July 26, 2004
@


2.11
log
@Updated header
@
text
@d617 5
@


2.10
log
@Fixed problem with Ewald sum parameters.
@
text
@d13 1
a13 1
//    Timestamp: 1 March 2004
@


2.9
log
@Added anisotropic style to pressure control,
and included in Tersoff example testp.
@
text
@d617 8
d649 2
a650 1
      erfc = t * (A1+t*(A2+t*(A3+t*(A4+t*A5)))) * expm2;
d717 2
a718 1
      erfc = t * (A1+t*(A2+t*(A3+t*(A4+t*A5)))) * expm2;
@


2.8
log
@Added the Tersoff force field class
@
text
@a627 8
  static const double EWALD_F = 1.12837917;
  static const double EWALD_P = 0.3275911;
  static const double A1 = 0.254829592;
  static const double A2 = -0.284496736;
  static const double A3 = 1.421413741;
  static const double A4 = -1.453152027;
  static const double A5 = 1.061405429;

a693 8

  static const double EWALD_F = 1.12837917;
  static const double EWALD_P = 0.3275911;
  static const double A1 = 0.254829592;
  static const double A2 = -0.284496736;
  static const double A3 = 1.421413741;
  static const double A4 = -1.453152027;
  static const double A5 = 1.061405429;
@


2.7
log
@Added NPT ensemble. Noy sure if it is working
yet, and need to update documentation.
@
text
@d45 1
d52 1
d56 1
@


2.6
log
@Added force_ewald.
Moved eam data from Particle into Force_Eam.
Added some fast version of LJ forces.
Eliminated redundant reneighboring on first timestep.
This caused epsilon changes in some forces.
@
text
@d38 5
a42 5
					const double xi[], const double xj[],
					double f[], double& energy,
					const int& ientry) const
{
  double delr_norm,delr2,delr_2,delr_6,virial;
d51 1
a51 1
    virial = (param_list[ientry].params[0]*delr_6
d53 16
a68 6
    energy = (param_list[ientry].params[2]*delr_6
	      - param_list[ientry].params[3])*delr_6;
    
    f[0] = virial*delr[0]*delr_2;
    f[1] = virial*delr[1]*delr_2;
    f[2] = virial*delr[2]*delr_2;
d70 9
a78 2
    virial = 0.0;
    energy = 0.0;
a82 2

  return ;
d86 5
a90 5
					const double xi[], const double xj[], 
					double f[], double& energy,
					const int& ientry) const
{
  double delr_norm,delr2,delr_2,delr_6,virial;
d99 1
a99 1
    virial = (param_list[ientry].params[0]*delr_6 
d101 17
a117 8
    energy = (param_list[ientry].params[2]*delr_6 
	      - param_list[ientry].params[3])*delr_6
              - param_list[ientry].params[5];
    
    f[0] = virial*delr[0]*delr_2;
    f[1] = virial*delr[1]*delr_2;
    f[2] = virial*delr[2]*delr_2;
    
d119 8
a126 2
    virial = 0.0;
    energy = 0.0;
a130 1
  return ;
d134 4
a137 4
					const Particle& pi, const Particle& pj, 
					double f[], double& energy,
					const int& ientry, const Box* b) const
{
d145 1
a145 1
  force_lj_cut(xi,xj,f,energy,ientry);
d150 4
a153 4
					      const Particle& pi, const Particle& pj, 
					      double f[], double& energy,
					      const int& ientry, const Box* b) const
{
d161 1
a161 1
  force_lj_cut_shift(xi,xj,f,energy,ientry);
d165 4
a168 4
					  const Particle& pi, const Particle& pj, 
					  double f[], double& energy,
					  const int& ientry, const Box* b) const
{
d170 1
a170 1
  double delr_norm,delr2,delr_2,delr_6,virial;
d180 19
a198 10
  virial = (param_list[ientry].params[0]*delr_6 
			   - param_list[ientry].params[1])*delr_6;
  energy = (param_list[ientry].params[2]*delr_6 
			   - param_list[ientry].params[3])*delr_6;

  f[0] = virial*delr[0]*delr_2;
  f[1] = virial*delr[1]*delr_2;
  f[2] = virial*delr[2]*delr_2;
    
  return ;
d202 4
a205 4
					    const Particle& pi, const Particle& pj, 
					    double f[], double& energy,
					    const int& ientry, const Box* b) const
{
d207 1
a207 1
  double delr_norm,delr2,delr_2,delr_6,virial,expr;
d218 1
a218 1
  virial = param_list[ientry].params[0]*delr_norm*expr   
d220 16
a235 8
  f[0] = virial*delr[0]*delr_2;
  f[1] = virial*delr[1]*delr_2;
  f[2] = virial*delr[2]*delr_2;
  energy = param_list[ientry].params[4]*expr
    - param_list[ientry].params[5]*delr_6;

  return;

d239 4
a242 4
						   const Particle& pi, const Particle& pj, 
						   double f[], double& energy,
						   const int& ientry, const Box* b) const
{
d244 1
a244 1
  double delr2,delr_2,delr_6,virial,expr;
d254 1
a254 1
  virial = param_list[ientry].params[0]*delr2*expr   
d256 16
a271 8
  f[0] = virial*delr[0]*delr_2;
  f[1] = virial*delr[1]*delr_2;
  f[2] = virial*delr[2]*delr_2;
  energy = param_list[ientry].params[4]*expr
    - param_list[ientry].params[5]*delr_6;

  return;

d275 4
a278 4
					      const Particle& pi, const Particle& pj, 
					      double f[], double& energy,
					      const int& ientry) const
{
d280 1
a280 1
  double delr_norm,delr2,delr_2,delr_6,virial;
d294 1
a294 1
    virial = (param_list[ientry].params[0]*delr_6 
d296 16
a311 6
    energy = (param_list[ientry].params[2]*delr_6 
	      - param_list[ientry].params[3])*delr_6;
    
    f[0] = virial*delr[0]*delr_2;
    f[1] = virial*delr[1]*delr_2;
    f[2] = virial*delr[2]*delr_2;
d313 9
a321 2
    virial = 0.0;
    energy = 0.0;
a325 2
    
  return ;
d329 4
a332 5
						    const Particle& pi, const Particle& pj, 
						    double f[], double& energy,
						    const int& ientry) const

{
d334 1
a334 1
  double delr_norm,delr2,delr_2,delr_6,virial;
d348 1
a348 1
    virial = (param_list[ientry].params[0]*delr_6 
d350 17
a366 8
    energy = (param_list[ientry].params[2]*delr_6 
	      - param_list[ientry].params[3])*delr_6
              - param_list[ientry].params[5];
    
    f[0] = virial*delr[0]*delr_2;
    f[1] = virial*delr[1]*delr_2;
    f[2] = virial*delr[2]*delr_2;
    
d368 8
a375 2
    virial = 0.0;
    energy = 0.0;
a379 1
  return ;
d383 4
a386 4
					      const Particle& pi, const Particle& pj, 
					      double f[], double& energy,
					      const int& ientry) const
{
d388 1
a388 1
  double delr_norm,delr2,delr_2,delr_6,virial;
d396 1
d399 19
a417 9
  virial = (param_list[ientry].params[0]*delr_6 
	   - param_list[ientry].params[1])*delr_6;
  f[0] = virial*delr[0]*delr_2;
  f[1] = virial*delr[1]*delr_2;
  f[2] = virial*delr[2]*delr_2;
  energy = (param_list[ientry].params[2]*delr_6 
	    - param_list[ientry].params[3])*delr_6;
    
  return ;
d421 4
a424 4
						  const Particle& pi, const Particle& pj, 
						  double f[], double& energy,
						  const int& ientry) const
{
d426 1
a426 1
  double delr_norm,delr2,delr_2,delr_6,virial,expr;
d439 1
a439 1
  virial = param_list[ientry].params[0]*delr_norm*expr   
d441 16
a456 8
  f[0] = virial*delr[0]*delr_2;
  f[1] = virial*delr[1]*delr_2;
  f[2] = virial*delr[2]*delr_2;
  energy = param_list[ientry].params[4]*expr
    - param_list[ientry].params[5]*delr_6;

  return;

d460 4
a463 4
					      const Particle& pi, const Particle& pj, 
					      double f[], double& energy,
					      const int& ientry) const
{
d465 1
a465 1
  double delr2,delr_2,delr_6,virial,expr;
d477 1
a477 1
  virial = param_list[ientry].params[0]*delr2*expr   
d479 16
a494 8
  f[0] = virial*delr[0]*delr_2;
  f[1] = virial*delr[1]*delr_2;
  f[2] = virial*delr[2]*delr_2;
  energy = param_list[ientry].params[4]*expr
    - param_list[ientry].params[5]*delr_6;

  return;

d498 5
a502 5
			   const double xi[], const double xj[], 
			   double f[], double& energy_lj, double& energy_coul,
			   const int& ientry,
			   const double& qi, const double& qj) const
{
d504 1
a504 1
  double virial_lj,virial_coul;
a515 2
    energy_lj = (param_list[ientry].params[2]*delr_6 
	      - param_list[ientry].params[3])*delr_6;
d518 10
a527 1
      virial_coul = qiqjr;
a528 3
    } else {
      virial_coul = 0.0;
      energy_coul = 0.0;
d530 8
a537 3
    f[0] = (virial_lj+virial_coul)*delr[0]*delr_2;
    f[1] = (virial_lj+virial_coul)*delr[1]*delr_2;
    f[2] = (virial_lj+virial_coul)*delr[2]*delr_2;
a538 4
    virial_lj = 0.0;
    virial_coul = 0.0;
    energy_lj = 0.0;
    energy_coul = 0.0;
d542 9
a551 1

d556 5
a560 5
			   const double xi[], const double xj[], 
			   double f[], double& energy_lj, double& energy_coul,
			   const int& ientry,
			   const double& qi, const double& qj) const
{
d562 1
a562 1
  double virial_lj,virial_coul;
a573 3
    energy_lj = (param_list[ientry].params[2]*delr_6 
	      - param_list[ientry].params[3])*delr_6
              - param_list[ientry].params[5];
d575 12
a586 2
      qiqjr =  param_list[ientry].params[6]*qi*qj*sqrt(delr_2);
      virial_coul = qiqjr;
a587 3
    } else {
      virial_coul = 0.0;
      energy_coul = 0.0;
d589 8
a596 3
    f[0] = (virial_lj+virial_coul)*delr[0]*delr_2;
    f[1] = (virial_lj+virial_coul)*delr[1]*delr_2;
    f[2] = (virial_lj+virial_coul)*delr[2]*delr_2;
a597 4
    virial_lj = 0.0;
    virial_coul = 0.0;
    energy_lj = 0.0;
    energy_coul = 0.0;
d601 9
a610 1

d615 5
a619 4
			   const double xi[], const double xj[], 
			   double f[], double& energy_lj, double& energy_coul,
			   const int& ientry,
			   const double& qi, const double& qj) const {
d621 1
a621 1
  double virial_lj,virial_coul;
a640 2
    energy_lj = (param_list[ientry].params[2]*delr_6 
	      - param_list[ientry].params[3])*delr_6;
a648 1
      energy_coul = qiqjr*erfc;
d650 2
a652 1
      energy_coul = 0.0;
d654 17
a670 3
    f[0] = (virial_lj+virial_coul)*delr[0]*delr_2;
    f[1] = (virial_lj+virial_coul)*delr[1]*delr_2;
    f[2] = (virial_lj+virial_coul)*delr[2]*delr_2;
a671 4
    virial_lj = 0.0;
    virial_coul = 0.0;
    energy_lj = 0.0;
    energy_coul = 0.0;
d675 9
d690 5
a694 4
			   const double xi[], const double xj[], 
			   double f[], double& energy_lj, double& energy_coul,
			   const int& ientry,
			   const double& qi, const double& qj) const {
d696 1
a696 1
  double virial_lj,virial_coul;
d707 1
a715 3
    energy_lj = (param_list[ientry].params[2]*delr_6 
	      - param_list[ientry].params[3])*delr_6
              - param_list[ientry].params[5];
d718 1
a718 1
      grij = param_list[ientry].params[7] * r;
d722 1
a722 1
      qiqjr =  param_list[ientry].params[6]*qi*qj/r;
a723 1
      energy_coul = qiqjr*erfc;
d725 2
a727 1
      energy_coul = 0.0;
d729 18
a746 3
    f[0] = (virial_lj+virial_coul)*delr[0]*delr_2;
    f[1] = (virial_lj+virial_coul)*delr[1]*delr_2;
    f[2] = (virial_lj+virial_coul)*delr[2]*delr_2;
a747 4
    virial_lj = 0.0;
    virial_coul = 0.0;
    energy_lj = 0.0;
    energy_coul = 0.0;
d751 9
@


2.5
log
@Various
@
text
@d38 1
a38 1
					const double xi[], const double xj[], 
d51 1
a51 1
    virial = (param_list[ientry].params[0]*delr_6 
d53 1
a53 1
    energy = (param_list[ientry].params[2]*delr_6 
@


2.4
log
@Updated documentation
@
text
@d13 1
a13 1
//    Timestamp: 8 January 2004
@


2.3
log
@Added Ewald sum example
@
text
@d483 1
a483 3
			   const double& qi, const double& qj,
			   const double& g_ewald) const
{
d509 1
a509 1
      grij = g_ewald * r;
d540 1
a540 3
			   const double& qi, const double& qj,
			   const double& g_ewald) const
{
d566 1
a566 1
      grij = g_ewald * r;
@


2.2
log
@The primary change is the addition of the embedded atom method (EAM)
This is contained in the class Force_Eam. An example is contained
in the directory Testing/testl.

I also tweaked various parts of the code:
-Added epsilon shift to unit cell origin to avoid
pathologies associated with origin at zero
-Changed ndof from 3n to 3n-3
-Implemented localptr usertag arrays in class ParticleList
This enables user to pick whatever integer tags they want for
atoms, but the code generates internal tags 0,1,....nparticles_tot-1.
-Random velocities are now generated for all nparticles_tot particles,
but only assigned to local particles, so that velocity assignments
are independent of number of processors used.
-I got rid of the dreaded COSP neighboring scheme
-I added an example of Nose-Hoover thermostat in testm
-I added a warning for when force field type has no particle type match.
@
text
@d388 209
@


2.2.2.1
log
@Committing merge of main trunk onto branch cjkimme_version.
@
text
@d13 1
a13 1
//    Timestamp: July 26, 2004
d38 5
a42 5
	    const double xi[], const double xj[],
	    double f[], const bool& Lenergy, const bool& Lvirial, 
	    double& energy, double virial[],
	    const int& ientry) const {
  double delr_norm,delr2,delr_2,delr_6,virial_tmp;
a44 1
  // delr is -r_ij = r_ji
d51 1
a51 2
    // virial_tmp is (-1/r)dphi/dr
    virial_tmp = (param_list[ientry].params[0]*delr_6
d53 6
a58 17
    virial_tmp*=delr_2;
    // f_i = -grad_i phi(r_ij) = -dphi/dr grad_i r_ij = virial_tmp r_ji
    f[0] = virial_tmp*delr[0];
    f[1] = virial_tmp*delr[1];
    f[2] = virial_tmp*delr[2];
    if (Lenergy) {
      energy = (param_list[ientry].params[2]*delr_6
		- param_list[ientry].params[3])*delr_6;
    }
    if (Lvirial) {
      virial[0] = virial_tmp*delr[0]*delr[0];
      virial[1] = virial_tmp*delr[1]*delr[1];
      virial[2] = virial_tmp*delr[2]*delr[2];
      virial[3] = virial_tmp*delr[0]*delr[1];
      virial[4] = virial_tmp*delr[0]*delr[2];
      virial[5] = virial_tmp*delr[1]*delr[2];
    }
d60 2
a61 9
    if (Lenergy) {
      energy = 0.0;
    }
    if (Lvirial) {
      for (int ivirial=0;ivirial<nvirial;ivirial++) {
	virial[ivirial] = 0.0;
      }
    }

d66 2
d71 5
a75 5
            const double xi[], const double xj[], 
	    double f[], const bool& Lenergy, const bool& Lvirial, 
	    double& energy, double virial[],
	    const int& ientry) const {
  double delr_norm,delr2,delr_2,delr_6,virial_tmp;
d84 1
a84 1
    virial_tmp = (param_list[ientry].params[0]*delr_6 
d86 8
a93 17
    virial_tmp*=delr_2;
    f[0] = virial_tmp*delr[0];
    f[1] = virial_tmp*delr[1];
    f[2] = virial_tmp*delr[2];
    if (Lenergy) {
      energy = (param_list[ientry].params[2]*delr_6
		- param_list[ientry].params[3])*delr_6
	        - param_list[ientry].params[5];
    }
    if (Lvirial) {
      virial[0] = virial_tmp*delr[0]*delr[0];
      virial[1] = virial_tmp*delr[1]*delr[1];
      virial[2] = virial_tmp*delr[2]*delr[2];
      virial[3] = virial_tmp*delr[0]*delr[1];
      virial[4] = virial_tmp*delr[0]*delr[2];
      virial[5] = virial_tmp*delr[1]*delr[2];
    }
d95 2
a96 8
    if (Lenergy) {
      energy = 0.0;
    }
    if (Lvirial) {
      for (int ivirial=0;ivirial<nvirial;ivirial++) {
	virial[ivirial] = 0.0;
      }
    }
d101 1
d105 4
a108 4
            const Particle& pi, const Particle& pj, 
	    double f[], const bool& Lenergy, const bool& Lvirial, 
	    double& energy, double virial[],
	    const int& ientry, const Box* b) const {
d116 1
a116 1
  force_lj_cut(xi,xj,f,Lenergy,Lvirial,energy,virial,ientry);
d121 4
a124 4
            const Particle& pi, const Particle& pj, 
	    double f[], const bool& Lenergy, const bool& Lvirial, 
	    double& energy, double virial[],
	    const int& ientry, const Box* b) const {
d132 1
a132 1
  force_lj_cut_shift(xi,xj,f,Lenergy,Lvirial,energy,virial,ientry);
d136 4
a139 4
            const Particle& pi, const Particle& pj, 
	    double f[], const bool& Lenergy, const bool& Lvirial, 
	    double& energy, double virial[],
	    const int& ientry, const Box* b) const {
d141 1
a141 1
  double delr_norm,delr2,delr_2,delr_6,virial_tmp;
d151 10
a160 19

  virial_tmp = (param_list[ientry].params[0]*delr_6 
		- param_list[ientry].params[1])*delr_6;
  virial_tmp*=delr_2;
  f[0] = virial_tmp*delr[0];
  f[1] = virial_tmp*delr[1];
  f[2] = virial_tmp*delr[2];
  if (Lenergy) {
    energy = (param_list[ientry].params[2]*delr_6
	      - param_list[ientry].params[3])*delr_6;
  }
  if (Lvirial) {
    virial[0] = virial_tmp*delr[0]*delr[0];
    virial[1] = virial_tmp*delr[1]*delr[1];
    virial[2] = virial_tmp*delr[2]*delr[2];
    virial[3] = virial_tmp*delr[0]*delr[1];
    virial[4] = virial_tmp*delr[0]*delr[2];
    virial[5] = virial_tmp*delr[1]*delr[2];
  }
d164 4
a167 4
            const Particle& pi, const Particle& pj, 
	    double f[], const bool& Lenergy, const bool& Lvirial, 
	    double& energy, double virial[],
	    const int& ientry, const Box* b) const {
d169 1
a169 1
  double delr_norm,delr2,delr_2,delr_6,virial_tmp,expr;
d180 1
a180 1
  virial_tmp = param_list[ientry].params[0]*delr_norm*expr   
d182 8
a189 16
  virial_tmp*=delr_2;
  f[0] = virial_tmp*delr[0];
  f[1] = virial_tmp*delr[1];
  f[2] = virial_tmp*delr[2];
  if (Lenergy) {
    energy = param_list[ientry].params[4]*expr
      - param_list[ientry].params[5]*delr_6;
  }
  if (Lvirial) {
    virial[0] = virial_tmp*delr[0]*delr[0];
    virial[1] = virial_tmp*delr[1]*delr[1];
    virial[2] = virial_tmp*delr[2]*delr[2];
    virial[3] = virial_tmp*delr[0]*delr[1];
    virial[4] = virial_tmp*delr[0]*delr[2];
    virial[5] = virial_tmp*delr[1]*delr[2];
  }
d193 4
a196 4
	    const Particle& pi, const Particle& pj, 
	    double f[], const bool& Lenergy, const bool& Lvirial, 
	    double& energy, double virial[],
	    const int& ientry, const Box* b) const {
d198 1
a198 1
  double delr2,delr_2,delr_6,virial_tmp,expr;
d208 1
a208 1
  virial_tmp = param_list[ientry].params[0]*delr2*expr   
d210 8
a217 16
  virial_tmp*=delr_2;
  f[0] = virial_tmp*delr[0];
  f[1] = virial_tmp*delr[1];
  f[2] = virial_tmp*delr[2];
  if (Lenergy) {
    energy = param_list[ientry].params[4]*expr
      - param_list[ientry].params[5]*delr_6;
  }
  if (Lvirial) {
    virial[0] = virial_tmp*delr[0]*delr[0];
    virial[1] = virial_tmp*delr[1]*delr[1];
    virial[2] = virial_tmp*delr[2]*delr[2];
    virial[3] = virial_tmp*delr[0]*delr[1];
    virial[4] = virial_tmp*delr[0]*delr[2];
    virial[5] = virial_tmp*delr[1]*delr[2];
  }
d221 4
a224 4
	    const Particle& pi, const Particle& pj, 
	    double f[], const bool& Lenergy, const bool& Lvirial, 
	    double& energy, double virial[],
	    const int& ientry) const {
d226 1
a226 1
  double delr_norm,delr2,delr_2,delr_6,virial_tmp;
d240 1
a240 1
    virial_tmp = (param_list[ientry].params[0]*delr_6
d242 6
a247 16
    virial_tmp*=delr_2;
    f[0] = virial_tmp*delr[0];
    f[1] = virial_tmp*delr[1];
    f[2] = virial_tmp*delr[2];
    if (Lenergy) {
      energy = (param_list[ientry].params[2]*delr_6
		- param_list[ientry].params[3])*delr_6;
    }
    if (Lvirial) {
      virial[0] = virial_tmp*delr[0]*delr[0];
      virial[1] = virial_tmp*delr[1]*delr[1];
      virial[2] = virial_tmp*delr[2]*delr[2];
      virial[3] = virial_tmp*delr[0]*delr[1];
      virial[4] = virial_tmp*delr[0]*delr[2];
      virial[5] = virial_tmp*delr[1]*delr[2];
    }
d249 2
a250 9
    if (Lenergy) {
      energy = 0.0;
    }
    if (Lvirial) {
      for (int ivirial=0;ivirial<nvirial;ivirial++) {
	virial[ivirial] = 0.0;
      }
    }

d255 2
d260 5
a264 4
	    const Particle& pi, const Particle& pj, 
	    double f[], const bool& Lenergy, const bool& Lvirial, 
	    double& energy, double virial[],
	    const int& ientry) const {
d266 1
a266 1
  double delr_norm,delr2,delr_2,delr_6,virial_tmp;
d280 1
a280 1
    virial_tmp = (param_list[ientry].params[0]*delr_6 
d282 8
a289 17
    virial_tmp*=delr_2;
    f[0] = virial_tmp*delr[0];
    f[1] = virial_tmp*delr[1];
    f[2] = virial_tmp*delr[2];
    if (Lenergy) {
      energy = (param_list[ientry].params[2]*delr_6
		- param_list[ientry].params[3])*delr_6
	        - param_list[ientry].params[5];
    }
    if (Lvirial) {
      virial[0] = virial_tmp*delr[0]*delr[0];
      virial[1] = virial_tmp*delr[1]*delr[1];
      virial[2] = virial_tmp*delr[2]*delr[2];
      virial[3] = virial_tmp*delr[0]*delr[1];
      virial[4] = virial_tmp*delr[0]*delr[2];
      virial[5] = virial_tmp*delr[1]*delr[2];
    }
d291 2
a292 8
    if (Lenergy) {
      energy = 0.0;
    }
    if (Lvirial) {
      for (int ivirial=0;ivirial<nvirial;ivirial++) {
	virial[ivirial] = 0.0;
      }
    }
d297 1
d301 4
a304 4
            const Particle& pi, const Particle& pj, 
	    double f[], const bool& Lenergy, const bool& Lvirial, 
	    double& energy, double virial[],
	    const int& ientry) const {
d306 1
a306 1
  double delr_norm,delr2,delr_2,delr_6,virial_tmp;
a313 1

d316 9
a324 19

  virial_tmp = (param_list[ientry].params[0]*delr_6 
		- param_list[ientry].params[1])*delr_6;
  virial_tmp*=delr_2;
  f[0] = virial_tmp*delr[0];
  f[1] = virial_tmp*delr[1];
  f[2] = virial_tmp*delr[2];
  if (Lenergy) {
    energy = (param_list[ientry].params[2]*delr_6
	      - param_list[ientry].params[3])*delr_6;
  }
  if (Lvirial) {
    virial[0] = virial_tmp*delr[0]*delr[0];
    virial[1] = virial_tmp*delr[1]*delr[1];
    virial[2] = virial_tmp*delr[2]*delr[2];
    virial[3] = virial_tmp*delr[0]*delr[1];
    virial[4] = virial_tmp*delr[0]*delr[2];
    virial[5] = virial_tmp*delr[1]*delr[2];
  }
d328 4
a331 4
            const Particle& pi, const Particle& pj, 
	    double f[], const bool& Lenergy, const bool& Lvirial, 
	    double& energy, double virial[],
	    const int& ientry) const {
d333 1
a333 1
  double delr_norm,delr2,delr_2,delr_6,virial_tmp,expr;
d346 1
a346 1
  virial_tmp = param_list[ientry].params[0]*delr_norm*expr   
d348 8
a355 16
  virial_tmp*=delr_2;
  f[0] = virial_tmp*delr[0];
  f[1] = virial_tmp*delr[1];
  f[2] = virial_tmp*delr[2];
  if (Lenergy) {
    energy = param_list[ientry].params[4]*expr
      - param_list[ientry].params[5]*delr_6;
  }
  if (Lvirial) {
    virial[0] = virial_tmp*delr[0]*delr[0];
    virial[1] = virial_tmp*delr[1]*delr[1];
    virial[2] = virial_tmp*delr[2]*delr[2];
    virial[3] = virial_tmp*delr[0]*delr[1];
    virial[4] = virial_tmp*delr[0]*delr[2];
    virial[5] = virial_tmp*delr[1]*delr[2];
  }
d359 4
a362 4
	    const Particle& pi, const Particle& pj, 
	    double f[], const bool& Lenergy, const bool& Lvirial, 
	    double& energy, double virial[],
	    const int& ientry) const {
d364 1
a364 1
  double delr2,delr_2,delr_6,virial_tmp,expr;
d376 1
a376 1
  virial_tmp = param_list[ientry].params[0]*delr2*expr   
d378 5
a382 228
  virial_tmp*=delr_2;
  f[0] = virial_tmp*delr[0];
  f[1] = virial_tmp*delr[1];
  f[2] = virial_tmp*delr[2];
  if (Lenergy) {
    energy = param_list[ientry].params[4]*expr
      - param_list[ientry].params[5]*delr_6;
  }
  if (Lvirial) {
    virial[0] = virial_tmp*delr[0]*delr[0];
    virial[1] = virial_tmp*delr[1]*delr[1];
    virial[2] = virial_tmp*delr[2]*delr[2];
    virial[3] = virial_tmp*delr[0]*delr[1];
    virial[4] = virial_tmp*delr[0]*delr[2];
    virial[5] = virial_tmp*delr[1]*delr[2];
  }
}

inline void Force_Twobody::force_lj_cut_coul(
	    const double xi[], const double xj[], 
	    double f[], const bool& Lenergy, const bool& Lvirial, 
	    double& energy_lj, double& energy_coul, double virial[],
	    const int& ientry,
	    const double& qi, const double& qj) const {
  double delr_norm,delr2,delr_2,delr_6;
  double virial_lj,virial_tmp;
  double qiqjr;
  double delr[3];

  delr2 = vec3_distsq(xi,xj,delr);

  if (delr2 <= param_list[ientry].params[4]) {
    
    delr_2 = 1.0/delr2;
    delr_6 = delr_2*delr_2*delr_2;
    virial_lj = (param_list[ientry].params[0]*delr_6 
	      - param_list[ientry].params[1])*delr_6;
    if (qi != 0.0 && qj != 0.0) {
      qiqjr =  param_list[ientry].params[5]*qi*qj*sqrt(delr_2);
    } else {
      qiqjr = 0.0;
    }
    virial_tmp = (virial_lj+qiqjr)*delr_2;
    f[0] = virial_tmp*delr[0];
    f[1] = virial_tmp*delr[1];
    f[2] = virial_tmp*delr[2];
    if (Lenergy) {
      energy_lj = (param_list[ientry].params[2]*delr_6 
		   - param_list[ientry].params[3])*delr_6;
      energy_coul = qiqjr;
    }
    if (Lvirial) {
      virial[0] = virial_tmp*delr[0]*delr[0];
      virial[1] = virial_tmp*delr[1]*delr[1];
      virial[2] = virial_tmp*delr[2]*delr[2];
      virial[3] = virial_tmp*delr[0]*delr[1];
      virial[4] = virial_tmp*delr[0]*delr[2];
      virial[5] = virial_tmp*delr[1]*delr[2];
    }
  }  else {
    f[0] = 0.0;
    f[1] = 0.0;
    f[2] = 0.0;
    if (Lenergy) {
      energy_lj = 0.0;
      energy_coul = 0.0;
    }
    if (Lvirial) {
      for (int ivirial=0;ivirial<nvirial;ivirial++) {
	virial[ivirial] = 0.0;
      }
    }
  }
  return ;
}

inline void Force_Twobody::force_lj_cut_shift_coul(
	    const double xi[], const double xj[], 
	    double f[], const bool& Lenergy, const bool& Lvirial, 
	    double& energy_lj, double& energy_coul, double virial[],
	    const int& ientry,
	    const double& qi, const double& qj) const {
  double delr_norm,delr2,delr_2,delr_6;
  double virial_lj,virial_tmp;
  double qiqjr;
  double delr[3];

  delr2 = vec3_distsq(xi,xj,delr);

  if (delr2 <= param_list[ientry].params[4]) {
    
    delr_2 = 1.0/delr2;
    delr_6 = delr_2*delr_2*delr_2;
    virial_lj = (param_list[ientry].params[0]*delr_6 
	      - param_list[ientry].params[1])*delr_6;
    if (qi != 0.0 && qj != 0.0) {
      qiqjr =  param_list[ientry].params[5]*qi*qj*sqrt(delr_2);
    } else {
      qiqjr = 0.0;
    }
    virial_tmp = (virial_lj+qiqjr)*delr_2;
    f[0] = virial_tmp*delr[0];
    f[1] = virial_tmp*delr[1];
    f[2] = virial_tmp*delr[2];
    if (Lenergy) {
      energy_lj = (param_list[ientry].params[2]*delr_6 
		   - param_list[ientry].params[3])*delr_6
	           - param_list[ientry].params[6];
      energy_coul = qiqjr;
    }
    if (Lvirial) {
      virial[0] = virial_tmp*delr[0]*delr[0];
      virial[1] = virial_tmp*delr[1]*delr[1];
      virial[2] = virial_tmp*delr[2]*delr[2];
      virial[3] = virial_tmp*delr[0]*delr[1];
      virial[4] = virial_tmp*delr[0]*delr[2];
      virial[5] = virial_tmp*delr[1]*delr[2];
    }
  }  else {
    f[0] = 0.0;
    f[1] = 0.0;
    f[2] = 0.0;
    if (Lenergy) {
      energy_lj = 0.0;
      energy_coul = 0.0;
    }
    if (Lvirial) {
      for (int ivirial=0;ivirial<nvirial;ivirial++) {
	virial[ivirial] = 0.0;
      }
    }
  }
  return ;
}

// This is a little risky, since if for any reason,
// this file is include in more than one file,
// the compiler will baulk. Should really put these
// initializations directly in force_twobody.cpp, or in a separate
// include used only by force_twobody.cpp
const double Force_Twobody::EWALD_F = 1.12837917;
const double Force_Twobody::EWALD_P = 0.3275911;
const double Force_Twobody::EWALD_A1 = 0.254829592;
const double Force_Twobody::EWALD_A2 = -0.284496736;
const double Force_Twobody::EWALD_A3 = 1.421413741;
const double Force_Twobody::EWALD_A4 = -1.453152027;
const double Force_Twobody::EWALD_A5 = 1.061405429;

inline void Force_Twobody::force_lj_cut_ewald(
	    const double xi[], const double xj[], 
	    double f[], const bool& Lenergy, const bool& Lvirial, 
	    double& energy_lj, double& energy_coul, double virial[],
	    const int& ientry,
	    const double& qi, const double& qj) const {
  double delr_norm,delr2,delr_2,delr_6;
  double virial_lj,virial_coul,virial_tmp;
  double qiqjr,t,grij,r,expm2,erfc;
  double delr[3];

  delr2 = vec3_distsq(xi,xj,delr);

  if (delr2 <= param_list[ientry].params[4]) {
    
    delr_2 = 1.0/delr2;
    delr_6 = delr_2*delr_2*delr_2;
    virial_lj = (param_list[ientry].params[0]*delr_6 
	      - param_list[ientry].params[1])*delr_6;
    if (qi != 0.0 && qj != 0.0) {
      r = sqrt(delr2);
      grij = param_list[ientry].params[6] * r;
      expm2 = exp(-grij*grij);
      t = 1.0 / (1.0 + EWALD_P*grij);
      erfc = t * (EWALD_A1+t*(EWALD_A2+
	     t*(EWALD_A3+t*(EWALD_A4+t*EWALD_A5)))) * expm2;
      qiqjr =  param_list[ientry].params[5]*qi*qj/r;
      virial_coul = qiqjr*(erfc + EWALD_F*grij*expm2);
    } else {
      qiqjr = 0.0;
      erfc = 0.0;
      virial_coul = 0.0;
    }
    virial_tmp = (virial_lj+virial_coul)*delr_2;
    f[0] = virial_tmp*delr[0];
    f[1] = virial_tmp*delr[1];
    f[2] = virial_tmp*delr[2];
    if (Lenergy) {
      energy_lj = (param_list[ientry].params[2]*delr_6 
		   - param_list[ientry].params[3])*delr_6;
      energy_coul = qiqjr*erfc;
    }
    if (Lvirial) {
      virial[0] = virial_tmp*delr[0]*delr[0];
      virial[1] = virial_tmp*delr[1]*delr[1];
      virial[2] = virial_tmp*delr[2]*delr[2];
      virial[3] = virial_tmp*delr[0]*delr[1];
      virial[4] = virial_tmp*delr[0]*delr[2];
      virial[5] = virial_tmp*delr[1]*delr[2];
    }
  }  else {
    f[0] = 0.0;
    f[1] = 0.0;
    f[2] = 0.0;
    if (Lenergy) {
      energy_lj = 0.0;
      energy_coul = 0.0;
    }
    if (Lvirial) {
      for (int ivirial=0;ivirial<nvirial;ivirial++) {
	virial[ivirial] = 0.0;
      }
    }
  }

  return ;
}

inline void Force_Twobody::force_lj_cut_shift_ewald(
	    const double xi[], const double xj[], 
	    double f[], const bool& Lenergy, const bool& Lvirial, 
	    double& energy_lj, double& energy_coul, double virial[],
	    const int& ientry,
	    const double& qi, const double& qj) const {
  double delr_norm,delr2,delr_2,delr_6;
  double virial_lj,virial_coul,virial_tmp;
  double qiqjr,t,grij,r,expm2,erfc;
  double delr[3];

  delr2 = vec3_distsq(xi,xj,delr);
d384 1
a384 52
  if (delr2 <= param_list[ientry].params[4]) {
    
    delr_2 = 1.0/delr2;
    delr_6 = delr_2*delr_2*delr_2;
    virial_lj = (param_list[ientry].params[0]*delr_6 
	      - param_list[ientry].params[1])*delr_6;
    if (qi != 0.0 && qj != 0.0) {
      r = sqrt(delr2);
      grij = param_list[ientry].params[6] * r;
      expm2 = exp(-grij*grij);
      t = 1.0 / (1.0 + EWALD_P*grij);
      erfc = t * (EWALD_A1+t*(EWALD_A2+
	     t * (EWALD_A3+t*(EWALD_A4+t*EWALD_A5)))) * expm2;
      qiqjr =  param_list[ientry].params[5]*qi*qj/r;
      virial_coul = qiqjr*(erfc + EWALD_F*grij*expm2);
    } else {
      qiqjr = 0.0;
      erfc = 0.0;
      virial_coul = 0.0;
    }
    virial_tmp = (virial_lj+virial_coul)*delr_2;
    f[0] = virial_tmp*delr[0];
    f[1] = virial_tmp*delr[1];
    f[2] = virial_tmp*delr[2];
    if (Lenergy) {
      energy_lj = (param_list[ientry].params[2]*delr_6 
		   - param_list[ientry].params[3])*delr_6
                   - param_list[ientry].params[7];
      energy_coul = qiqjr*erfc;
    }
    if (Lvirial) {
      virial[0] = virial_tmp*delr[0]*delr[0];
      virial[1] = virial_tmp*delr[1]*delr[1];
      virial[2] = virial_tmp*delr[2]*delr[2];
      virial[3] = virial_tmp*delr[0]*delr[1];
      virial[4] = virial_tmp*delr[0]*delr[2];
      virial[5] = virial_tmp*delr[1]*delr[2];
    }
  }  else {
    f[0] = 0.0;
    f[1] = 0.0;
    f[2] = 0.0;
    if (Lenergy) {
      energy_lj = 0.0;
      energy_coul = 0.0;
    }
    if (Lvirial) {
      for (int ivirial=0;ivirial<nvirial;ivirial++) {
	virial[ivirial] = 0.0;
      }
    }
  }
a385 1
  return ;
@


2.1
log
@Added a Perl script to Header.pl to prepend a header contained in
header.txt to source fiels, using

Header.pl *.pl *.cpp *.h M*[^~]
@
text
@d107 1
a107 1
					const int& ientry, const Box& b) const
d114 1
a114 1
  b.Minimg_Diff_Shift(xi,xj);
d123 1
a123 1
					      const int& ientry, const Box& b) const
d130 1
a130 1
  b.Minimg_Diff_Shift(xi,xj);
d138 1
a138 1
					  const int& ientry, const Box& b) const
d146 1
a146 1
  b.Minimg_Diff(xi,xj,delr);
d166 1
a166 1
					    const int& ientry, const Box& b) const
d173 1
a173 1
  b.Minimg_Diff(xi,xj,delr);
d195 1
a195 1
						   const int& ientry, const Box& b) const
d202 1
a202 1
  b.Minimg_Diff(xi,xj,delr);
@


2.0
log
@*** empty log message ***
@
text
@d1 28
@


1.5
log
@Added class Profile to measure different types of spatial profiles
Added class Input to handle input commands.
Added global functions input_string to parse input commands.
@
text
@@


1.4
log
@Created an abstract class Forcefield, with derived classes Force_Twobody
and Force_Threebody.
Implemented Stillinger-Weber forcefield within Force_Threebody.
Unfortunately, the COSP neighboring method does not work for
threebody forces, so we currently do not have neighbor lists
for threebody interactions.  Probably need to use LAMMPS-like
ghost atom method and standard neighbor list structures.
@
text
@d38 1
a38 1
    
d89 1
@


1.3
log
@

Added neighbor list object.
@
text
@d4 4
a7 15
#include <iostream>
#include <math.h>
#include "box_inline.h"

//   This is a set of inline function definitions for two-body forces.

inline int Force_Twobody::get_entry(const int& itype_in, 
				    const int& jtype_in) const {
  return param_index[itype_in][jtype_in];
}

inline Force_Twobody::ff_type Force_Twobody::get_type(
  const int& ientry_in) const {
  return param_list[ientry_in].type;
}
d81 1
a81 2
  double xi[3],xj[3],delr[3];
  double delr_norm,delr2,delr_2,delr_6,virial;
d86 1
a86 2
  b.Minimg_Diff(xi,xj,delr);
  delr2 = delr[0]*delr[0]+delr[1]*delr[1]+delr[2]*delr[2];
d88 1
a88 21
  if (delr2 <= param_list[ientry].params[4]) {
    
    delr_2 = 1.0/delr2;
    delr_6 = delr_2*delr_2*delr_2;
    virial = (param_list[ientry].params[0]*delr_6 
	      - param_list[ientry].params[1])*delr_6;
    energy = (param_list[ientry].params[2]*delr_6 
	      - param_list[ientry].params[3])*delr_6;
    
    f[0] = virial*delr[0]*delr_2;
    f[1] = virial*delr[1]*delr_2;
    f[2] = virial*delr[2]*delr_2;
  }  else {
    virial = 0.0;
    energy = 0.0;
    f[0] = 0.0;
    f[1] = 0.0;
    f[2] = 0.0;
  }
    
  return ;
d96 1
a96 2
  double xi[3],xj[3],delr[3];
  double delr_norm,delr2,delr_2,delr_6,virial;
d101 1
a101 2
  b.Minimg_Diff(xi,xj,delr);
  delr2 = delr[0]*delr[0]+delr[1]*delr[1]+delr[2]*delr[2];
d103 1
a103 22
  if (delr2 <= param_list[ientry].params[4]) {
    
    delr_2 = 1.0/delr2;
    delr_6 = delr_2*delr_2*delr_2;
    virial = (param_list[ientry].params[0]*delr_6 
	      - param_list[ientry].params[1])*delr_6;
    energy = (param_list[ientry].params[2]*delr_6 
	      - param_list[ientry].params[3])*delr_6
              - param_list[ientry].params[5];
    
    f[0] = virial*delr[0]*delr_2;
    f[1] = virial*delr[1]*delr_2;
    f[2] = virial*delr[2]*delr_2;
    
  }  else {
    virial = 0.0;
    energy = 0.0;
    f[0] = 0.0;
    f[1] = 0.0;
    f[2] = 0.0;
  }
  return ;
@


1.2
log
@
Added ReadParticleTypes, and improved organization of input,
including error checking.
@
text
@d20 146
a165 5
inline void Force_Twobody::force_lj_minimg(
			 const vector<Particle>::iterator iteri,
			 const vector<Particle>::iterator iterj, 
			 double f[], double& energy, const Box& b,
			 const int& ientry) const
d170 2
a171 5
  iteri->get_x(xi);
  iterj->get_x(xj);
  delr[0] = xi[0]-xj[0];
  delr[1] = xi[1]-xj[1];
  delr[2] = xi[2]-xj[2];
d190 4
a193 5
inline void Force_Twobody::force_exp6_minimg(
                              const vector<Particle>::iterator iteri,
			      const vector<Particle>::iterator iterj, 
			      double f[], double& energy, const Box& b,
			      const int& ientry) const
d198 2
a199 2
  iteri->get_x(xi);
  iterj->get_x(xj);
d219 4
a222 5
inline void Force_Twobody::force_square_exp6_minimg(
                              const vector<Particle>::iterator iteri,
			      const vector<Particle>::iterator iterj, 
			      double f[], double& energy, const Box& b,
			      const int& ientry) const
d227 2
a228 2
  iteri->get_x(xi);
  iterj->get_x(xj);
d247 84
a330 5
inline void Force_Twobody::force_lj_nopbc(
                              const vector<Particle>::iterator iteri,
			      const vector<Particle>::iterator iterj, 
			      double f[], double& energy, const Box& b,
			      const int& ientry) const
d335 2
a336 2
  iteri->get_x(xi);
  iterj->get_x(xj);
d354 4
a357 5
inline void Force_Twobody::force_exp6_nopbc(
                              const vector<Particle>::iterator iteri,
			      const vector<Particle>::iterator iterj, 
			      double f[], double& energy, const Box& b,
			      const int& ientry) const
d362 2
a363 2
  iteri->get_x(xi);
  iterj->get_x(xj);
d385 4
a388 5
inline void Force_Twobody::force_square_exp6_nopbc(
                              const vector<Particle>::iterator iteri,
			      const vector<Particle>::iterator iterj, 
			      double f[], double& energy, const Box& b,
			      const int& ientry) const
d393 2
a394 2
  iteri->get_x(xi);
  iterj->get_x(xj);
@


1.1
log
@Starting source distribution for Grasp.
Basic molecular dynamics code with twobody interactions
@
text
@d6 1
d21 4
a24 4
                              const vector<Particle>::iterator iteri,
			      const vector<Particle>::iterator iterj, 
			      double f[], double& energy, const Box& b,
			      const int& ientry) const
d31 4
d37 1
d41 4
a44 1
	   - param_list[ientry].params[1])*delr_6;
a47 2
  energy = (param_list[ientry].params[2]*delr_6 
	    - param_list[ientry].params[3])*delr_6;
@

