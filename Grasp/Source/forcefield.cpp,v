head	4.7;
access;
symbols
	ReverseComm_branch:4.5.0.4
	ADTools_branch:4.5.0.2
	Monaco_Aidan:4.3.0.4
	Root-of-Monaco_Aidan:4.3
	PPPM_Crozier2:4.4.0.2
	PPPM_Crozier:4.4
	Root-of-PPPM_Crozier:4.4
	Monaco:4.3.0.2
	PreMonaco:4.3
	Recovery-2004-04-12:4.0
	BRANCH:4.1.0.4
	PMONACO:4.1.0.2
	ROOT:4.1
	initial:4.0.0.2
	pmonaco:4.0
	Version_4_0:4.0
	Version_3_0:3.0
	BeforeREAXMerge:3.2
	REAX-2:3.0.2.1
	P_MonacoSource:3.0.0.6
	GraspSource:3.0
	P_Monaco:3.0.0.4
	InitialGrasp:3.0
	REAXFF:3.0.0.2
	premerge_cjkimme_version:3.0
	CRAY:2.19.0.2
	cjkimme_version_merge_from_trunk_1:2.7.2.1
	cjkimme_version:2.7.0.2;
locks; strict;
comment	@// @;


4.7
date	2007.09.05.22.43.34;	author athomps;	state Exp;
branches;
next	4.6;

4.6
date	2007.05.30.05.41.46;	author athomps;	state Exp;
branches;
next	4.5;

4.5
date	2006.01.25.21.40.12;	author athomps;	state Exp;
branches;
next	4.4;

4.4
date	2005.06.08.20.08.48;	author athomps;	state Exp;
branches
	4.4.2.1;
next	4.3;

4.3
date	2005.05.03.16.28.27;	author athomps;	state Exp;
branches
	4.3.4.1;
next	4.2;

4.2
date	2005.05.02.20.13.38;	author athomps;	state Exp;
branches;
next	4.1;

4.1
date	2005.04.12.22.26.04;	author saubry;	state Exp;
branches;
next	4.0;

4.0
date	2005.04.05.16.43.30;	author athomps;	state Exp;
branches;
next	3.3;

3.3
date	2005.04.02.00.37.56;	author athomps;	state Exp;
branches;
next	3.2;

3.2
date	2005.03.24.21.14.20;	author athomps;	state Exp;
branches;
next	3.1;

3.1
date	2005.03.08.18.08.52;	author athomps;	state Exp;
branches;
next	3.0;

3.0
date	2004.09.22.17.56.49;	author athomps;	state Exp;
branches
	3.0.2.1
	3.0.6.1;
next	2.19;

2.19
date	2004.08.27.20.05.36;	author athomps;	state Exp;
branches;
next	2.18;

2.18
date	2004.08.24.15.32.11;	author athomps;	state Exp;
branches;
next	2.17;

2.17
date	2004.08.13.21.52.19;	author athomps;	state Exp;
branches;
next	2.16;

2.16
date	2004.08.02.18.00.47;	author athomps;	state Exp;
branches;
next	2.15;

2.15
date	2004.07.30.20.18.47;	author athomps;	state Exp;
branches;
next	2.14;

2.14
date	2004.07.26.15.52.18;	author athomps;	state Exp;
branches;
next	2.13;

2.13
date	2004.07.22.23.15.01;	author athomps;	state Exp;
branches;
next	2.12;

2.12
date	2004.07.21.17.46.50;	author athomps;	state Exp;
branches;
next	2.11;

2.11
date	2004.07.19.17.05.38;	author athomps;	state Exp;
branches;
next	2.10;

2.10
date	2004.05.20.22.11.33;	author athomps;	state Exp;
branches;
next	2.9;

2.9
date	2004.03.20.00.15.38;	author athomps;	state Exp;
branches;
next	2.8;

2.8
date	2004.03.01.18.13.34;	author athomps;	state Exp;
branches;
next	2.7;

2.7
date	2004.01.28.20.36.13;	author athomps;	state Exp;
branches
	2.7.2.1;
next	2.6;

2.6
date	2004.01.09.19.01.08;	author athomps;	state Exp;
branches;
next	2.5;

2.5
date	2003.10.04.02.46.53;	author athomps;	state Exp;
branches;
next	2.4;

2.4
date	2003.09.19.23.35.18;	author athomps;	state Exp;
branches;
next	2.3;

2.3
date	2003.09.18.15.49.57;	author athomps;	state Exp;
branches;
next	2.2;

2.2
date	2003.07.22.22.27.41;	author athomps;	state Exp;
branches;
next	2.1;

2.1
date	2003.06.17.19.08.11;	author athomps;	state Exp;
branches;
next	2.0;

2.0
date	2003.04.24.17.19.15;	author athomps;	state Exp;
branches;
next	1.4;

1.4
date	2003.03.17.17.14.18;	author athomps;	state Exp;
branches;
next	1.3;

1.3
date	2003.03.03.20.32.39;	author athomps;	state Exp;
branches;
next	1.2;

1.2
date	2003.02.21.23.10.03;	author athomps;	state Exp;
branches;
next	1.1;

1.1
date	2003.02.18.23.15.17;	author athomps;	state Exp;
branches;
next	;

2.7.2.1
date	2004.09.13.23.00.09;	author cjkimme;	state Exp;
branches;
next	;

3.0.2.1
date	2005.03.30.23.32.07;	author athomps;	state Exp;
branches;
next	;

3.0.6.1
date	2005.04.07.00.04.52;	author saubry;	state Exp;
branches;
next	;

4.3.4.1
date	2006.02.02.23.40.43;	author athomps;	state Exp;
branches;
next	4.3.4.2;

4.3.4.2
date	2006.02.08.23.43.02;	author athomps;	state Exp;
branches;
next	4.3.4.3;

4.3.4.3
date	2006.02.15.21.34.48;	author athomps;	state Exp;
branches;
next	;

4.4.2.1
date	2005.06.21.21.46.18;	author pscrozi;	state Exp;
branches;
next	;


desc
@@


4.7
log
@Fixed midpoint bug and eliminated all osx_serial_debug warnings (-Wuninitialized, -Wshadow, ...)
@
text
@//-----------------------------------------------------------------------
//
//   G R A S P
//   ____________
//   \           \
//    \ General   \
//     \ Reactive  \
//      \ Atomistic \
//       \ Simulation\
//        \ Program   \
//         \___________\
//
//    Timestamp: April 1, 2005
//    Version: 4.0
//
//    Primary Author: Aidan P. Thompson
//
//    e-mail: athomps@@sandia.gov
//   
//    Copyright (2005) Sandia National Laboratories
//
//    Sandia National Laboratories is a multiprogram laboratory 
//    operated by Sandia Corporation, a Lockheed Martin company,
//    for the United States Department of Energy under contract
//    No. DE-AC04-94AL-85000.
//
//    Under the terms of Contract DE-AC04-94AL85000 with Sandia 
//    Corporation, the U.S. Government retains certain rights in 
//    this software.
//
//    This software is distributed under the terms of the GNU Public 
//    License (GPL). For a copy of the GPL see the file 
//    Grasp/Documentation/LICENSE or visit the GNU website at 
//    http://www.gnu.org/copyleft/gpl.html. Briefly, the GPL 
//    entitles you to use the software, modify it and redistribute it. 
//    The main thing you can not do is apply any other licensing 
//    terms to the software. Also, if any part of this sofware is added 
//    to other software, then that software must also be released under 
//    the GPL.
//
//    This software comes with no warranty of any kind. 
//
//----------------------------------------------------------------------- 
/////:EOH~

#include <vector>
#include <string>
#include <iostream>
#include <fstream>
using namespace std;
#include "mpi.h"
#include "grasp.h"
#include "comm.h"
#include "box.h"
#include "forcefield.h"
#include "neighbor.h"
#include "particletypelist.h"
#include "log.h"
extern Log glog;

ForceField::ForceField() {
  virial.resize(nvirial);
  neighbor = NULL;
}

ForceField::~ForceField() {
  if (neighbor != NULL) {
    delete neighbor;
  }
}
void ForceField::Neighboring(
	         ParticleList* p, 
	         const Box* b, Comm* comm) {
  if (Lneighbor) {
    neighbor->Neighboring(p,type_index,
			rcutneighsq_table,b,comm);
  }
}

bool ForceField::find_id(const string& id, int& itype) const
{
  bool match;
  match = false;
  itype = -1;
  for (int i=0;(i < ntypes) 
	 && !match ; i++) {
    if (id == id_index[i]) {
      match = true;
      itype = i;
      break;
    }
  }
  return match;
}

int ForceField::get_npairs(const int& nparticles) const
{
  int npairs;
  if (get_Lneighbor()) {
    npairs = neighbor->get_nneighbors();
  } else {
    npairs = nparticles*(nparticles-1)/2;
  }
  return npairs;
}

int ForceField::get_ntypes() const {
  return ntypes;
}

int ForceField::get_classname() const {
  return classname;
}

string ForceField::get_label() const {
  return label;
}

double ForceField::get_rcutmax() const {
  return rcutmax;
}

bool ForceField::get_Lneighbor() const {
  return Lneighbor;
}

double ForceField::get_timeforce() const {
  return timeforce;
}

int ForceField::get_nforce() const {
  return nforce;
}

int ForceField::get_npieces() const {
  return npieces;
}

vector<string> ForceField::get_label_piece() const {
  return label_piece;
}

vector<double> ForceField::get_energy() const {
  return energy_piece;
}

double ForceField::get_virial() const {
  return (virial[0]+virial[1]+virial[2])/3.0;
}

void ForceField::get_virial(vector <double>& virial_tmp) const {
  virial_tmp.resize(nvirial);
  for (int ivirial=0;ivirial<nvirial;ivirial++) {
    virial_tmp[ivirial] = virial[ivirial];
  }
}

void ForceField::CheckMasses(const ParticleTypeList*) {
  // Most force fields don't know about masses
};

double ForceField::get_g_ewald() const {
  // Most force fields do not know about g_ewald
  return NULL;
}

void ForceField::SetupNeighbor(const string& neighbor_style,
       const int& neighbor_freq,
       const double& neighbor_rskin, double& rcutneighmax,
       double& rcutcomm,
       const Box* b, Comm* comm){
  int node,nprocs;
  bool Ltwoway,Ltwoway_ghost;

  node = comm->get_node();
  nprocs = comm->get_nprocs();

  if (neighbor_style == "none") {
    Lneighbor = false;
  } else if (neighbor_style == "nsq") {
    Ltwoway = false;
    Ltwoway_ghost = false;
    Lneighbor = true;
    neighbor = new Neighbor(Neighbor::neighbor_nsq,
			    Ltwoway,Ltwoway_ghost,
			    neighbor_freq,neighbor_rskin);
  } else if (neighbor_style == "bin") {
    Ltwoway = false;
    Ltwoway_ghost = false;
    Lneighbor = true;
    neighbor = new Neighbor(Neighbor::neighbor_bin,
			    Ltwoway,Ltwoway_ghost,
			    neighbor_freq,neighbor_rskin);
  } else {
    glog.error("ForceField::SetupNeighbor:\n"
	       "Invalid neighbor style"+neighbor_style);
  }

  if (Lneighbor && Lnocut) {
    glog.error("ForceField::SetupNeighbor:\n"
	       "Can not use nocut types with neighboring");
  }

  if (!Lneighbor && nprocs>1) { 
    glog.error("ForceField::SetupNeighbor:\n"
	       "Must use neighboring with multiple processes");
  }

  if (!Lneighbor) {
    if (2.0*rcutmax >  b->get_lmin()) {
      glog.error("ForceField::SetupNeighbor:\n"
	 "Smallest separation of periodic images less than twice cut-off\n"
	 "Need to use neighbor list to capture all images");
    }
  }

  rcutneighmax = 0.0;
  rcutcomm = 0.0;
  if (Lneighbor) {
    rcutneighmax = rcutmax + neighbor_rskin;
    rcutcomm = rcutmax + neighbor_rskin;
    neighbor->set_rcutneighmax(rcutneighmax);
    SetupCutNeighSq(neighbor_rskin,comm);
    if (node == 0) {
      glog.get_logfile() << "Cutoffs for this forcefield" << endl;
      glog.get_logfile() << "rcutmax = " << rcutmax << endl;
      glog.get_logfile() << "rcutcomm = " << rcutcomm << endl;
      glog.get_logfile() << "rskin = " << neighbor_rskin << endl;
      glog.get_logfile() << "rcutneighmax = " << rcutneighmax << endl;
    }
  }
}

void ForceField::SetupTypes(const ParticleTypeList* t) {
  int itype,itype_ff;
  bool match;
  int nparticletypes;

  nparticletypes = t->get_ntypes();

  // For each id in t, generate ff index
  // If id not found in ff, generate warning
  type_index.resize(nparticletypes);
  for (itype = 0; itype < nparticletypes; itype++) {
    match = find_id(t->get_id(itype),itype_ff);
    if (!match) {
      glog.warning("ForceField::SetupTypes:\n"
		   "No forcefield particle type match for particle type " 
		   + t->get_id(itype));
      type_index[itype]=-1;
    } else {
      type_index[itype]=itype_ff;
    }
  }
    // Check that each id in ff appears in t
  for (itype_ff = 0; itype_ff < ntypes; itype_ff++) {
    match = t->find_id(id_index[itype_ff],itype);
    if (!match) {
      glog.warning("ForceField::SetupTypes:\n"
		   "No particle type match for forcefield particle type "
		   + id_index[itype_ff]);
    }
  }
  CheckMasses(t);
}

void ForceField::set_rcutneighmaxall(const double& rcutneighmaxall) {
  neighbor->set_rcutneighmaxall(rcutneighmaxall);
};

@


4.6
log
@Implemented midpoint method for ReaxFF
@
text
@d74 2
a75 1
  neighbor->Neighboring(p,type_index,
d77 1
@


4.5
log
@Added multiple replica feature.
@
text
@d168 1
d216 1
d219 1
d225 1
@


4.4
log
@Added prototype for Force_PPPM class
@
text
@d220 4
a223 4
      glog.logfile << "Cutoffs for this forcefield" << endl;
      glog.logfile << "rcutmax = " << rcutmax << endl;
      glog.logfile << "rskin = " << neighbor_rskin << endl;
      glog.logfile << "rcutneighmax = " << rcutneighmax << endl;
@


4.4.2.1
log
@Latest PPPM version
@
text
@d160 1
a160 1
//double ForceField::get_g_ewald() const {
d162 2
a163 2
//  return 0.0;
//}
@


4.3
log
@Fixed glitch in header.
@
text
@d160 5
@


4.3.4.1
log
@Added EAM energy change calculation
@
text
@a136 25
void ForceField::SaveEnergy() {
  for (int ipiece=0;ipiece<npieces;ipiece++) {
    energy_save[ipiece] = energy_piece[ipiece];
  }
}
  
void ForceField::ZeroEnergy() {
  for (int ipiece=0;ipiece<npieces;ipiece++) {
    energy_piece[ipiece] = 0.0;
  }
  for (int ivirial=0;ivirial<nvirial;ivirial++) {
    virial[ivirial] = 0.0;
  }
}
  
void ForceField::RestoreEnergy(Comm* comm) {
  vector<double> energy_piece_all(npieces);
  MPI_Allreduce(&energy_piece[0],&energy_piece_all[0],npieces,MPI_DOUBLE,
		MPI_SUM,comm->get_world());
  energy_piece.swap(energy_piece_all);
  for (int ipiece=0;ipiece<npieces;ipiece++) {
    energy_piece[ipiece] += energy_save[ipiece];
  }
}
  
a259 11
// This is an empty version for the base class
double ForceField::EnergyParticleRemove(const int& i, 
	    ParticleList* p, const Box* b, Comm* comm) {
  return 0.0;
}

// This is an empty version for the base class
double ForceField::EnergyParticleAdd(const int& i, 
	    ParticleList* p, const Box* b, Comm* comm) {
  return 0.0;
}
@


4.3.4.2
log
@Added bin-based energy calc
@
text
@a295 12

// This is an empty version for the base class
double ForceField::EnergyParticleRemove(const int& i, const Bin*, 
	    ParticleList* p, const Box* b, Comm* comm) {
  return 0.0;
}

// This is an empty version for the base class
double ForceField::EnergyParticleAdd(const int& i, const Bin*, 
	    ParticleList* p, const Box* b, Comm* comm) {
  return 0.0;
}
@


4.3.4.3
log
@Improved performance of MC moves and turned on periodic output
@
text
@a307 17

// This is an empty version for the base class
void ForceField::SaveParticles(ParticleList* p, const Box* b, Comm* comm) {
}

// This is an empty version for the base class
void ForceField::RestoreParticles(ParticleList* p, const Box* b, Comm* comm) {
}

// This is an empty version for the base class
void ForceField::SaveParticles(const Bin* bp, ParticleList* p, const Box* b, Comm* comm) {
}

// This is an empty version for the base class
void ForceField::RestoreParticles(const Bin* bp, ParticleList* p, const Box* b, Comm* comm) {
}

@


4.2
log
@Recovered from corruption on April 12, 1005
@
text
@d43 1
a43 1
//------------------------------------------------------------------------ 
@


4.1
log
@Create new branch.
@
text
@d13 2
a14 2
//    Timestamp: September 22, 2004
//    Version: 3.0
d16 1
a16 1
//    Author: Aidan P. Thompson
d20 4
a23 4
//    Copyright (2004) Sandia National Laboratories
//   
//    Sandia is a multiprogram laboratory operated by 
//    Sandia Corporation, a Lockheed Martin company,
d27 16
d188 1
a188 1
	       "Invalid neighbor style");
d237 2
a238 2
		   "Particle id has no ff match");
      glog.logfile << itype_ff << " " << t->get_id(itype) << endl;
d249 2
a250 1
		   "ff type id has no particle type match");
@


4.0
log
@This is version 4.0
@
text
@d13 2
a14 2
//    Timestamp: April 1, 2005
//    Version: 4.0
d16 1
a16 1
//    Primary Author: Aidan P. Thompson
d20 4
a23 4
//    Copyright (2005) Sandia National Laboratories
//
//    Sandia National Laboratories is a multiprogram laboratory 
//    operated by Sandia Corporation, a Lockheed Martin company,
a26 16
//    Under the terms of Contract DE-AC04-94AL85000 with Sandia 
//    Corporation, the U.S. Government retains certain rights in 
//    this software.
//
//    This software is distributed under the terms of the GNU Public 
//    License (GPL). For a copy of the GPL see the file 
//    Grasp/Documentation/LICENSE or visit the GNU website at 
//    http://www.gnu.org/copyleft/gpl.html. Briefly, the GPL 
//    entitles you to use the software, modify it and redistribute it. 
//    The main thing you can not do is apply any other licensing 
//    terms to the software. Also, if any part of this sofware is added 
//    to other software, then that software must also be released under 
//    the GPL.
//
//    This software comes with no warranty of any kind. 
//
d172 1
a172 1
	       "Invalid neighbor style"+neighbor_style);
d221 2
a222 2
		   "No forcefield particle type match for particle type " 
		   + t->get_id(itype));
d233 1
a233 2
		   "No particle type match for forcefield particle type "
		   + id_index[itype_ff]);
@


3.3
log
@Merged REAX version with main version
@
text
@d16 1
a16 1
//    Author: Aidan P. Thompson
d20 4
a23 4
//    Copyright (2004) Sandia National Laboratories
//   
//    Sandia is a multiprogram laboratory operated by 
//    Sandia Corporation, a Lockheed Martin company,
d27 16
@


3.2
log
@Added a bunch of tweaks to allow mixing of force fields.
@
text
@a0 1

d13 2
a14 2
//    Timestamp: September 22, 2004
//    Version: 3.0
d221 1
a221 1
		   "No forcefield type for particle type " 
d233 1
a233 1
		   "No particle type match for forcefield type "
@


3.1
log
@Fixed several typos in force field classes.
CV ----------------------------------------------------------------------
@
text
@d1 1
d173 1
a173 1
	       "Invalid neighbor style");
d222 2
a223 2
		   "Particle id has no ff match");
      glog.logfile << itype_ff << " " << t->get_id(itype) << endl;
d234 2
a235 1
		   "ff type id has no particle type match");
@


3.0
log
@Created a new version number, GRASP 3.0
@
text
@d220 1
a220 1
      glog.warning("ForceFieldList::SetupTypes:\n"
d232 1
a232 1
      glog.warning("ForceFieldList::SetupTypes:\n"
@


3.0.6.1
log
@Fusion of ALex and Sylvie's versions.
Implementation of bins.
Add energy change.

saubry (04-06-05)
@
text
@d220 1
a220 1
      glog.warning("ForceField::SetupTypes:\n"
d232 1
a232 1
      glog.warning("ForceField::SetupTypes:\n"
@


3.0.2.1
log
@Separated charge equilibration input from REAX
@
text
@d220 1
a220 1
      glog.warning("ForceField::SetupTypes:\n"
d232 1
a232 1
      glog.warning("ForceField::SetupTypes:\n"
@


2.19
log
@Eliminated troublesome use of inline static const initializations
to define compile-time integer constants. Replaced with enumeration constants.
@
text
@d13 2
a14 1
//    Timestamp: July 26, 2004
@


2.18
log
@Added a new variant of the neighbor list, invoked by
Ltwoway = false
Ltwoway_ghost = true

This is the same as what LAMMPS uses when Newton's Law is not used.

The new variant is used in by the Force_Eam class, in order
to eliminate the communication of fp.

It was more of an experiment than anything. It works, and for
examples with lots of ghost atoms, seems to speed things up, but
I doubt that it is dramatic.
@
text
@d241 1
@


2.17
log
@Did some memory clean up, to satisfy valgrind
@
text
@d148 1
a148 1
  bool Ltwoway;
d157 1
d160 2
a161 1
			    Ltwoway,neighbor_freq,neighbor_rskin);
d164 1
d167 2
a168 1
			    Ltwoway,neighbor_freq,neighbor_rskin);
@


2.16
log
@Fixed problem with virial in class Force_External
@
text
@d46 1
d50 1
a50 1
  if (Lneighbor) {
a53 1

@


2.15
log
@Fixed bugs in ForceEwald and modified testn to test fix
Shortened run times on testm, testo, and testp by 10x.
@
text
@d45 1
@


2.14
log
@Updated header
@
text
@d44 9
@


2.13
log
@Fixed problem with rcutneighmax when using multiple
force fields with different cut off distances.
@
text
@d13 1
a13 1
//    Timestamp: 1 March 2004
@


2.12
log
@Added anisotropic style to pressure control,
and included in Tersoff example testp.
@
text
@d224 3
@


2.11
log
@Added the Tersoff force field class
@
text
@d122 7
@


2.10
log
@Added NPT ensemble. Noy sure if it is working
yet, and need to update documentation.
@
text
@d131 1
a131 1
  bool Lasymm;
d139 1
a139 1
    Lasymm = false;
d142 1
a142 1
			    Lasymm,neighbor_freq,neighbor_rskin);
d144 1
a144 1
    Lasymm = false;
d147 1
a147 1
			    Lasymm,neighbor_freq,neighbor_rskin);
@


2.9
log
@Various
@
text
@d118 4
@


2.8
log
@Added Ewald sum example
@
text
@d13 1
a13 1
//    Timestamp: 8 January 2004
@


2.7
log
@The primary change is the addition of the embedded atom method (EAM)
This is contained in the class Force_Eam. An example is contained
in the directory Testing/testl.

I also tweaked various parts of the code:
-Added epsilon shift to unit cell origin to avoid
pathologies associated with origin at zero
-Changed ndof from 3n to 3n-3
-Implemented localptr usertag arrays in class ParticleList
This enables user to pick whatever integer tags they want for
atoms, but the code generates internal tags 0,1,....nparticles_tot-1.
-Random velocities are now generated for all nparticles_tot particles,
but only assigned to local particles, so that velocity assignments
are independent of number of processors used.
-I got rid of the dreaded COSP neighboring scheme
-I added an example of Nose-Hoover thermostat in testm
-I added a warning for when force field type has no particle type match.
@
text
@d34 1
d36 2
d40 1
d44 7
d118 1
a118 2
void ForceField::CheckMasses(const int [], 
                             const ParticleTypeList*) {
d121 91
@


2.7.2.1
log
@Committing merge of main trunk onto branch cjkimme_version.
@
text
@d13 1
a13 1
//    Timestamp: July 26, 2004
a33 1
#include "mpi.h"
a34 2
#include "comm.h"
#include "box.h"
a36 1
#include "particletypelist.h"
a39 17
ForceField::ForceField() {
  virial.resize(nvirial);
  neighbor = NULL;
}

ForceField::~ForceField() {
  if (neighbor != NULL) {
    delete neighbor;
  }
}
void ForceField::Neighboring(
	         ParticleList* p, 
	         const Box* b, Comm* comm) {
  neighbor->Neighboring(p,type_index,
			rcutneighsq_table,b,comm);
}

d107 2
a108 12
double ForceField::get_virial() const {
  return (virial[0]+virial[1]+virial[2])/3.0;
}

void ForceField::get_virial(vector <double>& virial_tmp) const {
  virial_tmp.resize(nvirial);
  for (int ivirial=0;ivirial<nvirial;ivirial++) {
    virial_tmp[ivirial] = virial[ivirial];
  }
}

void ForceField::CheckMasses(const ParticleTypeList*) {
a109 99
};

void ForceField::SetupNeighbor(const string& neighbor_style,
       const int& neighbor_freq,
       const double& neighbor_rskin, double& rcutneighmax,
       const Box* b, Comm* comm){
  int node,nprocs;
  bool Ltwoway,Ltwoway_ghost;

  node = comm->get_node();
  nprocs = comm->get_nprocs();

  if (neighbor_style == "none") {
    Lneighbor = false;
  } else if (neighbor_style == "nsq") {
    Ltwoway = false;
    Ltwoway_ghost = false;
    Lneighbor = true;
    neighbor = new Neighbor(Neighbor::neighbor_nsq,
			    Ltwoway,Ltwoway_ghost,
			    neighbor_freq,neighbor_rskin);
  } else if (neighbor_style == "bin") {
    Ltwoway = false;
    Ltwoway_ghost = false;
    Lneighbor = true;
    neighbor = new Neighbor(Neighbor::neighbor_bin,
			    Ltwoway,Ltwoway_ghost,
			    neighbor_freq,neighbor_rskin);
  } else {
    glog.error("ForceField::SetupNeighbor:\n"
	       "Invalid neighbor style");
  }

  if (Lneighbor && Lnocut) {
    glog.error("ForceField::SetupNeighbor:\n"
	       "Can not use nocut types with neighboring");
  }

  if (!Lneighbor && nprocs>1) { 
    glog.error("ForceField::SetupNeighbor:\n"
	       "Must use neighboring with multiple processes");
  }

  if (!Lneighbor) {
    if (2.0*rcutmax >  b->get_lmin()) {
      glog.error("ForceField::SetupNeighbor:\n"
	 "Smallest separation of periodic images less than twice cut-off\n"
	 "Need to use neighbor list to capture all images");
    }
  }

  rcutneighmax = 0.0;
  if (Lneighbor) {
    rcutneighmax = rcutmax + neighbor_rskin;
    neighbor->set_rcutneighmax(rcutneighmax);
    SetupCutNeighSq(neighbor_rskin,comm);
    if (node == 0) {
      glog.logfile << "Cutoffs for this forcefield" << endl;
      glog.logfile << "rcutmax = " << rcutmax << endl;
      glog.logfile << "rskin = " << neighbor_rskin << endl;
      glog.logfile << "rcutneighmax = " << rcutneighmax << endl;
    }
  }
}

void ForceField::SetupTypes(const ParticleTypeList* t) {
  int itype,itype_ff;
  bool match;
  int nparticletypes;

  nparticletypes = t->get_ntypes();

  // For each id in t, generate ff index
  // If id not found in ff, generate warning
  type_index.resize(nparticletypes);
  for (itype = 0; itype < nparticletypes; itype++) {
    match = find_id(t->get_id(itype),itype_ff);
    if (!match) {
      glog.warning("ForceFieldList::SetupTypes:\n"
		   "Particle id has no ff match");
      glog.logfile << itype_ff << " " << t->get_id(itype) << endl;
      type_index[itype]=-1;
    } else {
      type_index[itype]=itype_ff;
    }
  }
    // Check that each id in ff appears in t
  for (itype_ff = 0; itype_ff < ntypes; itype_ff++) {
    match = t->find_id(id_index[itype_ff],itype);
    if (!match) {
      glog.warning("ForceFieldList::SetupTypes:\n"
		   "ff type id has no particle type match");
    }
  }
  CheckMasses(t);
}

void ForceField::set_rcutneighmaxall(const double& rcutneighmaxall) {
  neighbor->set_rcutneighmaxall(rcutneighmaxall);
@


2.6
log
@Added a Perl script to Header.pl to prepend a header contained in
header.txt to source fiels, using

Header.pl *.pl *.cpp *.h M*[^~]
@
text
@d107 4
@


2.5
log
@Fized up the output a little mor.
Standardized the method for treating enum option lists
Created the Constants class
@
text
@d1 28
@


2.4
log
@Reworked a lot of the output to make it cleaner and more consistent.
Improved the timers.
@
text
@d41 1
a41 1
};
d45 1
a45 1
};
d49 1
a49 1
};
d53 1
a53 1
};
d57 1
a57 5
};

double ForceField::get_energy() const {
  return energy;
};
d61 1
a61 1
};
d65 14
a78 1
};
@


2.3
log
@Fixed a couple more bugs to get neighbor binning working.
No more known round-off problems exist.
@
text
@d12 1
a12 1
bool Forcefield::find_id(const string& id, int& itype) const
d28 1
a28 1
int Forcefield::get_npairs(const int& nparticles) const
d39 1
a39 1
int Forcefield::get_ntypes() const {
d43 1
a43 1
int Forcefield::get_classname() const {
d47 5
a51 1
double Forcefield::get_rcutmax() const {
d55 1
a55 1
bool Forcefield::get_Lneighbor() const {
d57 12
@


2.2
log
@Improved treament of log and error messages using new class Log.
Added minimization class Minimizer (currently only steepest descent).
Implemented Nsq neighboring for threebody forcefields.
Reinstated density profiles.
@
text
@d32 1
a32 1
    npairs = get_nneighbors();
a38 4
int Forcefield::get_nneighbors() const {
    return neighbor->get_nneighbors();
};

d47 2
a48 2
double Forcefield::get_rcut_max() const {
  return rcut_max;
@


2.1
log
@This is a lot of stuff.  Basically, the code is now parallel,
but it is only tested for the force field twobody_lj_cut.

The parallelization scheme is based on Steve Plimptons Comm class.
@
text
@d9 2
a10 1
extern ofstream logfile;
a58 6
const vector<Fixed_Object>& Forcefield::get_walls() {
  logfile <<"Error: ForceField::get_walls():"
    "This function should only be called for derived classes"
    "It is not implemented in base class" << endl;
  exit(0);
}
@


2.0
log
@*** empty log message ***
@
text
@d4 1
d9 1
d59 1
a59 1
  cout <<"Error: ForceField::get_walls():"
@


1.4
log
@Added class Profile to measure different types of spatial profiles
Added class Input to handle input commands.
Added global functions input_string to parse input commands.
@
text
@d3 3
a8 11
void Forcefield::SetupNeighborListNsq(const vector<Particle>& particles, const int* type_index) {
  neighbor->SetupNeighborListNsq(particles,type_index,*this);
};

void Forcefield::SetupNeighborListNsqNonself(
            const vector<Particle>& particlesi, 
	    const vector<Particle>& particlesj, 
	    const int* type_index) {
  neighbor->SetupNeighborListNsqNonself(particlesi,particlesj,type_index,*this);
};

d56 2
a57 5
void Forcefield::SetupNeighborListNsqWall(
       const vector<Particle>& particles, 
       const int* type_index)
{
  cout <<"Error: ForceField::SetupNeighborListNsqWall:"
@


1.3
log
@Added the Forcefield derived class Force_External. It makes use
of the class Fixed_Object, which resembles class Particle,
bu does not have a velocity vector and does not provide
timestepping operations.

Also added the basic temperature initialization in temperature.cpp,
as well as velocity output in box.cpp.
@
text
@d52 4
@


1.2
log
@Fixed a variety of bugs related to energy conservation.
Add kinetic energy and temperature calculation.
LJ and Stillinger-Weber forcefields fully tested against
TOWHEE and energy conservation.
@
text
@d10 7
d33 11
d59 10
@


1.1
log
@Created an abstract class Forcefield, with derived classes Force_Twobody
and Force_Threebody.
Implemented Stillinger-Weber forcefield within Force_Threebody.
Unfortunately, the COSP neighboring method does not work for
threebody forces, so we currently do not have neighbor lists
for threebody interactions.  Probably need to use LAMMPS-like
ghost atom method and standard neighbor list structures.
@
text
@d2 1
d10 1
a10 1
bool Forcefield::find_id(const int& id, int& itype) const
@

