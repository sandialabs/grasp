head	4.13;
access;
symbols
	ReverseComm_branch:4.6.0.2
	ADTools_branch:4.5.0.2
	Monaco_Aidan:4.3.0.6
	Root-of-Monaco_Aidan:4.3
	PPPM_Crozier2:4.3.0.4
	PPPM_Crozier:4.3
	Root-of-PPPM_Crozier:4.3
	Monaco:4.3.0.2
	PreMonaco:4.3
	Recovery-2004-04-12:4.0
	BRANCH:4.1.0.4
	PMONACO:4.1.0.2
	ROOT:4.1
	initial:4.0.0.2
	pmonaco:4.0
	Version_4_0:4.0
	Version_3_0:3.0
	BeforeREAXMerge:3.3
	REAX-2:3.2
	P_MonacoSource:3.3.0.4
	GraspSource:3.3
	P_Monaco:3.3.0.2
	InitialGrasp:3.3
	REAXFF:3.2.0.2
	premerge_cjkimme_version:3.0
	CRAY:2.10.0.2
	cjkimme_version_merge_from_trunk_1:2.6.2.3
	cjkimme_version:2.6.0.2;
locks; strict;
comment	@// @;


4.13
date	2008.05.22.17.23.38;	author athomps;	state Exp;
branches;
next	4.12;

4.12
date	2007.10.15.20.52.10;	author athomps;	state Exp;
branches;
next	4.11;

4.11
date	2007.05.15.19.30.48;	author athomps;	state Exp;
branches;
next	4.10;

4.10
date	2007.03.12.04.00.03;	author athomps;	state Exp;
branches;
next	4.9;

4.9
date	2007.02.15.04.41.38;	author athomps;	state Exp;
branches;
next	4.8;

4.8
date	2007.01.26.23.22.28;	author athomps;	state Exp;
branches;
next	4.7;

4.7
date	2006.11.09.20.13.52;	author athomps;	state Exp;
branches;
next	4.6;

4.6
date	2006.08.26.02.04.29;	author athomps;	state Exp;
branches
	4.6.2.1;
next	4.5;

4.5
date	2006.01.25.21.40.12;	author athomps;	state Exp;
branches;
next	4.4;

4.4
date	2005.10.11.01.40.34;	author athomps;	state Exp;
branches;
next	4.3;

4.3
date	2005.05.03.16.28.27;	author athomps;	state Exp;
branches
	4.3.6.1;
next	4.2;

4.2
date	2005.05.02.20.13.38;	author athomps;	state Exp;
branches;
next	4.1;

4.1
date	2005.04.12.22.26.04;	author saubry;	state Exp;
branches;
next	4.0;

4.0
date	2005.04.05.16.43.30;	author athomps;	state Exp;
branches;
next	3.4;

3.4
date	2005.04.02.00.37.56;	author athomps;	state Exp;
branches;
next	3.3;

3.3
date	2005.01.11.16.06.05;	author athomps;	state Exp;
branches
	3.3.4.1;
next	3.2;

3.2
date	2004.10.22.22.35.17;	author cjkimme;	state Exp;
branches;
next	3.1;

3.1
date	2004.10.22.22.30.16;	author cjkimme;	state Exp;
branches;
next	3.0;

3.0
date	2004.09.22.17.56.49;	author athomps;	state Exp;
branches;
next	2.10;

2.10
date	2004.08.13.22.54.43;	author athomps;	state Exp;
branches;
next	2.9;

2.9
date	2004.07.26.15.52.18;	author athomps;	state Exp;
branches;
next	2.8;

2.8
date	2004.07.21.17.46.50;	author athomps;	state Exp;
branches;
next	2.7;

2.7
date	2004.05.20.22.11.34;	author athomps;	state Exp;
branches;
next	2.6;

2.6
date	2004.01.28.20.36.13;	author athomps;	state Exp;
branches
	2.6.2.1;
next	2.5;

2.5
date	2004.01.09.19.01.08;	author athomps;	state Exp;
branches;
next	2.4;

2.4
date	2003.11.26.22.51.14;	author athomps;	state Exp;
branches;
next	2.3;

2.3
date	2003.10.20.22.05.45;	author athomps;	state Exp;
branches;
next	2.2;

2.2
date	2003.07.22.22.27.41;	author athomps;	state Exp;
branches;
next	2.1;

2.1
date	2003.06.17.19.08.11;	author athomps;	state Exp;
branches;
next	2.0;

2.0
date	2003.04.24.17.19.15;	author athomps;	state Exp;
branches;
next	1.6;

1.6
date	2003.02.25.23.06.37;	author athomps;	state Exp;
branches;
next	1.5;

1.5
date	2003.02.21.23.10.03;	author athomps;	state Exp;
branches;
next	1.4;

1.4
date	2003.02.18.23.15.17;	author athomps;	state Exp;
branches;
next	1.3;

1.3
date	2003.02.04.00.12.41;	author athomps;	state Exp;
branches;
next	1.2;

1.2
date	2003.01.18.00.20.49;	author athomps;	state Exp;
branches;
next	1.1;

1.1
date	2003.01.08.23.25.53;	author athomps;	state Exp;
branches;
next	;

4.6.2.1
date	2006.11.08.04.18.38;	author athomps;	state Exp;
branches;
next	;

4.3.6.1
date	2006.02.02.23.40.43;	author athomps;	state Exp;
branches;
next	;

3.3.4.1
date	2005.02.17.21.41.38;	author saubry;	state Exp;
branches;
next	3.3.4.2;

3.3.4.2
date	2005.04.07.00.04.52;	author saubry;	state Exp;
branches;
next	;

2.6.2.1
date	2004.05.14.16.12.58;	author cjkimme;	state Exp;
branches;
next	2.6.2.2;

2.6.2.2
date	2004.09.09.21.01.42;	author cjkimme;	state Exp;
branches;
next	2.6.2.3;

2.6.2.3
date	2004.09.13.23.00.09;	author cjkimme;	state Exp;
branches;
next	;


desc
@@


4.13
log
@Fixed error in pressure control full for non-zero origin
@
text
@//-----------------------------------------------------------------------
//
//   G R A S P
//   ____________
//   \           \
//    \ General   \
//     \ Reactive  \
//      \ Atomistic \
//       \ Simulation\
//        \ Program   \
//         \___________\
//
//    Timestamp: April 1, 2005
//    Version: 4.0
//
//    Primary Author: Aidan P. Thompson
//
//    e-mail: athomps@@sandia.gov
//   
//    Copyright (2005) Sandia National Laboratories
//
//    Sandia National Laboratories is a multiprogram laboratory 
//    operated by Sandia Corporation, a Lockheed Martin company,
//    for the United States Department of Energy under contract
//    No. DE-AC04-94AL-85000.
//
//    Under the terms of Contract DE-AC04-94AL85000 with Sandia 
//    Corporation, the U.S. Government retains certain rights in 
//    this software.
//
//    This software is distributed under the terms of the GNU Public 
//    License (GPL). For a copy of the GPL see the file 
//    Grasp/Documentation/LICENSE or visit the GNU website at 
//    http://www.gnu.org/copyleft/gpl.html. Briefly, the GPL 
//    entitles you to use the software, modify it and redistribute it. 
//    The main thing you can not do is apply any other licensing 
//    terms to the software. Also, if any part of this sofware is added 
//    to other software, then that software must also be released under 
//    the GPL.
//
//    This software comes with no warranty of any kind. 
//
//----------------------------------------------------------------------- 
/////:EOH~

#include <iostream>
#include <fstream>
#include <vector>
#include <string>
#include <cmath>
using namespace std;
#include "mpi.h"
#include "grasp.h"
#include "particle.h"
#include "box.h"
#include "log.h"
extern Log glog;

Particle::Particle()
{
  type = 0;
  tag = 0;
  color = 0;
  x[0] = 0.0;
  x[1] = 0.0;
  x[2] = 0.0;
  mass = 0.0;
  charge = 0.0;
  v[0] = 0.0;
  v[1] = 0.0;
  v[2] = 0.0;
  f[0] = 0.0;
  f[1] = 0.0;
  f[2] = 0.0;  
  X[0] = X[1] = X[2] = 0.0;
  phi = 0.0;
  ishift[0] = 0;
  ishift[1] = 0;
  ishift[2] = 0;
  virial[0] = 0.0;
  virial[1] = 0.0;
  virial[2] = 0.0;
  virial[3] = 0.0;
  virial[4] = 0.0;
  virial[5] = 0.0;
  is_fixed = false;  // these two should always be set later
  to_be_minimized = false;
}

Particle::Particle(const int& typein, const int& tagin, 
		   const int& colorin, const double xin[],
		   const double Xin[], const double& massin,
		   const int ishift_in[],
		   const double& chargein, const double& phiin,
		   const bool& fix_in, const bool& minimize_in)
{
  type = typein;
  tag = tagin;
  color = colorin;
  x[0] = xin[0];
  x[1] = xin[1];
  x[2] = xin[2];
  mass = massin;
  charge = chargein;
  v[0] = 0.0;
  v[1] = 0.0;
  v[2] = 0.0;
  f[0] = 0.0;
  f[1] = 0.0;
  f[2] = 0.0;  
  X[0] = Xin[0];
  X[1] = Xin[1];
  X[2] = Xin[2];
  phi = phiin;
  ishift[0] = ishift_in[0];
  ishift[1] = ishift_in[1];
  ishift[2] = ishift_in[2];
  virial[0] = 0.0;
  virial[1] = 0.0;
  virial[2] = 0.0;
  virial[3] = 0.0;
  virial[4] = 0.0;
  virial[5] = 0.0;
  is_fixed = fix_in;
  to_be_minimized = minimize_in;
}

Particle::Particle(const int& typein, const int& tagin,
		   const int& colorin, const double xin[],
		   const double Xin[], const double& massin, 
		   const double& chargein, const double vin[], 
		   const int ishift_in[],
		   const double& phiin, 
		   const bool& fix_in, const bool& minimize_in)
{
  type = typein;
  tag = tagin;
  color = colorin;
  x[0] = xin[0];
  x[1] = xin[1];
  x[2] = xin[2];
  mass = massin;
  charge = chargein;
  v[0] = vin[0];
  v[1] = vin[1];
  v[2] = vin[2];
  f[0] = 0.0;
  f[1] = 0.0;
  f[2] = 0.0;  
  X[0] = Xin[0]; 
  X[1] = Xin[1]; 
  X[2] = Xin[2];
  phi = phiin;
  ishift[0] = ishift_in[0];
  ishift[1] = ishift_in[1];
  ishift[2] = ishift_in[2];
  virial[0] = 0.0;
  virial[1] = 0.0;
  virial[2] = 0.0;
  virial[3] = 0.0;
  virial[4] = 0.0;
  virial[5] = 0.0;
  is_fixed = fix_in;
  to_be_minimized = minimize_in;
}

Particle::Particle(const int& typein, const int& tagin,
		   const double xin[], const double Xin[], const double& chargein)
{
  type = typein;
  tag = tagin;
  x[0] = xin[0];
  x[1] = xin[1];
  x[2] = xin[2];
  mass = 0.0;
  charge = chargein;
  f[0] = 0.0;
  f[1] = 0.0;
  f[2] = 0.0;  
  X[0] = Xin[0];
  X[1] = Xin[1];
  X[2] = Xin[2];
  virial[0] = 0.0;
  virial[1] = 0.0;
  virial[2] = 0.0;
  virial[3] = 0.0;
  virial[4] = 0.0;
  virial[5] = 0.0;
  is_fixed = false;
  to_be_minimized = false;
}

Particle::Particle(const Particle& p)
{
  type = p.type;
  tag = p.tag;
  color = p.color;
  x[0] = p.x[0];
  x[1] = p.x[1];
  x[2] = p.x[2];
  mass = p.mass;
  charge = p.charge;
  v[0] = p.v[0];
  v[1] = p.v[1];
  v[2] = p.v[2];
  f[0] = p.f[0];
  f[1] = p.f[1];
  f[2] = p.f[2];
  X[0] = p.X[0];
  X[1] = p.X[1];
  X[2] = p.X[2];
  phi = p.phi;
  ishift[0] = p.ishift[0];
  ishift[1] = p.ishift[1];
  ishift[2] = p.ishift[2];
  virial[0] = p.virial[0];
  virial[1] = p.virial[1];
  virial[2] = p.virial[2];
  virial[3] = p.virial[3];
  virial[4] = p.virial[4];
  virial[5] = p.virial[5];
  is_fixed = p.is_fixed;
  to_be_minimized = p.to_be_minimized;
}

Particle& Particle::operator=(const Particle& p)
{
  if (this != &p) {
    type = p.type;
    tag = p.tag;
    color = p.color;
    x[0] = p.x[0];
    x[1] = p.x[1];
    x[2] = p.x[2];
    charge = p.charge;
    mass = p.mass;
    v[0] = p.v[0];
    v[1] = p.v[1];
    v[2] = p.v[2];
    f[0] = p.f[0];
    f[1] = p.f[1];
    f[2] = p.f[2];
    X[0] = p.X[0];
    X[1] = p.X[1];
    X[2] = p.X[2];
    phi = p.phi;
    ishift[0] = p.ishift[0];
    ishift[1] = p.ishift[1];
    ishift[2] = p.ishift[2];
    virial[0] = p.virial[0];
    virial[1] = p.virial[1];
    virial[2] = p.virial[2];
    virial[3] = p.virial[3];
    virial[4] = p.virial[4];
    virial[5] = p.virial[5];
    is_fixed = p.is_fixed;
    to_be_minimized = p.to_be_minimized;
  }
  return *this;
}

Particle::~Particle()
{
}

int Particle::get_tag() const
{
  return tag;
}

int Particle::get_color() const
{
  return color;
}

void Particle::get_v(double v_out[]) const
{
  v_out[0] = v[0];
  v_out[1] = v[1];
  v_out[2] = v[2];
  return;
}

void Particle::get_f(double f_out[]) const
{
  f_out[0] = f[0];
  f_out[1] = f[1];
  f_out[2] = f[2];
  return;
}

void Particle::get_virial(double virial_out[]) const
{
  virial_out[0] = virial[0];
  virial_out[1] = virial[1];
  virial_out[2] = virial[2];
  virial_out[3] = virial[3];
  virial_out[4] = virial[4];
  virial_out[5] = virial[5];
  return;
}

void Particle::get_X(double X_out[]) const
{
  X_out[0] = X[0];
  X_out[1] = X[1];
  X_out[2] = X[2];
  return;
}

void Particle::get_shift(int ishift_out[]) const
{
  ishift_out[0] = ishift[0];
  ishift_out[1] = ishift[1];
  ishift_out[2] = ishift[2];
}

void Particle::get_shift(double dshift_out[]) const
{
  dshift_out[0] = ishift[0];
  dshift_out[1] = ishift[1];
  dshift_out[2] = ishift[2];
}

void Particle::get_u(double u_out[]) const
{
  u_out[0] = x[0]-X[0];
  u_out[1] = x[1]-X[1];
  u_out[2] = x[2]-X[2];
  return;
}

double Particle::get_charge() const
{
  return charge;
}

double Particle::get_mass() const
{
  return mass;
}
 
double Particle::get_phi() const
{
  return phi;
}

bool Particle::get_fixed() const
{
  return is_fixed;
}

bool Particle::get_minimized() const
{
  return to_be_minimized;
}

double Particle::get_mvsq() const
{
  return mass*(v[0]*v[0]+v[1]*v[1]+v[2]*v[2]);
}

void Particle::get_mvsq(vector <double>& kv_tmp) const {
  kv_tmp[0] = mass*v[0]*v[0];
  kv_tmp[1] = mass*v[1]*v[1];
  kv_tmp[2] = mass*v[2]*v[2];
  kv_tmp[3] = mass*v[0]*v[1];
  kv_tmp[4] = mass*v[0]*v[2];
  kv_tmp[5] = mass*v[1]*v[2];
}

void Particle::set_type(const int& typein)
{
  type = typein;
}

void Particle::set_tag(const int& tagin)
{
  tag = tagin;
}

void Particle::set_color(const int& colorin)
{
  color = colorin;
}

void Particle::set_x(const double x_in[])
{
  x[0] = x_in[0];
  x[1] = x_in[1];
  x[2] = x_in[2];
}

void Particle::set_v(const double v_in[])
{
  v[0] = v_in[0];
  v[1] = v_in[1];
  v[2] = v_in[2];
}

void Particle::set_f(const double f_in[])
{
  f[0] = f_in[0];
  f[1] = f_in[1];
  f[2] = f_in[2];
}

void Particle::set_f()
{
  f[0]=0.0;
  f[1]=0.0;
  f[2]=0.0;
}

void Particle::set_virial()
{
  virial[0]=0.0;
  virial[1]=0.0;
  virial[2]=0.0;
  virial[3]=0.0;
  virial[4]=0.0;
  virial[5]=0.0;
}

void Particle::set_X(const double X_in[])
{
  X[0] = X_in[0];
  X[1] = X_in[1];
  X[2] = X_in[2];
}

void Particle::set_charge(const double& chargein)
{
  charge = chargein;
}

void Particle::set_mass(const double& massin)
{
  mass = massin;
}

void Particle::set_phi(const double& phiin)
{
  phi = phiin;
}

void Particle::increment_phi(const double& eij)
{
  phi += eij;
}

void Particle::step_x(const double& timestep)
{
  if (!is_fixed) {
    x[0]+=timestep*v[0];
    x[1]+=timestep*v[1];
    x[2]+=timestep*v[2];
  }
}

void Particle::step_x_force(const double& timestepsq, 
			    const bool* relax_coord)
{
  if (!is_fixed) {
    double dtmass;
    dtmass = 0.5*timestepsq/mass;
    if (relax_coord[0]) x[0]+=dtmass*f[0];
    if (relax_coord[1]) x[1]+=dtmass*f[1];
    if (relax_coord[2]) x[2]+=dtmass*f[2];
  } 
}

void Particle::step_x_force(const double& timestepsq, 
			    const bool* relax_coord, const double& maxstep,
			    bool& Lmaxstep, double& fsq)
{
  fsq = 0.0;
  if (!is_fixed) {
    double dtmass;
    double step;
    dtmass = timestepsq/mass;

    if (relax_coord[0]) {
      step = dtmass*f[0];
      fsq+=f[0]*f[0];
      if (fabs(step) < maxstep) {
	x[0]+=step;
      } else {
	Lmaxstep = true;
	if (step>0.0) {
	  x[0]+=maxstep;
	} else {
	  x[0]-=maxstep;
	}
      }
    }
    
    if (relax_coord[1]) {
      step = dtmass*f[1];
      fsq+=f[1]*f[1];
      if (fabs(step) < maxstep) {
	x[1]+=step;
      } else {
	Lmaxstep = true;
	if (step>0.0) {
	  x[1]+=maxstep;
	} else {
	  x[1]-=maxstep;
	}
      }
    }
    
    if (relax_coord[2]) {
      step = dtmass*f[2];
      fsq+=f[2]*f[2];
      if (fabs(step) < maxstep) {
	x[2]+=step;
      } else {
	Lmaxstep = true;
	if (step>0.0) {
	  x[2]+=maxstep;
	} else {
	  x[2]-=maxstep;
	}
      }
    }
  } 
}

void Particle::step_v(const double& timestep)
{
  if (!is_fixed) {
    double dtmass;
    dtmass = timestep/mass;
    v[0]+=dtmass*f[0];
    v[1]+=dtmass*f[1];
    v[2]+=dtmass*f[2];
  }
}

void Particle::scale_v(const double fac)
{
  v[0] = fac*v[0];
  v[1] = fac*v[1];
  v[2] = fac*v[2];
}

void Particle::scale_v(const Box* b, const double fac[])
{
  b->Scale_Vel(v,fac);    
}

void Particle::scale_v(const Box* b, const double deformation[3][3])
{
  b->Scale_Vel(v,deformation);    
}

void Particle::reset_x(const Box* b)
{
  b->Minimg_Pos(x,X,ishift);    
}


void Particle::reset_full_x(const Box* b)
{
  b->Minimg_Pos_Full(x,X,ishift);
}

void Particle::scale_x(const Box* b, const double dilation[]) {
  b->Scale_Pos(x,dilation);    
}

void Particle::scaled_deform(const Box* b, const double deformation[3][3]) {
  b->Scaled_Deform(x,deformation);    
}

void Particle::apply_boundary_conditions(const Box* b)
{
  b->ReflectPosVel(x,v);
}


@


4.12
log
@Improved stability of steepest descent minimizer
@
text
@d555 1
a555 1
  b->Scaled_Deform(v,deformation);    
@


4.11
log
@Added nose-hoover-full version of pressure control to allow fully flexible fluctuations in box dimensions
@
text
@d475 1
a475 1
			    bool& Lmaxstep)
d477 1
d485 1
d500 1
d515 1
@


4.10
log
@Added fix deformation command to allow box shape to be changed over time
@
text
@d549 5
@


4.9
log
@Added non-periodic BC, constant velocity vector, slabwise temperature rescale fix
@
text
@d564 4
@


4.8
log
@Added periodic shift tracking and added timestep to restart
@
text
@d564 5
@


4.7
log
@Merged ReverseComm_branch back into main branch
@
text
@d77 3
d93 1
d115 3
d131 3
a133 1
		   const double& chargein, const double vin[], const double& phiin, 
d154 3
d213 3
d247 3
d311 14
d551 1
a551 1
  b->Minimg_Pos(x,X);    
d557 1
a557 1
  b->Minimg_Pos_Full(x,X);
@


4.6
log
@Added damping constant commands for Nose-Hoover barostats and thermostats
@
text
@d77 6
d111 6
d124 2
a125 1
		   const double& chargein, const double vin[], const double& phiin, const bool& fix_in, const bool& minimize_in)
d145 6
d171 6
d201 6
d232 6
d274 11
d383 10
@


4.6.2.1
log
@Added atom stress for ReaxFF
@
text
@a76 6
  virial[0] = 0.0;
  virial[1] = 0.0;
  virial[2] = 0.0;
  virial[3] = 0.0;
  virial[4] = 0.0;
  virial[5] = 0.0;
a104 6
  virial[0] = 0.0;
  virial[1] = 0.0;
  virial[2] = 0.0;
  virial[3] = 0.0;
  virial[4] = 0.0;
  virial[5] = 0.0;
d112 1
a112 2
		   const double& chargein, const double vin[], const double& phiin, 
		   const bool& fix_in, const bool& minimize_in)
a131 6
  virial[0] = 0.0;
  virial[1] = 0.0;
  virial[2] = 0.0;
  virial[3] = 0.0;
  virial[4] = 0.0;
  virial[5] = 0.0;
a151 6
  virial[0] = 0.0;
  virial[1] = 0.0;
  virial[2] = 0.0;
  virial[3] = 0.0;
  virial[4] = 0.0;
  virial[5] = 0.0;
a175 6
  virial[0] = p.virial[0];
  virial[1] = p.virial[1];
  virial[2] = p.virial[2];
  virial[3] = p.virial[3];
  virial[4] = p.virial[4];
  virial[5] = p.virial[5];
a200 6
    virial[0] = p.virial[0];
    virial[1] = p.virial[1];
    virial[2] = p.virial[2];
    virial[3] = p.virial[3];
    virial[4] = p.virial[4];
    virial[5] = p.virial[5];
a236 11
void Particle::get_virial(double virial_out[]) const
{
  virial_out[0] = virial[0];
  virial_out[1] = virial[1];
  virial_out[2] = virial[2];
  virial_out[3] = virial[3];
  virial_out[4] = virial[4];
  virial_out[5] = virial[5];
  return;
}

a334 10
void Particle::set_virial()
{
  virial[0]=0.0;
  virial[1]=0.0;
  virial[2]=0.0;
  virial[3]=0.0;
  virial[4]=0.0;
  virial[5]=0.0;
}

@


4.5
log
@Added multiple replica feature.
@
text
@d376 1
a376 1
    dtmass = timestepsq/mass;
@


4.4
log
@Added some new barostats and thermostats.
@
text
@d52 1
@


4.3
log
@Fixed glitch in header.
@
text
@d453 1
a453 1
void Particle::scale_v(const double fac[])
d455 1
a455 3
  v[0] = fac[0]*v[0];
  v[1] = fac[1]*v[1];
  v[2] = fac[2]*v[2];
@


4.3.6.1
log
@Added EAM energy change calculation
@
text
@a75 1
  rho = 0.0;
a83 1
		   const double& rhoin,
a103 1
  rho = rhoin;
d111 1
a111 3
		   const double& chargein, const double vin[], 
		   const double& phiin, const double& rhoin, 
		   const bool& fix_in, const bool& minimize_in)
a130 1
  rho = rhoin;
d136 1
a136 2
		   const double xin[], const double Xin[], 
		   const double& chargein, const double& rhoin)
a144 1
  rho = rhoin;
a174 1
  rho = p.rho;
a199 1
    rho = p.rho;
a266 5
double Particle::get_rho() const
{
  return rho;
}

a355 5
void Particle::set_rho(const double& rhoin)
{
  rho = rhoin;
}

a360 5
void Particle::increment_rho(const double& rhoij)
{
  rho += rhoij;
}

@


4.2
log
@Recovered from corruption on April 12, 1005
@
text
@d43 1
a43 1
//------------------------------------------------------------------------ 
@


4.1
log
@Create new branch.
@
text
@d13 2
a14 2
//    Timestamp: September 22, 2004
//    Version: 3.0
d16 1
a16 1
//    Author: Aidan P. Thompson
d20 4
a23 4
//    Copyright (2004) Sandia National Laboratories
//   
//    Sandia is a multiprogram laboratory operated by 
//    Sandia Corporation, a Lockheed Martin company,
d27 16
a355 7
void Particle::add_x(const double x_in[])
{
  x[0] += x_in[0];
  x[1] += x_in[1];
  x[2] += x_in[2];
}

@


4.0
log
@This is version 4.0
@
text
@d13 2
a14 2
//    Timestamp: April 1, 2005
//    Version: 4.0
d16 1
a16 1
//    Primary Author: Aidan P. Thompson
d20 4
a23 4
//    Copyright (2005) Sandia National Laboratories
//
//    Sandia National Laboratories is a multiprogram laboratory 
//    operated by Sandia Corporation, a Lockheed Martin company,
a26 16
//    Under the terms of Contract DE-AC04-94AL85000 with Sandia 
//    Corporation, the U.S. Government retains certain rights in 
//    this software.
//
//    This software is distributed under the terms of the GNU Public 
//    License (GPL). For a copy of the GPL see the file 
//    Grasp/Documentation/LICENSE or visit the GNU website at 
//    http://www.gnu.org/copyleft/gpl.html. Briefly, the GPL 
//    entitles you to use the software, modify it and redistribute it. 
//    The main thing you can not do is apply any other licensing 
//    terms to the software. Also, if any part of this sofware is added 
//    to other software, then that software must also be released under 
//    the GPL.
//
//    This software comes with no warranty of any kind. 
//
d340 7
@


3.4
log
@Merged REAX version with main version
@
text
@d16 1
a16 1
//    Author: Aidan P. Thompson
d20 4
a23 4
//    Copyright (2004) Sandia National Laboratories
//   
//    Sandia is a multiprogram laboratory operated by 
//    Sandia Corporation, a Lockheed Martin company,
d27 16
@


3.3
log
@Fixed two bugs in nph_anisotropic integration scheme that
were causing the wrong dynamics. The scheme now conserves
the pseudohamiltonian well.
@
text
@d13 2
a14 2
//    Timestamp: September 22, 2004
//    Version: 3.0
@


3.3.4.1
log
@Implement energy change.
Two ways are implemented:
     -  brute force,
     -  removal of the energy of atom before being boosted
        and addition of the energy of the boosted atoms.
Brute force is for every force field. Other method is for EAM only for now.


Sylvie Aubry - 02-17-05
@
text
@a339 8
void Particle::add_x(const double x_in[])
{
  x[0] += x_in[0];
  x[1] += x_in[1];
  x[2] += x_in[2];
}


@


3.3.4.2
log
@Fusion of ALex and Sylvie's versions.
Implementation of bins.
Add energy change.

saubry (04-06-05)
@
text
@d347 1
@


3.2
log
@Removing debugging cout statements.
@
text
@d440 2
a441 2
  v[1] = fac[0]*v[1];
  v[2] = fac[0]*v[2];
@


3.1
log
@Merging branch cjkimme_version with the trunk. testh and testi are kind
of questionable, but everything else looks ok.
@
text
@d363 1
a363 2
  } else
	cout << "Crickey\n";
d416 1
a416 2
  } else
	cout << "Crickey\n";
@


3.0
log
@Created a new version number, GRASP 3.0
@
text
@d58 4
a61 1
  charge = 0.0;
d65 4
a68 3
		   const int& colorin, 
		   const double xin[], const double& massin,
		   const double& chargein)
d84 6
d93 3
a95 3
		   const int& colorin,
		   const double xin[], const double& massin, 
		   const double& chargein, const double vin[])
d111 6
d120 1
a120 1
		   const double xin[], const double& chargein)
d132 5
d155 6
d180 6
d220 16
d245 15
d318 7
d335 10
d347 5
a351 3
  x[0]+=timestep*v[0];
  x[1]+=timestep*v[1];
  x[2]+=timestep*v[2];
d357 8
a364 5
  double dtmass;
  dtmass = timestepsq/mass;
  if (relax_coord[0]) x[0]+=dtmass*f[0];
  if (relax_coord[1]) x[1]+=dtmass*f[1];
  if (relax_coord[2]) x[2]+=dtmass*f[2];
d371 9
a379 12
  double dtmass;
  double step;
  dtmass = timestepsq/mass;

  if (relax_coord[0]) {
    step = dtmass*f[0];
    if (fabs(step) < maxstep) {
      x[0]+=step;
    } else {
      Lmaxstep = true;
      if (step>0.0) {
	x[0]+=maxstep;
d381 6
a386 1
	x[0]-=maxstep;
d389 5
a393 10
  }

  if (relax_coord[1]) {
    step = dtmass*f[1];
    if (fabs(step) < maxstep) {
      x[1]+=step;
    } else {
      Lmaxstep = true;
      if (step>0.0) {
	x[1]+=maxstep;
d395 6
a400 1
	x[1]-=maxstep;
d403 5
a407 10
  }

  if (relax_coord[2]) {
    step = dtmass*f[2];
    if (fabs(step) < maxstep) {
      x[2]+=step;
    } else {
      Lmaxstep = true;
      if (step>0.0) {
	x[2]+=maxstep;
d409 6
a414 1
	x[2]-=maxstep;
d417 2
a418 1
  }
d423 7
a429 5
  double dtmass;
  dtmass = timestep/mass;
  v[0]+=dtmass*f[0];
  v[1]+=dtmass*f[1];
  v[2]+=dtmass*f[2];
d448 1
a448 1
  b->Minimg_Pos(x);    
d454 1
a454 1
  b->Minimg_Pos_Full(x);
@


2.10
log
@Fixed bug in minimixer.cpp, and tweaked parameters to
improve performance. Result very sensitive to maxstep.
@
text
@d13 2
a14 1
//    Timestamp: July 26, 2004
@


2.9
log
@Updated header
@
text
@d282 1
a282 1
			    bool Lmaxstep)
@


2.8
log
@Added anisotropic style to pressure control,
and included in Tersoff example testp.
@
text
@d13 1
a13 1
//    Timestamp: 8 January 2004
@


2.7
log
@Added NPT ensemble. Noy sure if it is working
yet, and need to update documentation.
@
text
@d201 9
d345 7
@


2.6
log
@The primary change is the addition of the embedded atom method (EAM)
This is contained in the class Force_Eam. An example is contained
in the directory Testing/testl.

I also tweaked various parts of the code:
-Added epsilon shift to unit cell origin to avoid
pathologies associated with origin at zero
-Changed ndof from 3n to 3n-3
-Implemented localptr usertag arrays in class ParticleList
This enables user to pick whatever integer tags they want for
atoms, but the code generates internal tags 0,1,....nparticles_tot-1.
-Random velocities are now generated for all nparticles_tot particles,
but only assigned to local particles, so that velocity assignments
are independent of number of processors used.
-I got rid of the dreaded COSP neighboring scheme
-I added an example of Nose-Hoover thermostat in testm
-I added a warning for when force field type has no particle type match.
@
text
@d349 5
@


2.6.2.1
log
@Keeping track of displacements for each particle.
@
text
@a56 1
  X[0] = X[1] = X[2] = 0.0;
d61 2
a62 2
		   const int& colorin, const double xin[],
		   const double Xin[], const double& massin,
a78 3
  X[0] = Xin[0];
  X[1] = Xin[1];
  X[2] = Xin[2];
d82 2
a83 2
		   const int& colorin, const double xin[],
		   const double Xin[], const double& massin, 
a99 3
  X[0] = Xin[0]; 
  X[1] = Xin[1]; 
  X[2] = Xin[2];
d103 1
a103 1
		   const double xin[], const double Xin[], const double& chargein)
a114 3
  X[0] = Xin[0];
  X[1] = Xin[1];
  X[2] = Xin[2];
a132 3
  X[0] = p.X[0];
  X[1] = p.X[1];
  X[2] = p.X[2];
a151 3
    X[0] = p.X[0];
    X[1] = p.X[1];
    X[2] = p.X[2];
a185 16
void Particle::get_X(double X_out[]) const
{
  X_out[0] = X[0];
  X_out[1] = X[1];
  X_out[2] = X[2];
  return;
}

void Particle::get_u(double u_out[]) const
{
  u_out[0] = x[0]-X[0];
  u_out[1] = x[1]-X[1];
  u_out[2] = x[2]-X[2];
  return;
}

a243 7
void Particle::set_X(const double X_in[])
{
  X[0] = X_in[0];
  X[1] = X_in[1];
  X[2] = X_in[2];
}

d340 1
a340 1
  b->Minimg_Pos(x,X);    
d346 1
a346 1
  b->Minimg_Pos_Full(x,X);
@


2.6.2.2
log
@Committing changes to branch cjkimme_version before trying to merge changes
to the main branch onto branch cjkimme_version. Adding classes
for conjugate_gradient minimization along with two derived classes. One
is interfacial_minimizer which minimizes with respect to rigid translations
of groups of atoms. The other is grain_boundary_minimizer which minimizes
the zero temperature energy of a grain boundary allowing interlayer relaxation normal to the gb.
@
text
@d58 1
a58 3
  phi = 0.0;
  is_fixed = false;  // these two should always be set later
  to_be_minimized = false;
d64 1
a64 2
		   const double& chargein, const double& phiin,
		   const bool& fix_in, const bool& minimize_in)
a82 3
  phi = phiin;
  is_fixed = fix_in;
  to_be_minimized = minimize_in;
d88 1
a88 1
		   const double& chargein, const double vin[], const double& phiin, const bool& fix_in, const bool& minimize_in)
a106 3
  phi = phiin;
  is_fixed = fix_in;
  to_be_minimized = minimize_in;
a124 2
  is_fixed = false;
  to_be_minimized = false;
a145 3
  phi = p.phi;
  is_fixed = p.is_fixed;
  to_be_minimized = p.to_be_minimized;
a167 3
    phi = p.phi;
    is_fixed = p.is_fixed;
    to_be_minimized = p.to_be_minimized;
a226 15
 
double Particle::get_phi() const
{
  return phi;
}

bool Particle::get_fixed() const
{
  return is_fixed;
}

bool Particle::get_minimized() const
{
  return to_be_minimized;
}
a292 10
void Particle::set_phi(const double& phiin)
{
  phi = phiin;
}

void Particle::increment_phi(const double& eij)
{
  phi += eij;
}

d295 3
a297 5
  if (!is_fixed) {
    x[0]+=timestep*v[0];
    x[1]+=timestep*v[1];
    x[2]+=timestep*v[2];
  }
d303 5
a307 7
  if (!is_fixed) {
    double dtmass;
    dtmass = timestepsq/mass;
    if (relax_coord[0]) x[0]+=dtmass*f[0];
    if (relax_coord[1]) x[1]+=dtmass*f[1];
    if (relax_coord[2]) x[2]+=dtmass*f[2];
  }
d314 12
a325 9
  if (!is_fixed) {
    double dtmass;
    double step;
    dtmass = timestepsq/mass;

    if (relax_coord[0]) {
      step = dtmass*f[0];
      if (fabs(step) < maxstep) {
	x[0]+=step;
d327 1
a327 6
	Lmaxstep = true;
	if (step>0.0) {
	  x[0]+=maxstep;
	} else {
	  x[0]-=maxstep;
	}
d330 10
a339 5
    
    if (relax_coord[1]) {
      step = dtmass*f[1];
      if (fabs(step) < maxstep) {
	x[1]+=step;
d341 1
a341 6
	Lmaxstep = true;
	if (step>0.0) {
	  x[1]+=maxstep;
	} else {
	  x[1]-=maxstep;
	}
d344 10
a353 5
    
    if (relax_coord[2]) {
      step = dtmass*f[2];
      if (fabs(step) < maxstep) {
	x[2]+=step;
d355 1
a355 6
	Lmaxstep = true;
	if (step>0.0) {
	  x[2]+=maxstep;
	} else {
	  x[2]-=maxstep;
	}
d363 5
a367 7
  if (!is_fixed) {
    double dtmass;
    dtmass = timestep/mass;
    v[0]+=dtmass*f[0];
    v[1]+=dtmass*f[1];
    v[2]+=dtmass*f[2];
  }
@


2.6.2.3
log
@Committing merge of main trunk onto branch cjkimme_version.
@
text
@d13 1
a13 1
//    Timestamp: July 26, 2004
a264 9
void Particle::get_mvsq(vector <double>& kv_tmp) const {
  kv_tmp[0] = mass*v[0]*v[0];
  kv_tmp[1] = mass*v[1]*v[1];
  kv_tmp[2] = mass*v[2]*v[2];
  kv_tmp[3] = mass*v[0]*v[1];
  kv_tmp[4] = mass*v[0]*v[2];
  kv_tmp[5] = mass*v[1]*v[2];
}

d358 1
a358 1
			    bool& Lmaxstep)
a426 7
void Particle::scale_v(const double fac[])
{
  v[0] = fac[0]*v[0];
  v[1] = fac[0]*v[1];
  v[2] = fac[0]*v[2];
}

a436 5

void Particle::scale_x(const Box* b, const double dilation[]) {
  b->Scale_Pos(x,dilation);    
}

@


2.5
log
@Added a Perl script to Header.pl to prepend a header contained in
header.txt to source fiels, using

Header.pl *.pl *.cpp *.h M*[^~]
@
text
@d338 1
a338 1
void Particle::reset_x(const Box& b)
d340 1
a340 1
  b.Minimg_Pos(x);
d344 1
a344 1
void Particle::reset_full_x(const Box& b)
d346 1
a346 1
  b.Minimg_Pos_Full(x);
@


2.4
log
@Gutted the class Input, so that it is now a generic wrapper.
All the detailed treatment of each command is pushed down into
the relevant classes.
@
text
@d1 28
@


2.3
log
@Cleaned up various things, especially treatment of constants
and input strings.
@
text
@d5 1
d241 51
@


2.2
log
@Improved treament of log and error messages using new class Log.
Added minimization class Minimizer (currently only steepest descent).
Implemented Nsq neighboring for threebody forcefields.
Reinstated density profiles.
@
text
@d251 7
@


2.1
log
@This is a lot of stuff.  Basically, the code is now parallel,
but it is only tested for the force field twobody_lj_cut.

The parallelization scheme is based on Steve Plimptons Comm class.
@
text
@a5 1
extern ofstream logfile;
d9 2
d230 10
@


2.0
log
@*** empty log message ***
@
text
@a0 1
#ifdef DEBUG_ALLOCATION
d2 1
a2 1
#endif
d6 1
a14 1
  id[0] = '*';
d19 2
d28 21
a48 3
#ifdef DEBUG_ALLOCATION
  cout << " Creating particle of type " << type << endl;
#endif
d52 3
a54 3
		   const string& idin, const int& colorin,
		   const double xin[], const double vin[], 
		   const double& chargein)
a57 1
  id = idin;
d62 2
a66 1
  charge = chargein;
a69 3
#ifdef DEBUG_ALLOCATION
  cout << " Creating particle of type " << typein << endl;
#endif
d72 1
a72 2
Particle::Particle(const int& typein, const int& tagin, 
		   const string& idin, const int& colorin, 
a76 2
  id = idin;
  color = colorin;
d80 1
a80 3
  v[0] = 0.0;
  v[1] = 0.0;
  v[2] = 0.0;
a84 3
#ifdef DEBUG_ALLOCATION
  cout << " Creating particle of type " << typein << endl;
#endif
a88 3
#ifdef DEBUG_ALLOCATION
  cout << " Copying particle of type " << p.type << endl;
#endif
a90 1
  id = p.id;
d95 2
a102 1
  charge = p.charge;
a109 1
    id = p.id;
d114 2
a121 1
    charge = p.charge;
a127 3
#ifdef DEBUG_ALLOCATION
  cout << " Destroying particle type " << type << endl;
#endif
a134 5
string Particle::get_id() const
{
  return id;
}

a180 5
void Particle::set_id(const string& idin)
{
  id = idin;
}

d186 1
a186 1
void Particle::set_x(const double x_in[], const Box& b)
a190 1
  b.Minimg_Pos(x);
@


1.6
log
@Added configuration output routine to Box.
Added shifted origin to minimg routines.
Cleaned up minimg routines to consistently
Deal with following issues:
	orthorhombic versus triclinic
	inner-loop Minimig_Dist functions only perform single box shift,
		as it is more efficient than general shift.
	For this reason, standard Minimg_Pos function also only
		performs single box shift, but also checks that
		aparticles have not strayed too far.
	Initial config may require more than single box shift, and
		so for this we use Minimg_Full_pos.
Treatment of equality conditions:
	Positions on )0,1[ are mapped onto [0,1).
	Positions on [0,1) are left alone.
	Distances on )-1,1( should not occur
	Distances on )-0.5,0.5( are mapped (-0.5,0.5).
	Distances on [-0.5,0.5] are left alone.
@
text
@a0 2
using namespace std;

d6 2
a258 1

@


1.5
log
@Fixed a variety of bugs related to energy conservation.
Add kinetic energy and temperature calculation.
LJ and Stillinger-Weber forcefields fully tested against
TOWHEE and energy conservation.
@
text
@d255 6
@


1.4
log
@Created an abstract class Forcefield, with derived classes Force_Twobody
and Force_Threebody.
Implemented Stillinger-Weber forcefield within Force_Threebody.
Unfortunately, the COSP neighboring method does not work for
threebody forces, so we currently do not have neighbor lists
for threebody interactions.  Probably need to use LAMMPS-like
ghost atom method and standard neighbor list structures.
@
text
@d7 1
d15 1
a15 1
  id = 0;
d33 1
a33 1
		   const int& idin, const int& colorin,
d57 1
a57 1
		   const int& idin, const int& colorin, 
d133 1
a133 1
int Particle::get_id() const
d169 5
d184 1
a184 1
void Particle::set_id(const int& idin)
d243 1
a243 3
  //See units.txt for explanation of 100 fs time unit. 
  //Eventually need to formalize this with a global constant.
  dtmass = 0.01*timestep*mass;
@


1.3
log
@

Added neighbor list object.
@
text
@a7 3
#include "particle_types.h"
#include "neighbor.h"
#include "force_twobody.h"
a124 5
}

int Particle::get_type() const
{
  return type;
@


1.2
log
@
Added ReadParticleTypes, and improved organization of input,
including error checking.
@
text
@a7 1
#include "box.h"
d9 1
d11 1
d235 1
a235 1
void Particle::step_x(const double& timestep, const Box& b)
a239 1
  b.Minimg_Pos(x);
d252 6
@


1.1
log
@Starting source distribution for Grasp.
Basic molecular dynamics code with twobody interactions
@
text
@d170 5
d224 10
d244 7
a250 3
  v[0]+=timestep*f[0];
  v[1]+=timestep*f[1];
  v[2]+=timestep*f[2];
@

